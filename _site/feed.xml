<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-09-01T17:48:13+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">KEEPMIND</title><subtitle>A place I record so that I don&apos;t forget.</subtitle><author><name>Joonsu Ryu</name></author><entry><title type="html">Data Types</title><link href="http://localhost:4000/pl/data-types/" rel="alternate" type="text/html" title="Data Types" /><published>2023-09-01T00:00:00+09:00</published><updated>2023-09-01T00:00:00+09:00</updated><id>http://localhost:4000/pl/data-types</id><content type="html" xml:base="http://localhost:4000/pl/data-types/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;6장에서는 데이터 타입의 개념과 각 데이터 타입의 특성을 소개합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;데이터 타입(Data Type)&lt;/span&gt;은 데이터 값들의 모임과 그 값들에 대해 미리 정의된 연산들의 집합으로 정의됩니다. 프로그램은 데이터를 토대로 여러 연산을 통해 결과를 도출하기 때문에, 사용하는 언어에서 제공하는 데이터 타입이 현실의 문제와 얼마나 잘 매칭되는가가 중요합니다.&lt;/p&gt;

&lt;p&gt;몇 가지 사례를 소개하자면, Fortran 90 이전에는 기본적인 데이터 구조만을 지원했기 때문에, 연결 리스트나 트리가 모두 배열로 구현되었습니다. COBOL은 십진수의 데이터 값과 레코드를 위한 데이터 타입을 지원했습니다. PL/I는 다양한 분야에 사용하는 것을 목적으로 만들어졌기 때문에 많은 데이터 타입을 지원하였습니다. ALGOL 68은 기본적인 데이터 타입을 지원하되, 필요한 경우 사용자가 직접 만들 수 있는 데이터 타입을 지원하였습니다. Ada 언어에 이르러서는 추상 데이터 타입을 지원하기 시작했습니다. 추상 데이터 타입은 직접적으로 구현 방법을 명시하지는 않고 데이터와 데이터에 대한 연산을 나타내는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;원시 데이터 타입(Primitive Data Type)&lt;/span&gt;은 다른 타입의 관점에서 정의되지 않은 데이터 타입을 말합니다. 즉, 언어에서 기본적으로 제공하는 데이터 타입이라고 생각하시면 됩니다. 이러한 데이터 타입은 표현과 연산이 하드웨어에서 지원하는데, 구조화된 타입을 제공하기 위해서는 원시 데이터 타입과 함께 한 개 이상의 타입 생성자가 함께 사용됩니다.&lt;/p&gt;

&lt;p&gt;원시 데이터 타입 중 &lt;strong&gt;수치 타입(Numeric Type)&lt;/strong&gt;에 대해 알아보겠습니다. 수치 타입 중 가장 대표적인 타입이 바로 &lt;span style=&quot;color:red&quot;&gt;정수(Integer)&lt;/span&gt;입니다. 정수형 타입은 컴퓨터에 따라 다른 크기가 지원되는데, 예를 들어 byte, word, long word, quadword 등이 있습니다. C, C++, C# 등과 같은 언어에서는 부호가 없는 정수(Unsigned Int) 타입을 지원하는데, 이것은 주로 이진 데이터에 대해 사용합니다.&lt;/p&gt;

&lt;p&gt;Word가 실제로 메모리에 차지하는 비트의 수는 컴퓨터의 CPU에 따라 달라집니다. (16비트 컴퓨터, 32비트 컴퓨터 등)&lt;/p&gt;

&lt;p&gt;정수 자료형을 구현할 때는 비트 문자열로 표기하며, 일반적으로 가장 왼쪽에 있는 비트는 부호를 나타냈습니다. 그러나 최근에는 덧셈과 뺄셈 연산이 편리한 2의 보수(2’s Compliment) 표기법을 많이 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실수를 모델링하기 위해서는 일반적으로 &lt;span style=&quot;color:red&quot;&gt;부동 소수점(Floating Point)&lt;/span&gt;을 사용합니다. 그러나 부동 소수점은 대부분 실수 값을 근사할 뿐입니다. 많이 사용되는 실수인 $\pi$나 $e$ 조차 정확하게 표기가 불가능합니다. 예를 들어 십진수 0.1을 부동 소수점으로 표기한다면, 이진수 0.0001100110011…로 정확하게 표현되지 않습니다.&lt;/p&gt;

&lt;p&gt;부동 소수점 데이터 타입은 대부분의 언어에 포함되어 있지만, 많은 소형 컴퓨터에서는 하드웨어에서 지원하지 않는 경우가 많습니다. 이런 경우 고정 소수점 방식을 사용하거나, 아니면 근사치를 나타낸 표를 저장하여 처리하기도 합니다. 그러나 이런 경우까지 고려하실 필요는 없고, 과학적인 프로그래밍을 지원하는 언어에서는 일반적으로 float와 double이라는 두 가지 타입을 제공합니다.&lt;/p&gt;

&lt;p&gt;부동 소수점은 IEEE 754 규격을 이용하여 구현하는데, 이것은 부호 비트, 지수부, 소수부로 구성되어 있습니다. double 타입은 일반적으로 더 정밀한 소수를 표현하기 위해서 사용하므로, float 타입에 비해 두 배 이상의 소수부를 갖고 있는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비즈니스 업무에 사용하는 것이 상정된 컴퓨터들은 하드웨어에서 &lt;span style=&quot;color:red&quot;&gt;십진수(Decimal)&lt;/span&gt; 데이터 타입을 지원합니다. 십진수 타입은 부동 소수점과 다르게 제한된 범위 내에서 소수 값을 정확하게 저장할 수 있는 장점이 있습니다. 대표적인 십진수 데이터 타입은 &lt;strong&gt;BCD(Binary Coded Decimal)&lt;/strong&gt;로, 이진수 코드를 사용하여 문자열과 비슷하게 저장하는 방식입니다. BCD에는 packed 방식과 unpacked 방식이 있습니다. unpacked 방식은 자리수 하나당 1개의 바이트를 이용해서 표현하는 방식이고 (4개는 의미 없음), packed 방식은 2개의 자리를 1개의 바이트로 압축하여 표현하는 방식입니다. unpacked 방식의 경우 남는 4개의 비트를 1로 채우지만, 마지막 글자의 경우 숫자가 양수인지 음수인지에 따라 다릅니다. 양수의 경우 1100, 음수의 경우에는 1101로 표현합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;불리안 타입(Boolean Type)&lt;/span&gt;은 참과 거짓만 나타낼 수 있는 가장 간단한 데이터 타입입니다. ALGOL 60에서 처음 도입되었으며, 스위치나 플래그를 표현하기 위해서 사용합니다. 불리안 타입은 한 개의 비트로 표현이 가능하지만, 컴퓨터에서 한 개의 비트를 효율적으로 접근할 수 없기 때문에 읿나적으로 1개의 바이트로 구현됩니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;문자 타입(Character Type)&lt;/span&gt;은 일반적으로 수치 값으로 컴퓨터에 저장됩니다. 가장 많이 사용하는 기법은 ASCII(American Standard Code for Information Interchange)로써 0부터 127까지의 값을 사용합니다. 그러나 세계화가 이루어짐에 따라 128개의 글자가 부족해졌고, 결국 1991년 Unicode라는 새로운 규격이 만들어졌습니다. C 언어와 C++ 언어는 계속 ASCII 코드를 사용하지만, Java, Python과 같이 그 뒤에 나온 언어들은 Unicode를 사용하여 문자를 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;문자열 타입(Character String Type)&lt;/span&gt;은 문자들로 구성되는 타입입니다. 문자열은 문자 조작을 하는 모든 프로그램에서 필수적인 데이터 타입입니다. 문자열 타입을 설계할 때 중요한 두 가지 고려사항이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스트링이 원시 타입인가, 아니면 단순히 문자 배열의 특수한 종류인가?&lt;/li&gt;
  &lt;li&gt;스트링이 정적의 길이를 갖는가, 아니면 동적인 길이를 갖는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저 첫 번째 고려사항부터 살펴보겠습니다. 문자열을 단순히 문자의 배열로 취급하는 대표적인 언어가 바로 C 언어입니다. 이러한 언어들에서는 표준 라이브러리를 통해 문자열 연산 기능을 제공하며(string.h), 널 문자(\0)를 이용하여 문자의 끝을 나타냅니다.&lt;/p&gt;

&lt;p&gt;반대로 문자열을 원시 타입으로 제공하는 언어들도 있습니다. Java나 Python이 채택한 방법인데, 이러한 방법은 언어의 작성력이 증가하며 그에 따른 비용도 크지 않다는 장점이 있습니다. 원시 타입으로 문자열 타입을 제공할 경우, 할당, 관계 연산자, 연결 및 하위 문자열 참조와 같은 기능을 기본 연산으로 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로는 문자열 길이에 관한 고려사항입니다. 생성될 때 길이가 같이 정해지는 문자열을 &lt;span style=&quot;color:red&quot;&gt;정적 길이 스트링(Static Length String)&lt;/span&gt;이라고 합니다. Fortran 77과 90, COBOL, Ada 언어에서 기본적으로 제공하는 문자열이 바로 이런 방식입니다.&lt;/p&gt;

&lt;p&gt;다른 방법으로는 문자열 변수를 선언할 때 길이가 같이 선언되지만, 고정된 최대 길이까지 가변적인 길이를 갖는 것을 허용하는 &lt;span style=&quot;color:red&quot;&gt;제한된 동적 길이 스트링(Limited Dynamic Length String)&lt;/span&gt;이 있습니다. C 언어에서의 문자열이 바로 이런 구조입니다. 왜냐하면 문자열의 길이를 나타낼 때, 배열의 길이 자체가 변하는 것이 아니라 널 문자가 어디에 있는지에 따라 문자열의 끝이 달라지기 때문입니다.&lt;/p&gt;

&lt;p&gt;마지막 방법은 문자열이 최대 길이의 제한 없이 가변 길이를 갖는 것을 허용하는 &lt;span style=&quot;color:red&quot;&gt;동적 길이 스트링(Dynamic Length String)&lt;/span&gt; 방식입니다. JavaScript나 C++ 언어가 이러한 방식을 채택하고 있는데, 동적 기억공간 할당과 회수에 따른 부담이 늘어나지만 유연성을 갖는다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;특이하게 Ada95+는 이 세 가지 방법을 모두 지원합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문자열 타입은 언어의 작성력에 중요한 요소입니다. 문자열을 배열로 다루는 것은 원시 타입으로 다루는 것보다 더 복잡해질 수 있습니다. 예를 들어, C 언어에서 strcpy를 사용하지 않고 구현한다고 하면 반복문이 반드시 필요합니다. 프로그래밍 언어에서 문자열을 원시 타입으로 추가하는 것은 비용도 거의 들지 않는 일이기 때문에 굉장히 비효율적인 일입니다. 따라서 현대 프로그래밍 언어에서는 대부분 문자열을 원시 타입으로써 제공합니다. 패턴 매칭이나 접합과 같은 연산은 대부분의 프로그램에서 필수적이기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문자열 타입은 하드웨어에서 직접 지원될 수도 있지만, 대부분의 경우에는 소프트웨어로써 구현됩니다. 만약 문자열 타입이 문자 배열로 표현되는 경우에는 언어 자체에서 문자열 관련 연산을 거의 제공하지 않습니다.&lt;/p&gt;

&lt;p&gt;정적 길이 스트링에서 변수의 속성 모음(Descriptor)은 컴파일 과정에서만 요구되며, 변수 이름, 길이, 첫 번째 문자가 저장된 주소입니다. 제한된 동적 길이 스트링에서는 변수 이름, 첫 번째 문자가 저장된 주소, 최대 길이, 현재 길이가 저장되며 실행 시간 속성 모음이 필요합니다. 이 두 방법에서는 동적 기억공간 할당이 필요하지 않습니다. 제한된 동적 길이 스트링도 변수가 기억공간에 바인딩될 때 최대 길이까지 저장할 수 있는 크기만큼 할당되기 때문입니다.&lt;/p&gt;

&lt;p&gt;그러나 동적 길이 스트링의 구현은 다소 복잡합니다. 첫 번째 방법은 연결 리스트에 문자열을 저장하는 것입니다. 만약 문자열의 길이가 늘어난다면 새로 필요한 기억공간은 힙의 무작위 위치에서 생성됩니다. 이 방법은 보다 많은 공간이 필요하고 접근도 느리다는 단점이 있습니다. 두 번째 방법은 문자열 전체를 인접한 기억공간에 저장하는 것입니다. 문제는 동적 길이 스트링은 문자열이 얼마나 늘어날지 예측할 수 없다는 것입니다. 따라서 이 방법에서 문자열의 길이가 늘어난다면, 문자열 전체를 저장할 수 있는 새로운 영역으로 이동합니다. 이 방법은 첫 번째 방법에 비해 접근이 빠르고 저장공간을 비교적 적게 차지하지만, 할당 시간이 느리다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;순서 타입(Ordinal Type)&lt;/span&gt;은 가능한 값의 범위가 양의 정수의 집합과 관련이 있는 타입입니다. Pascal이나 Java에서 제공하는 기본 순서 타입은 Integer, char, boolean 등이 있습니다. 일반적으로 프로그래밍 언어에서 지원하는 사용자 정의 순서 타입은 &lt;strong&gt;열거(Enumeration)&lt;/strong&gt; 타입과 &lt;strong&gt;부분범위(Subrange)&lt;/strong&gt; 타입입니다.&lt;/p&gt;

&lt;p&gt;열거 타입은 기호 상수(Symbolic Constant)인 모든 가능한 값들이 열거되는 타입입니다. 대표적으로 슬라이드에 나온 Ada 언어에서 요일을 저장한 타입이 있습니다. 이러한 열거 타입은 전형적으로 0, 1, … 등의 정수가 할당되지만, 정의에 따라 임의의 정수가 할당될 수도 있습니다. 열거 타입을 설계할 때 고려할 것들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;열거 상수가 한 개 이상의 타입 정의에 나타나는 것이 허용되는가?&lt;/li&gt;
  &lt;li&gt;그렇다면, 프로그램에서 이러한 상수 참조시 그 타입이 어떻게 검사되는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 고려 사항들은 타입 검사와 관련이 있습니다. 만약 열거 변수가 수치 타입으로 강제 변환되면, 연산들의 범위나 값들에 대한 제어가 없습니다. 따라서 이제부터 각각 언어에서 열거 타입을 어떻게 구현하였는지 자세히 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal, C, C++ 언어 같은 경우에 열거 상수는 주어진 참조 환경에서 둘 이상의 열거 타입에 사용될 수 없습니다. 또한 열거형 변수는 배열 첨자, 반복문의 변수, Case 문의 선택기로도 사용할 수 있습니다. 또한 관계 연산자와도 비교할 수 있습니다. 이러한 것들이 가능한 이유는, 열거 변수가 정수 문맥에서 사용될 때 정수형 변수로 강제 변환되기 때문입니다. 그러나 반대로 다른 타입의 값이 열거 타입으로 강제 변환되지는 않습니다.&lt;/p&gt;

&lt;p&gt;Ada 언어 같은 경우에는 동일 환경에서 열거 상수가 두 개 이상의 선언에서 정의될 수 있습니다. 이것을 &lt;span style=&quot;color:red&quot;&gt;중복 리터럴(Overloaded Literal)&lt;/span&gt;이라고 부릅니다. Ada에서는 타입 검사를 위해 열거 변수가 정수형 변수로 강제 변환되지 않습니다. 이는 컴파일 시간에서 문맥 오류를 탐지하는 것을 가능하게 합니다.&lt;/p&gt;

&lt;p&gt;열거 타입을 사용하는 이유는 매우 직접적인 방식으로 가독성을 증가시키기 때문입니다. 이름을 통해 정의된 값은 쉽게 인식되지만, 숫자로 코드화할 경우 쉽게 인식하기 어렵기 때문입니다. 숫자형 데이터 타입과 비교했을 때, 산술 연선이 불가능하고 범위 오류를 쉽게 감지할 수 있다는 장점이 있습니다. 열거형 변수에는 정의된 범위 밖의 값을 할당할 수 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부분 범위 타입은 순서 타입의 연속된 부분 순서열입니다. 예를 들면, Pascal 언어에서 index를 1부터 100까지의 범위를 갖는 변수로 설정했습니다. 이것은 정수의 연속된 부분 순서열이라고 볼 수 있습니다. 부분 범위 타입을 사용하는 이유는 가독성과 안정성이 증가하기 때문입니다. 간단한 타입이기 때문에, 설계할 때 고려사항은 딱히 없습니다. 다만 왜인지 Ada 95 이후로는 대부분의 언어에서 부분 범위 타입을 지원하지 않습니다. (왜 그런지 교재 제작자도 이상하게 생각하더라구요)&lt;/p&gt;

&lt;p&gt;앞서 소개한 대로, 이러한 사용자 정의 순서 타입의 구현은 보통 (음이 아닌) 정수로 구현됩니다. 부분 범위 타입은 범위 검사가 포함되어야 한다는 점만 제외하면 상위 유형(정수형 타입)과 동일한 방식으로 구현됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;배열(Array)&lt;/span&gt;은 동질적인 데이터 원소들의 묶음으로, 개개의 원소는 배열의 첫 번째 원소와 상대적인 위치에서 식별됩니다. 배열의 원소들은 모두 동일한 데이터 타입을 갖고, 배열 원소에 대한 참조는 대괄호와 같은 첨자 식을 이용하여 나타냅니다. 이 때, 참조되고 있는 메모리 위치의 주소를 결정하기 위해 실행 시간 계산이 추가로 필요합니다.&lt;/p&gt;

&lt;p&gt;배열 타입을 설계할 때 고려해야할 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아래 첨자에는 어떤 유형이 적합한가? (정수형, 순서형 등)&lt;/li&gt;
  &lt;li&gt;아래 첨자의 범위는 언제 바인딩되는가? (실행 시간 vs 컴파일 시간)&lt;/li&gt;
  &lt;li&gt;배열 할당은 언제 발생하는가? (실행 시간 vs 컴파일 시간)&lt;/li&gt;
  &lt;li&gt;아래 첨자는 몇 개나 허용되는가? (가능한 차원의 수)&lt;/li&gt;
  &lt;li&gt;공간이 할당될 때 배열이 초기화되는가?&lt;/li&gt;
  &lt;li&gt;어떤 종류의 슬라이스가 존재하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 페이지부터 이러한 고려 사항을 하나씩 따져보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열의 원소들은 두 단계의 구문 메커니즘에 의해 참조됩니다. 첫 번째는 배열의 이름이고, 두 번째는 첨자나 색인입니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a[100]&lt;/code&gt;과 같이 참조할 때, a가 배열의 이름이고, 100이 첨자입니다. 선택 연산은 배열 이름과 첨자로부터 하나의 원소로 매핑하는 것으로 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;배열에서 첨자를 표시할 때 소괄호를 이용하는 경우도 있고 대괄호를 이용하는 경우도 있습니다. Fortran과 PL/I이 개발되었을 당시에는 첨자를 나타낼 적절한 문자가 없었기 때문에 소괄호를 선택하였습니다. 그러나 소괄호를 사용하는 경우에는 함수에서 인자를 호출하는 것과 혼동될 여지가 있었기 때문에, 90년대 이후로는 대괄호를 이용하여 첨자를 표시하게 됩니다.&lt;/p&gt;

&lt;p&gt;배열의 첨자 타입은 일반적으로 정적으로 바인딩됩니다. 먼저 첨자 범위의 하한은 C 계열 언어에서 0으로 정의되며, Fortran 1, 2, 4에서는 1로 고정됩니다. Fortran 77과 90에서도 기본적으로 1로 설정되어 있지만, 임의의 정수로 설정할 수 있습니다. 이 범위가 프로그래머로부터 명시적으로 선언되어야 하는 언어도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열 첨자의 범위에 대한 바인딩과 저장공간에 대한 바인딩을 토대로 다음과 같이 네 가지 종류로 나눌 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;정적 배열(Static Array)&lt;/strong&gt; : 첨자의 범위와 기억공간 할당이 모두 정적으로 바인딩되는 배열입니다. 따라서 실행 시간 전에 바인딩이 끝나며, 동적 할당이나 회수가 이루어지지 않기 때문에 매우 효율적이라는 장점이 있습니다. Fortran 77의 배열이 이 방법을 채택하고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고정 스택 동적 배열(Fixed Stack Dynamic Array)&lt;/strong&gt; : 첨자의 범위는 정적으로 바인딩되지만, 기억공간 할당이 실행 시간 중에 발생하는 배열입니다. 두 개의 부프로그램이 있고, 각각 고정 스택 동적 배열을 갖고 있다면 동시에 실행되지 않는 한 그 배열들은 기억공간을 공유하기 때문에 기억공간을 효율적으로 사용할 수 있다는 장점이 있습니다. 대신 할당과 회수 시간이 별도로 소모되는 단점도 있습니다. Pascal의 지역 배열이 이 방법을 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스택 동적 배열(Stack Dynamic Array)&lt;/strong&gt; : 첨자의 범위와 기억공간의 바인딩이 모두 실행 시간 중에 동적으로 바인딩되는 배열입니다. 그러나 일단 첨자 범위가 바인딩되고 기억공간이 할당되면 변수의 수명 동안 고정됩니다. 이 방법은 배열이 사용되기 전까지 미리 선언할 필요가 없기 때문에 유연성이 높다는 장점이 있습니다. C언어가 대표적으로 이 방법을 사용하고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;힙 동적 배열(Heap Dynamic Array)&lt;/strong&gt; : 첨자의 범위와 기억공간의 바인딩이 모두 동적이며, 배열의 수명 동안 변경이 가능한 배열입니다. 스택 동적 배열보다 더 유연하다는 장점이 있습니다만, 힙으로부터 할당과 해제가 일어나기 때문에 더 느리다는 단점이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여담으로 다양한 데이터 타입을 저장할 수 있는 배열도 있습니다. 이러한 배열을 &lt;span style=&quot;color:red&quot;&gt;이기종 배열(Heterogeneous Array)&lt;/span&gt;이라고 부르는데, 배열의 원소가 동일한 데이터 타입일 필요가 없는 배열입니다. Perl, Python, JavaScript, Ruby 등에서 지원되며, 이 배열은 그 특성상 힙 동적 배열로 정의됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 다룰 내용은 배열의 첨자 수에 관한 설계입니다. 프로그래밍 언어의 역사에서 다루었듯이, Fortran I의 경우에는 첨자를 3개까지만 허용했습니다. 즉, 3차원 배열까지만 생성이 가능했다는 것입니다. 이후 Fortran 77과 90에서는 최대 7개를 지원했고, 그 이후 등장한 언어들에서는 무제한 차원의 배열이 가능했습니다.&lt;/p&gt;

&lt;p&gt;의외로 C 언어는 1개의 첨자만 사용할 수 있습니다. 그러나 배열 자체가 배열의 원소가 될 수 있으므로, 다차원 배열의 생성이 가능한 것입니다. 이와 같은 방식을 &lt;span style=&quot;color:red&quot;&gt;직교 설계(Orthogonal design)&lt;/span&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;몇몇 언어는 배열이 기억공간에 할당되는 시점에 배열을 초기화하는 방법을 제공합니다. 예를 들어, Fortran 77에서는 모든 데이터가 정적으로 할당되므로 DATA문을 사용한 로드 시간 초기화가 허용됩니다.&lt;/p&gt;

&lt;p&gt;C 언어 또한 정적 배열을 이용한 초기화가 가능합니다. 그러나 동적 배열은 이런식으로 초기화가 불가능합니다.&lt;/p&gt;

&lt;p&gt;Pascal이나 Modular-2와 같은 언어에서는 프로그램 선언에서 배열 초기화를 허용하지 않습니다.&lt;/p&gt;

&lt;p&gt;Ada 언어는 두 가지 방법으로 배열 초기화가 가능합니다. 값을 저장하는 순서대로 나열하는 방법과 =&amp;gt; 연산자를 사용하여 값들을 색인 위치에 직접 할당하는 방법입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;배열 연산(Array Operations)&lt;/span&gt;은 배열 단위로 연산을 수행하는 것을 말합니다. 예를 들어, 배정, 접합, 비교, 슬라이스 등이 있습니다. 이 중 슬라이스는 다음 장에서 따로 논의하도록 하고, 여기에서는 나머지 케이스만을 다루겠습니다.&lt;/p&gt;

&lt;p&gt;Fortran 90에서는 elemental 이라고 부르는 배열 연산을 제공합니다. 제공하는 연산들이 배열 원소들의 쌍(Pair) 연산이기 때문에 그렇게 이름이 붙었다고 합니다. 대표적으로 + 연산은 두 배열의 원소 쌍들의 합을 계산한 배열입니다. 이 외에도 할당, 산술, 관계 및 논리 연산자는 모든 크기의 배열에 대해 오버로딩되어 있습니다.&lt;/p&gt;

&lt;p&gt;APL은 가장 강력한 배열 연산을 지원하는 언어입니다. +, -, *, / 4가지 기본 산술 연산은 물론, 벡터, 행렬, 스칼라 피연산자에 대해서도 정의되어 있습니다. 내적, 외적 연산까지 지원합니다.&lt;/p&gt;

&lt;p&gt;C 언어는 기본적으로 배열 연산을 지원하지 않습니다. Java나 C++ 언어는 메소드를 통해 일부만 지원하며, Python은 배열 접합이나 비교, 원소 추가와 관련된 일부 연산을 지원합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열의 &lt;span style=&quot;color:red&quot;&gt;슬라이스(Slice)&lt;/span&gt;는 배열의 부분 구조입니다. 예를 들어, Fortran 90 언어에서 MAT(1:3, 2)는 1행부터 3행까지 2번째 열을 잘라서 만든 부분 배열이고, MAT(2:3, 1:3)은 2행부터 3행까지에서 1열부터 3열까지 자른 부분 배열입니다.&lt;/p&gt;

&lt;p&gt;Python 언어는 더 복잡한 슬라이스를 지원합니다. 예를 들어, vector[0:7:2]는 배열의 0부터 7까지 슬라이스하는데, 2 단위로 원소들을 슬라이스하는 명령어입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열을 구현하는 것은 원시 타입을 구현하는 것보다 훨씬 더 많은 노력이 필요합니다. 왜냐하면 효율적인 실행 시간 접근을 위해서는 배열에 대한 접근 방법이 컴파일 시간에 만들어져야 하기 때문입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, list[k]의 주소를 계산한다고 가정해봅시다. 1차원 배열은 각각의 원소가 인접한 메모리로 바인딩되기 때문에 (배열 list의 시작 첨자가 1이라면) list[k]의 주소 = list[1]의 주소 + (k - 1) * 원소의 크기 로 계산할 수 있을 것입니다. 원소의 타입이 정적으로 바인딩되고, 배열이 기억공간에 정적으로 바인딩되면 이 식은 실행 시간 전에 계산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 식을 컴파일 시간 내에 계산하기 위해서는 1차원 배열에 대한 속성이 그림과 같은 구조로 설정되어야 합니다. 만약 이러한 항목들이 동적으로 바인딩된다면, 배열의 주소는 실행 시간에 계산할 수밖에 없습니다.&lt;/p&gt;

&lt;p&gt;다차원 배열은 1차원 배열보다 구현하기 복잡합니다. 하드웨어 메모리는 일반적으로 선형으로 구성되어 있기 때문에, 다차원 배열을 1차원 배열로 매핑해야만 합니다. 이 때, 1차원 배열로 매핑하는 방법은 &lt;span style=&quot;color:red&quot;&gt;행 우선 순서(Row Major Order)&lt;/span&gt;와 &lt;span style=&quot;color:red&quot;&gt;열 우선 순서(Column Major Order)&lt;/span&gt;로 나눌 수 있습니다. 행 우선 순서는 1행의 내용을 저장 - 2행의 내용을 저장 - 3행의 내용을 저장 - … 순서대로 저장하는 방식이고, 열 우선 순서는 1열의 내용을 저장 - 2열의 내용을 저장 - 3열의 내용을 저장 - … 순서대로 저장하는 방식입니다. 대부분의 명령형 언어에서는 행 우선 순서대로 저장을 하며, Fortran과 같은 일부 언어에서만 열 우선 저장을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다차원 배열에서 &lt;span style=&quot;color:red&quot;&gt;접근 함수(Access Function)&lt;/span&gt;는 기반 주소와 참조 값들의 집합을 메모리 주소로 매핑하는 함수입니다. 예를 들어, 행 우선 순서로 2차원 배열에 대한 접근 함수를 구해보겠습니다. 시작 주소가 a[1,1]로 주어진 상황에서, 임의의 배열 원소인 a[i,j]의 주소를 계산한다면 a[1,1]의 주소 + ((i-1)*n +(j-1)) * 원소의 크기로 계산할 수 있습니다. 이 식에서 i와 j 부분은 그 값에 따라 달리지기 때문에, 상수와 변수 부분을 구분해서 정리하면 a[1,1]의 주소 - (n+1) * 원소의 크기 + (i * n + j) * 원소의 크기로 바꿔쓸 수 있습니다. 이를 반영하여, 다차원 배열에서 컴파일 시간에 계산할 수 있는 속성은 위 슬라이드의 마지막 그림과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 슬라이드는 3차원 배열에서 특정 배열 원소의 주소를 행 우선 순서/열 우선 순서로 계산하는 것을 나타낸 슬라이드입니다. 계산 방법은 쉽게 설명되어 있으니 한번 읽고 넘어가시면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;연상 배열(Associative Array)&lt;/span&gt;은 &lt;strong&gt;키(Key)&lt;/strong&gt;라고 불리는 원소의 개수와 동일한 개수의 값들로 참조되는 정렬되지 않은 배열을 말합니다. 일반적인 배열에서 색인 값은 전혀 정의할 필요가 없지만, 연상 배열에서는 색인 값도 키와 함께 정의되어야 합니다. 따라서 연상 배열의 실제 원소는 키와 값의 쌍으로 이루어져 있습니다. Perl, Python, Ruby 등의 언어에서는 연상 배열을 기본적으로 지원하며, Java나 C++ 언어에서는 표준 클래스 라이브러리로써 지원합니다. (ex. HashMap)&lt;/p&gt;

&lt;p&gt;Perl 언어에서 연상 배열은 &lt;strong&gt;해쉬(Hash)&lt;/strong&gt;라는 이름으로 지원됩니다. 모든 해쉬 변수는 % 기호로 시작해야 하며, =&amp;gt; 연산자 를 이용해 키와 값을 배정합니다. Python 언어에서는 &lt;strong&gt;사전(Dictionary)&lt;/strong&gt; 자료형을 통해 연상 배열을 지원합니다.&lt;/p&gt;

&lt;p&gt;해쉬의 장점은 원소에 접근할 때 일반적인 배열보다 매우 효율적이라는 것입니다. 왜냐하면 원소에 접근할 때 사용하는 해쉬 연산이 배열보다 효율적이기 때문입니다. 따라서 만약 취급할 데이터가 이름과 급료와 같이 쌍으로 구성되어 있다면 해쉬를 사용하는 것이 좋습니다. 그러나 리스트의 모든 원소를 처리해야하는 경우네는 배열을 사용하는것이 더 낫습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;레코드(Record)&lt;/span&gt;는 각각의 원소들이 이름으로 식별되고 다양한 데이터 타입을 가질 수 있는 자료형입니다. 이러한 자료형은 1960년대 초 COBOL에서 처음 도입된 이후 가장 인기있었던 프로그래밍 언어의 요소였습니다. 배열과 비교해보자면, 배열은 색인을 통해 원소에 접근하고 모든 원소가 동일한 데이터 타입을 갖지만, 레코드는 식별자로 원소에 접근하고 원소가 다양한 데이터 타입을 가질 수 있다는 차이점이 있습니다. 예를 들면, 학생의 정보를 저장할 때 이름은 문자열, 학번은 정수, 학점은 실수로 저장해 만드는 자료형이라고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;레코드의 구조는 언어마다 조금씩 다르게 지원합니다. 최초로 레코드를 지원했던 COBOL을 예로 들면, EMPLOYEE-RECORD 레코드는 EMPLOYEE-NAME과 HOURLY-RATE로 구성되어 있습니다. 앞의 01, 02, 05는 수준 번호로써 레코드의 계층 구조를 나타내며, PICTURE는 기억공간 형식을 나타냅니다. X(20)은 최대 20개의 글자로 이루어진 자료형을 나타내며, 99V99는 중간에 소수점을 갖는 4개의 십진수 숫자라는 의미입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어는 COBOL과는 다르게 계층 번호를 사용하지 않고 레코드 내부에 레코드를 또 선언함으로써 나타냅니다. 그리고 모든 Ada의 레코드 타입은 이름을 갖는 타입이어야만 합니다.&lt;/p&gt;

&lt;p&gt;Fortran과 C 언어에서 중첩 레코드를 사용할 경우, 중첩된 레코드를 먼저 선언하고 상위 레코드에서 하위 레코드를 참조하는 형식으로 정의합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;레코드 필드를 참조하는 방법도 여러 가지가 있습니다. 먼저 COBOL 언어는 OF 라는 명령어를 사용하여 참조합니다. 예를 들어, 이전 슬라이드에 나와있던 COBOL 레코드에서 MIDDLE 이라는 필드를 참조하려면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIDDLE OF EMPLOYEE-NAME OF EMPLOYEE-RECORD&lt;/code&gt; 와 같이 작성하면 됩니다. 이 외의 다른 언어들에서는 대부분 EMPLOYEE_RECORD.EMPLOYEE_NAME.MIDDLE과 같이 .(마침표)를 이용해서 표현합니다. 이렇게 마침표를 이용해 표시하는 방법을 &lt;strong&gt;도트 표기법(Dot Notation)&lt;/strong&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;레코드 필드를 참조할 때 두 가지 형식이 있는데, 레코드 필드까지 모든 중간 레코드의 이름이 포함되어야 하는 &lt;span style=&quot;color:red&quot;&gt;완전 자격 참조(Fully Qualified Reference)&lt;/span&gt;와, 참조 환경이 명확하다면 레코드 이름의 일부나 전체를 생략할 수 있는 &lt;span style=&quot;color:red&quot;&gt;생략 참조(Elliptical Reference)&lt;/span&gt; 형식이 있습니다. COBOL의 레코드는 생략 참조를 허용함으로써 프로그래머의 편리성을 고려하였지만, 생략 참조는 가독성에 문제가 생길 수 있기 때문에 일반적으로 완전 자격 참조 방식을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal이나 Modular-2 언어 같은 경우에는 레코드를 할당하는 것이 가능합니다. Ada 언어 또한 레코드의 할당과 동일성의 비교를 지원합니다. COBOL 언어 같은 경우에는 MOVE CORRESPONDING 명령어를 통해 대상 레코드에 동일한 이름이 필드가 있을 경우 원본 레코드의 필드를 복사하는 기능을 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;레코드 필드도 배열과 마찬가지로 인접한 메모리에 저장됩니다. 그러나 배열과는 다르게 필드의 크기가 반드시 같지는 않기 때문에 배열과는 다른 접근 방식을 사용합니다. 이러한 문제는 레코드의 시작 주소에 상대적인 오프셋 주소를 필드에 포함시킴으로써 해결합니다. 아래 그림은 컴파일 시간 속성의 형식을 나타내고 있습니다.&lt;/p&gt;

&lt;p&gt;또한 레코드의 경우 필드별 크기가 상이하기 때문에 컴퓨터 메모리의 효율적인 접근을 위한 &lt;strong&gt;워드 정렬(Word Alignment)&lt;/strong&gt;이라는 기법을 사용합니다. 예를 들어 오른쪽과 같은 구조체 코드가 있습니다. 이 경우 문자형 변수 c는 1바이트, 정수형 변수 i는 4바이트를 차지합니다. 원래라면 구조체 aa는 이 둘을 합친 5바이트를 차지해야하지만, 32비트 컴퓨터의 경우 4바이트(=32비트) 단위로 명령어를 처리하기 때문에 5바이트씩 처리하게 되면 비효율적인 접근이 발생합니다. 따라서 이 경우에는 컴퓨터가 한번에 가져올 수 있는 데이터의 크기에 맞추기 위해, 일부러 쓰지않는 3바이트를 더 배정해서 8바이트로 만드는 것이 접근에 유리합니다. 이런 용도로 추가하는 비트를 &lt;strong&gt;패딩(Padding)&lt;/strong&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;공용체(Union)&lt;/span&gt;는 변수가 프로그램 실행 중에 다른 시간이라면 다른 타입의 값을 저장할 수 있는 타입을 말합니다. 예를 들면, 컴파일러를 위한 상수들의 테이블이 있습니다. 이 테이블은 컴파일 중인 프로그램에서 발견된 상수들을 저장하는데 사용되는데, 프로그램에 사용되는 상수들은 데이터 타입이 다양합니다. 그런데 이 테이블에 저장된 값은 동일한 테이블 필드에 저장되므로, 발견되는 데이터 타입 중 가장 큰 타입을 기준으로 기억공간이 할당됩니다. 즉, 데이터 타입의 합집합(Union)이라고 볼 수 있으므로 이러한 이름이 붙었습니다.&lt;/p&gt;

&lt;p&gt;공용체의 주요한 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타입 검사가 요구되어야 하는가? (만약 타입 검사가 요구된다면 반드시 동적으로 구현되어야 한다)&lt;/li&gt;
  &lt;li&gt;공용체가 레코드에 포함되어야 하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 설계 고려 사항을 참고하여 공용체가 구현된 언어를 간략하게 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 Fortran 언어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EQUIVALENCE&lt;/code&gt;라는 구문으로 공용체를 선언합니다. Fortran에서는 공용체의 타입 검사를 실시하지 않습니다. ALGOL 68 언어는 Fortran과 다르게 타입 검사를 요구합니다. 이 때, 공용체가 현재 갖고 있는 타입을 나타내기 위해 &lt;strong&gt;태그(Tag)&lt;/strong&gt; 나 &lt;strong&gt;판별자(Discriminant)&lt;/strong&gt;를 표기하는데, 이러한 것을 포함하는 공용체를 &lt;span style=&quot;color:red&quot;&gt;판별 공용체(Discriminated Union)&lt;/span&gt;라고 부릅니다. 판별 공용체는 실행 시간에서 타입을 검사합니다.&lt;/p&gt;

&lt;p&gt;ALGOL 68은 판별 공용체를 &lt;span style=&quot;color:red&quot;&gt;적합성 문장(Conformity Clause)&lt;/span&gt;으로 구현하였습니다. 이것은 실행 시간에 변수가 어떤 타입을 갖고 있는지 테스트하여 각 경우의 수 별로 다르게 처리하는 방법입니다. 오른쪽의 코드를 보시면 ir1은 정수형, 실수형 변수가 저장될 수 있는 공용체로 정의되어 있습니다. 아래의 case 문에서는 ir1이 정수일 때와 실수일 때로 나누어서 문구를 처리합니다. 이러한 방식으로 공용체의 타입을 관리하는 것이 적합성 문장입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/32.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal 언어는 판별 공용체와 레코드 구조를 결합하여 &lt;span style=&quot;color:red&quot;&gt;변종 레코드(Variant Record)&lt;/span&gt;로 구현하였습니다. 이것은 판별 공용체를 갖고 있는 레코드 구조 타입입니다. Pascal 언어의 판별자는 현재 타입의 값이 저장된 레코드에서 사용자가 접근할 수 있는 변수입니다. 코드 예시를 보면 case 문에 form이라는 이름이 있는데, 이것이 바로 판별자입니다. 레코드에 circle, triangle, rectangle 이 저장될 수 있는데, 이 중 하나를 선택하는 의미입니다.&lt;/p&gt;

&lt;p&gt;공용체는 결국 프로그램의 신뢰성을 떨어트리기 때문에 최근에는 지향하지 않는 타입입니다. 기본적으로 메모리를 공유하기 때문에, 공용체 내의 변수의 값을 변경하면 다른 변수의 값도 변형됩니다. 또한 C, C++ 언어와 같이 타입 검사를 하지 않는 자유 공용체를 사용하는 경우 강 타입 언어로부터 멀어지게 됩니다. 타입 검사를 하더라도 그것이 매우 어렵기 때문에 Java나 C#과 같은 최근 언어에서는 공용체를 지원하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/33.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;공용체는 포함된 모든 가능한 변수를 같은 주소에 배정하는 것으로 간단하게 구현할 수 있습니다. 당연히 공용체에서 가장 큰 크기를 차지하는 변수만큼 기억공간이 할당됩니다. 예제로 나온 Ada 코드와 같이 공용체가 주어진 경우, 컴파일 시간 내에 이것을 저장하기 위한 배치는 다음과 같을 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공용체의 시작 주소&lt;/li&gt;
  &lt;li&gt;판별체(=TAG)&lt;/li&gt;
  &lt;li&gt;필드 접근을 위한 오프셋(=상대 주소)&lt;/li&gt;
  &lt;li&gt;TRUE - COUNT (INTEGER), FALSE - SUM (CHARACTER)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/34.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;집합(Set)&lt;/span&gt; 타입은 기본 타입의 고유한 값을 정렬되지 않은 모음으로 저장할 수 있는 타입입니다. 집합 타입의 설계 고려 사항은 최대 원소의 개수를 몇 개로 정할 것이냐입니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어를 예로 들면, 집합의 최대 원소 수는 구현에 따라 다르지만, 일반적으로 100개 이하입니다. 집합과 그 원소에 대한 연산은 단일 Word 크기에 맞는 비트 문자열로 표현함으로써 가장 효율적으로 구현할 수 있습니다. 예를 들어, {red, blue, green} 집합의 부분 집합인 {red, green}을 2진수 101로 표현하는 것입니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어에서 집합 연산은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;’:=’&lt;/strong&gt; : 집합 타입의 적절한 배정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’+’&lt;/strong&gt; : 합집합&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;‘*‘&lt;/strong&gt; : 교집합&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’-‘&lt;/strong&gt; : 차집합&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’=’&lt;/strong&gt; : 동일한 집합인가 판단&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;집합을 배열과 비교해보면, 집합의 연산은 배열의 연산보다 효율적이라는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/35.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전 슬라이드에서 말씀드렸듯이 집합은 일반적으로 비트 스트링 형태로 메모리에 저장합니다. 따라서 집합의 연산의 대부분은 간단한 논리 연산으로 해결이 가능하므로 효율적입니다. 예를 들어, 합집합 연산은 논리 OR, 원소의 포함 여부는 논리 AND 연산으로 간단하게 계산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/36.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;포인터(Pointer)&lt;/span&gt; 타입은 변수가 메모리 주소와 특수 값 nil로 구성되는 값들의 범위를 갖습니다. nil은 유효한 주소가 아니며, 포인터가 메모리 셀을 현재 참조할 수 없음을 나타냅니다. 포인터는 간접 주소 지정과 동적 할당 관리 용도로 주로 사용됩니다. 포인터는 일반적으로 타입 연산자(C언어에서의 *)를 사용하여 정의됩니다. 그러나 배열이나 레코드와는 다르게 실제 데이터를 저장하기 위해서 사용하기보다는, 다른 변수를 참조하기 위해서 사용합니다. 이렇게 다른 변수를 참조하기 위해서 사용하는 변수를 &lt;strong&gt;참조 타입(Reference Type)&lt;/strong&gt;이라고도 부릅니다. 반대로 실제 데이터를 저장하는 변수는 &lt;strong&gt;값 타입(Value Type)&lt;/strong&gt;이라고도 부릅니다.&lt;/p&gt;

&lt;p&gt;포인터의 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포인터 변수의 영역(Scope)과 수명(Lifetime)은 어떻게 되는가?&lt;/li&gt;
  &lt;li&gt;포인터가 참조하는 동적 변수의 수명은 어떻게 되는가?&lt;/li&gt;
  &lt;li&gt;포인터가 가리킬 수 있는 값의 타입이 제한되는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포인터는 기본적으로 &lt;strong&gt;배정&lt;/strong&gt;과 &lt;strong&gt;역참조&lt;/strong&gt; 두 가지 연산을 제공합니다. 배정은 포인터 변수의 값을 다른 주소로 설정하는 것이고, 역참조는 포인터 변수에 바인딩된 메모리 셀이 가리키는 값에 대한 참조를 말합니다. 예를 들어, 예제 코드에서 aa는 포인터 타입으로 정의되어 있습니다. 다음 줄에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aa = &amp;amp;bb&lt;/code&gt;는 aa에 bb의 주소를 배정함으로써 포인터 변수 aa가 bb의 메모리 셀을 가리키게 만드는 연산입니다. 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc = *aa&lt;/code&gt;를 통해 변수 cc에 aa가 가리키는 메모리 셀의 값, 즉 55를 저장하게 만드는 역참조 연산입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/37.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;포인터라는 개념을 처음 도입한 언어는 PL/I이었습니다. 포인터의 개념이 도입되고 나서 프로그램의 유연성이 매우 높아졌지만, 덩달아 여러 가지 유형의 프로그래밍 오류가 초래되었습니다. 따라서 Java와 같은 최근의 언어에서는 포인터를 사용하지 않고 참조 타입으로 대체하였습니다. 여기서는 포인터로 발생할 수 있는 여러 가지 문제를 짚고 넘어가보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 포인터 변수에 대한 &lt;strong&gt;타입 검사(Type Checking)&lt;/strong&gt; 문제입니다. 포인터가 가리킬 수 있는 개체 유형을 도메인 타입이라고 합니다. PL/I의 포인터는 단일 도메인 타입으로 제한되지 않았기 때문에 포인터에 대한 타입 검사가 어려웠습니다. C/C++ 언어에서는 정수 변수를 가리키는 포인터 변수는 정수 포인터, 실수 변수를 가리키는 포인터 변수는 실수 포인터와 같이 가리키는 데이터 타입에 따라 포인터 변수의 타입이 고정되어 있기 때문에 이 문제를 약간이나마 해결했습니다.&lt;/p&gt;

&lt;p&gt;다음으로는 &lt;strong&gt;허상 포인터(Dangling Pointer)&lt;/strong&gt; 문제입니다. 이 문제는 C 언어를 배울 때도 다루는 문제입니다. 허상 포인터는 이미 회수된 변수의 주소를 가리키는 포인터를 말합니다. 허상 포인터의 문제는 가리키고 있는 기억장소의 위치에 다른 변수가 할당될 수도 있기 때문에 위험합니다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;strong&gt;분실된 객체(Lost Object)&lt;/strong&gt; 문제입니다. 이것은 허상 포인터와 반대로, 기억공간에는 여전히 데이터가 저장되어 있지만, 사용자 프로그램에서 더이상 접근할 수 없게된 객체입니다. 이러한 변수를 흔히 쓰레기(Garbage)라고도 부릅니다. 왜냐면 더 이상 원래의 목적대로 사용할 수도 없고, 그렇다고 다른 용도로 재사용할 수도 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;위 슬라이드의 마지막 부분에서는 허상 포인터와 분실된 객체가 발생할 수 있는 코드 예시를 나타내고 있습니다. 왼쪽의 예제에서는 포인터 전역 변수인 i가 정의되어 있습니다. 그런데 부프로그램 sub1()에서 지역변수인 j가 새로 선언되어있습니다. sub1()에서 포인터 변수 i가 j를 가리키게 배정되었습니다. 그런데 변수 j는 부프로그램 sub1()의 지역변수이기 때문에, sub1()이 종료되면 수명이 끝납니다. 따라서 sub1()이 호출된 이후 *i는 이미 회수된 변수의 주소를 가리키게 됩니다.&lt;/p&gt;

&lt;p&gt;오른쪽 코드에서는 포인터 문자 변수 c가 정의되어 있습니다. 두 번째 줄에서 동적 할당을 통해 c에 새로운 기억공간이 할당됩니다. 그런데 이를 해제하지 않고, 나중에 또 c에 새로운 기억공간을 할당합니다. 이렇게 되면 첫 번째 할당한 기억공간은 프로그램 내에서 더이상 접근할 수 없습니다. 따라서 이 때 분실된 객체 문제가 발생하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/38.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal 언어에서 포인터는 동적으로 할당된 변수에 접근하는데만 사용됩니다. 동적 할당에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; 명령어를 사용하고, 해제할때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispoose&lt;/code&gt; 명령어를 사용합니다. dispose 명령어는 허상 포인터 문제가 거의 항상 발생했기 때문에, dispose 명령어가 나오면 이걸 무시하는 경우도 많았습니다. 이것은 허상 포인터 문제를 발생하지 않게 하지만, 프로그램이 더 이상 필요로 하지 않는 힙의 재사용을 불가능하게 만드는 단점이 있습니다. 이것은 초기 Pascal 언어가 산업용 보다는 교육용 언어로 설계되었기 때문에 발생하는 문제입니다.&lt;/p&gt;

&lt;p&gt;포인터는 어쩌면 goto문과 비슷한데, goto문이 문장의 제어 범위를 확대시키는 것처럼 포인터는 변수가 참조할 수 있는 메모리 셀의 범위를 확대시킵니다. goto문이 프로그래밍 언어 설계자들에게 비난을 받는 것처럼 포인터도 이와 같은 비난을 받는데요, 오른쪽에 포인터에 대한 악담이 실려있는데, 이 내용이 재미있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“고급 언어에서 포인터의 도입은 우리가 결코 회복할 수 없는 후퇴였습니다”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마치 우한 폐렴 때 질병관리청에서 그 전으로는 절 때 돌아갈 수 없다고 말한 것과 비슷한 느낌이네요.&lt;/p&gt;

&lt;p&gt;C 언어에서 포인터는 어셈블리 언어에서 주소를 사용하는 것처럼 사용할 수 있는데요, 이러한 설계는 허상 포인터나 분실된 객체 문제에 대해 어떤 해결책도 없다는 단점이 있습니다. 그러나 그 대신 C 언어에서는 포인터의 산술 연산이 가능하다는 특징이 있습니다. 기본적으로 ‘*’ 연산은 포인터의 역참조 연산, ‘&amp;amp;’ 연산은 변수의 주소를 생성합니다. 이 외에도 포인터 변수와 일반 변수의 산술 연산이 가능한데, 예를 들어 ptr + index 라는 연산이 있습니다. 이 것은 ptr에 index 값을 단순히 더하는 것이 아니라, 먼저 ptr이 가리키고 있는 메모리 셀의 크기 단위로 index의 값이 조절됩니다. 만약 ptr의 크기가 4인 메모리 셀을 가리키면, index에 먼저 4를 곱한 다음 ptr에 더하는 방식입니다. 이렇게 설정된 목적은 포인터 연산으로 배열을 표현하기 위해서입니다. 예를 들어, 포인터 변수 ptr에 1차원 배열이 할당되었다고 하면, *(ptr + 1)은 ptr[1]과 동일한 의미입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/39.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;참조 타입(Reference Type)&lt;/span&gt;은 포인터와 유사하지만, 포인터가 메모리의 주소를 참조하는 것과 달리 참조 타입은 메모리의 객체나 값을 참조합니다. 따라서 포인터는 주소값을 다루기 때문에 산술 연산이 가능하지만, 참조 타입은 그렇지 않다는 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;대표적인 참조 타입은 C++ 언어에서 구현되어 있습니다. C++ 언어의 참조 타입은 항상 암시적으로 역참조되는 상수 포인터로 구현되어 있는데, 상수이기 때문에 정의할 때 어떤 변수에 주소값으로 초기화되어야 합니다. 물론 초기화된 후에는 다른 변수를 참조하도록 설정할 수 없습니다. 일반적으로 C++ 언어에서 참조 타입은 함수에서 호출 함수와 피호출 함수간의 양방향 통신에 사용됩니다. 이러한 예제는 다음을 참고해주시기 바랍니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void sub1(int&amp;amp; num){
  num = 10;
}
int n = 0;
sub1(n);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같이 함수 매개변수를 참조 타입으로 설정하면, n을 포인터로 넘기지 않아도 n의 값을 0에서 10으로 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/40.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;대부분의 대형 컴퓨터에서 포인터는 2바이트 또는 4바이트 메모리 셀(워드 크기)에 저장된 단일 값으로 저장됩니다. 그런데 포인터를 구현할 때는 포인터를 저장하는 것 자체보다는 포인터로 인해 발생하는 허상 포인터 문제를 고려하는 것이 더 중요합니다.&lt;/p&gt;

&lt;p&gt;첫 번째 방법은 &lt;span style=&quot;color:red&quot;&gt;비석 접근 방법(Tombstone Approach)&lt;/span&gt;입니다. 이것은 모든 동적 변수에 비석이라는 특수한 셀을 포함시키는 것입니다. 실제 사용하는 포인터 변수는 이 비석을 가리키게 하고, 비석이 동적 변수를 가리키게 만드는 구조입니다. 만약 동적 변수가 기억장소에서 해제된다면, 비석은 그대로 남지만 nil을 가리키도록 설정됩니다. 즉, 비석을 통해 포인터가 회수된 기억공간을 계속 가리키는 것을 방지하는 방법입니다.&lt;/p&gt;

&lt;p&gt;아이디어만 들어도 이 방법의 문제점이 자연스럽게 떠오릅니다. 먼저, 동적 변수가 해제될 때도 비석은 해제되지 않기 때문에 그 만큼의 기억공간이 낭비됩니다. 게다가, 포인터 변수가 기억공간을 직접 가리키지 않고 비석을 통해 간접적으로 가리키기 때문에 그만큼의 접근 시간이 추가로 소모됩니다. 일반적으로는 이 정도의 시간적/공간적 비용을 감당하면서까지 신뢰성을 확보할 필요가 없기 때문에, 이 방법을 사용하는 언어는 거의 없습니다. 버전 9 이하의 매킨토시나 C++ 언어의 일부 라이브러리(std::weak_ptr)만 이 방법을 사용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/41.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;허상 포인터를 해결하는 두 번째 아이디어는 &lt;span style=&quot;color:red&quot;&gt;잠금과 키 접근 방법(Locks-and-key Approach)&lt;/span&gt;입니다. 이 방법은 동적 변수를 (변수, 잠금값)의 순서쌍으로 나타내고, 동적 변수를 가리키는 포인터는 (키, 주소)의 순서쌍으로 나타냅니다. 동적 변수가 할당되면 잠금값이 생성되어 포인터 변수의 키 값과 동적 변수의 잠금값에 이 값이 저장됩니다. 포인터가 역참조될 때는 포인터의 키 값과 동적 변수의 잠금값과 비교함으로써 그 접금이 일치하는지, 아닌지 확인합니다. 만약 포인터가 복사된다면 잠금값도 같이 복사되어야 하고, 해제될 때는 잠금값도 해제되어야 합니다.&lt;/p&gt;

&lt;p&gt;사실 이러한 방법들 보다는 그냥 프로그래머 직접 매번 동적 변수를 해제해주는 것이 좋습니다. 프로그램 내에서 모든 동적 변수가 명시적으로 해제된다면 허상 포인터 문제는 발생하지 않기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/42.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 힙 메모리 관리에 대해 알아보도록 하겠습니다. 힙 메모리 관리는 매우 복잡한 실행 시간 프로세스로, 여기서는 모든 힙이 동일한 크기로 할당/회수되는 시나리오와 가변 크기로 할당/회수되는 시나리오, 두 가지 상황으로 나누어 고려해보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 동일한 크기에 대해 회수에 대해 먼저 논의하자면, 기억공간 회수를 통해 사용가능한 셀을 묶어 가용 공간 리스트를 만들 수 있습니다. 할당은 필요할 때 이 리스트로부터 요구된 셀의 개수를 가져오는 것입니다. 할당보다 회수가 더 어려운 문제인데, 동적 변수는 2개 이상의 포인터로 가리켜질 수 있으므로 그 변수가 언제 프로그램에서 더 이상 사용되지 않는지 판단하는 것이 어렵기 때문입니다. 예를 들어, 동적 변수를 가리키던 포인터가 없어진다고 해서 그 동적 변수가 쓰이지 않는다고 보장할 수 없습니다. 다른 포인터가 그 동적 변수를 가리키고 있을 수도 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;LISP 언어에서는 회수하는 방법에 따라 두 가지 방법으로 나눌 수 있는데, 순차적으로 회수하는 &lt;strong&gt;참조 계수기 접근 방법(Reference Counter)&lt;/strong&gt;과 &lt;strong&gt;쓰레기 수집 접근 방법(Grabage Collection Approach)&lt;/strong&gt;이 있습니다.&lt;/p&gt;

&lt;p&gt;먼저 참조 계수기 접근 방법부터 알아보겠습니다. 참조 계수기 방법은 접근할 수 없는 메모리 셀이 생성될 때마다 회수를 수거하는 방법입니다. 이것을 구현하기 위해, 항상 모든 메모리 셀에 대해 현재 자신을 가리키고 있는 포인터의 갯수를 저장하는 계수기를 사용합니다. 만약 어떤 셀의 계수기 값이 0이 된다면 이 메모리 셀을 가리키는 포인터가 없다는 뜻이므로 더 이상 쓰지 않는 메모리 셀로 판단하여 회수합니다.&lt;/p&gt;

&lt;p&gt;참조 계수기 방법에는 세 가지 문제점이 존재합니다. 첫째는 기억공간의 셀 크기가 작다면, 그만큼 계수기가 차지는 공간이 부담이 될 수 있습니다. 둘째로 계수기의 값을 조절하기 위한 시간적 부담도 존재합니다. 특히나 LISP은 거의 모든 명령문마다 포인터의 값이 변경되므로, 프로그램 실행 시간에서 계수기가 차지하는 실행 시간이 매우 부담스럽습니다. 마지막으로 셀이 순환적으로 참조되어 있는 경우입니다. 이러한 순환 리스트에 속하는 셀은 적어도 1의 계수기 값을 갖게 되므로 영원히 회수되지 않는다는 문제점이 있습니다.&lt;/p&gt;

&lt;p&gt;다만 참조 계수기 방법에 단점만 있는 것은 아닙니다. 참조 계수기 방법은 순차적으로 동작하는 방식이기 때문에 프로그램의 수행과 번갈아가며 발생합니다. 따라서 전체적으로 프로그램 실행에 지연을 초래하지 않는다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/43.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 쓰레기 수집 접근 방법에 대해 알아보겠습니다. 실행 시간에서 저장공간이 요구될 때 기억공간의 메모리 셀을 할당하고, 필요할 때 포인터와 셀의 연결을 끊습니다. 이 때는 일단 기억공간 회수에 신경쓰지 않고, 사용가능한 모든 셀이 할당될 때까지 이루어집니다. 이 과정에서 발생하는 쓰레기를 수집하기 위해, 쓰레기 수집 프로세스가 시작됩니다. 쓰레기 수집을 위해, 모든 셀은 수집 과정에서 사용되는 여분의 비트나 필드를 갖습니다. 쓰레기 수집을 위한 간단한 알고리즘은 다음과 같이 나타낼 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;힙의 모든 셀은 쓰레기인지 나타내는 표시가 설정됩니다.&lt;/li&gt;
  &lt;li&gt;프로그램의 모든 포인터는 힙으로 추적되고, 도달 가능한 셀은 쓰레기가 아닌 것으로 표시합니다.&lt;/li&gt;
  &lt;li&gt;쓰레기가 아닌 것으로 표시되지 않은 힙의 모든 셀을 회수합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 쓰레기 수집 접근 방법의 가장 큰 단점은 가장 필요할 때 가장 최악으로 동작한다는 것입니다. 이게 무슨 말이냐 하면, 쓰레기 수집은 힙의 기억공간을 대부분 사용되었을 때만 사용됩니다. 그런데 이 방법은 대부분의 셀을 추적해서 현재 사용중인지 확인해야하기 때문에, 상당한 많은 시간이 소요됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/44.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 메모리 셀이 가변 크기인 경우에는 문제가 더 복잡해집니다. 우선 가변 크기 셀에서는 동일한 크기의 셀에서 발생하는 모든 어려움을 기본적으로 갖고 있고, 다음과 같은 추가적인 문제가 더 발생합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;힙에 있는 모든 셀이 쓰레기라는 것을 나타내기 위한 표시의 초기 설정이 어렵습니다. 왜냐하면 각각의 셀이 다른 크기이기 때문에, 셀의 영역이 어디서부터 어디까지인지 스캔하는 것이 어렵기 때문입니다. 이에 대한 대책으로는 셀의 첫 번째 필드로 그 셀의 크기를 표시하는 것입니다.&lt;/li&gt;
  &lt;li&gt;만약 포인터를 전혀 포함하지 않는 셀이라면 어떻게 표시를 할 것인지도 문제가 됩니다. 물론 이것은 내부 포인터를 추가하면 해결되는 문제이지만, 이것으로 인해 추가적인 공간적 부담과 시간적 부담이 발생합니다.&lt;/li&gt;
  &lt;li&gt;사용가능한 기억공간의 리스트를 관리하는 것도 문제입니다. 회수된 기억공간의 크기는 클 수도 있지만 작을 수도 있습니다. 만약 회수된 기억공간 중 하나가 필요한 기억공간의 크기에 맞지 않다면 충분한 크기를 가진 다른 기억공간을 찾아야합니다. 이에 대한 해결책으로는 기억공간의 크기가 작은 경우 인접한 블록을 합병하는 것이지만, 이 과정에서도 추가적인 시간적 부담이 발생합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 문제점 중, 1번과 2번의 문제는 참조 계수기 방법을 사용하면 어느 정도 해결이 가능합니다. 그러나 3번 문제는 참조 계수기로도 해결할 수 없습니다. 나쁜 소식은 대부분의 프로그래밍 언어에서는 이러한 가변 크기 셀의 관리가 반드시 필요하다는 것입니다.&lt;/p&gt;

&lt;p&gt;6장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Names, Bindings, Type Checking, and Scopes</title><link href="http://localhost:4000/pl/names-bindings-type-checking-and-scope/" rel="alternate" type="text/html" title="Names, Bindings, Type Checking, and Scopes" /><published>2023-08-28T00:00:00+09:00</published><updated>2023-08-28T00:00:00+09:00</updated><id>http://localhost:4000/pl/names-bindings-type-checking-and-scope</id><content type="html" xml:base="http://localhost:4000/pl/names-bindings-type-checking-and-scope/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;처음 소개드린대로 3장과 4장은 컴파일러 과목과 중복된 내용이기 때문에 생략하고, 바로 5장으로 넘어갑니다. 5장은 변수와 관련된 개념들을 하나씩 소개합니다. 특히 제목대로 변수의 이름, 바인딩, 타입 검사, 유효 영역 등을 중점으로 짚도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령형 언어는 폰 노이만 구조를 기반으로 한 추상화입니다. 이 컴퓨터 구조의 가장 큰 특징은 명령어와 데이터를 저장하는 메모리와, 그 메모리의 내용을 수정하기 위한 연산을 제공하는 CPU로 구성되어 있다는 것입니다. 명령형 언어의 변수라는 것은 결국 메모리 셀에 대한 추상화입니다. 변수는 데이터 타입, 유효 영역, 수명, 타입 검사 등과 같은 속성(Attribute)들의 모음으로 특징지어질 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 &lt;span style=&quot;color:red&quot;&gt;이름(Name)&lt;/span&gt;은 프로그램에서 변수, 레이블, 부프로그램 및 매개변수와 같은 요소들을 식별하는데 사용되는 문자열입니다. 이름을 설계할 때는 다음과 같은 것들을 고려해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이름의 최대 길이는 무엇인가?&lt;/li&gt;
  &lt;li&gt;이름에 밑줄과 같은 연결 문자를 사용할 수 있는가?&lt;/li&gt;
  &lt;li&gt;이름이 대소문자를 구분하는가?&lt;/li&gt;
  &lt;li&gt;이름이 특수어, 예약어, 키워드인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이것들에 대해 하나씩 고려해보도록 하겠습니다. 먼저 이름의 길이는 언어가 발전되면서 점점 늘어났습니다. 초기 프로그래밍 언어에서는 오로지 단 한 문자만 허용되었으나, FORTRAN I은 6글자, COBOL은 30문자, C와 C++, Java와 같은 경우는 제한 없는 길이가 가능해졌습니다.&lt;/p&gt;

&lt;p&gt;또한 대부분 프로그래밍 언어에서 밑줄 문자를 띄어쓰기와 비슷한 용도로 사용합니다. 이러한 문화는 1970년 ~ 1980년대에 널리 사용되었지만, 최근에는 점점 배제하는 경향을 보입니다. C 언어 이후 등장한 언어들에서는 Camel Notation이라는 표기법이 정립되어, 대소문자를 통해 단어를 구분했습니다. 예를 들어서 myStack과 같이 말입니다. 그러나 이러한 밑줄 문자나 대소문자 혼용 사용은 언어 설계의 고려 사항이 아니라 프로그래밍에서의 고려 사항입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 언어에서 대소문자를 구별하는 것이 옳은 선택일까요? 예를 들어 C++에서는 대소문자가 완벽하게 다른 글자로 구분됩니다. ROSE, rose, Rose 이 3개의 이름은 모두 다른 이름으로 취급됩니다. 이것은 가독성 측면에서 굉장히 좋지 않다고 볼 수 있습니다. 왜냐하면 이 3개의 이름은 서로 유사하게 보이지만, 실제로는 아무런 관련이 없기 때문입니다. 물론 이것은 프로그래밍에서의 문제이기 때문에 대부분의 사람들은 대소문자가 구별되는 것을 싫어하지 않지만, 사전 정의된 이름들에서 대소문자가 구별되는 경우 문제가 생길 수 있습니다. 예를 들어, Java에서 문자열을 정수 값으로 변환하는 메소드는 parseInt인데, ParseInt나 parseint로 입력하면 인식하지 못합니다. 이것은 작성력 측면에서 좋지 않은 경우라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;특수어(Special Words)&lt;/span&gt;는 수행될 행동들을 명칭화하여 프로그램의 가독성을 높이는데 사용됩니다. 대부분의 프로그래밍 언어에서 특수어는 &lt;span style=&quot;color:red&quot;&gt;키워드(Keyword)&lt;/span&gt;, 또는 &lt;span style=&quot;color:red&quot;&gt;예약어(Reserved word)&lt;/span&gt;로 분류되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;키워드&lt;/strong&gt; : 프로그래밍 언어 내의 특수어를 재정의할 수 있는 경우 키워드라고 부릅니다. 현재 사용되고 있는 언어 중에서 특수어가 키워드인 언어는 Fortran 뿐입니다. Fortran의 특수어 중 하나인 REAL은 REAL APPLE로 선언하는 경우에는 APPLE이 실수형 변수로 정의가 되지만, REAL = 3.4로 선언할 경우 REAL 이란 변수에 3.4를 대입하는 식이 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;예약어&lt;/strong&gt; : 프로그래밍 언어 내의 특수어를 재정의할 수 없는 경우 예약어라고 부릅니다. 프로그래밍 언어 설계 관점에서 보면, 예약어가 키워드보다 낫다는 것이 일반적인 의견입니다. 그러나 예약어에서도 문제가 하나 있는데, 언어가 갖고있는 예약어가 너무 많을 경우 프로그래머가 불편함을 느낄 수 있다는 것입니다. 특히 COBOL 언어는 300여개의 예약어를 가지고 있는데, 그 중에는 일반적으로 많이 사용하는 이름인 COUNT, LENGTH와 같은 것들도 포함하고 있습니다. 이 경우 프로그래머가 변수 이름을 짓는데 상당한 애로사항이 생길 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;변수(Variable)&lt;/span&gt;는 1페이지에서도 설명드렸듯이 메모리 셀에 대한 추상화입니다. 변수는 이름(Name), 주소(Address), 타입(Type), 값(Value), 수명(Lifetime), 유효 범위(Scope) 6개의 튜플로 구성되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이름&lt;/strong&gt; : 변수의 이름은 프로그램에서 가장 일반적으로 볼 수 있는 이름입니다. 변수의 이름은 &lt;strong&gt;식별자(Identifiers)&lt;/strong&gt;라고도 불립니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소&lt;/strong&gt; : 변수의 주소는 그 변수와 연관된 실제 메모리의 주소입니다. 많은 언어들에서는 동일한 변수가 프로그램의 위치에 따라 다른 주소와 연관되는 것이 가능합니다. C 언어와 비슷한 언어에서는 지역 변수(Local Variable)라는 개념을 생각하시면 됩니다. 또한 같은 주소를 가리키는 여러 개의 변수를 가질 수도 있습니다. 이것을 &lt;span style=&quot;color:red&quot;&gt;별칭(Alias)&lt;/span&gt;이라고 하는데, 이것은 가독성을 떨어트리므로 권장되지 않습니다. 예를 들어, total이 sum의 별칭이라면, total 값을 변경시켰을 때 sum 값도 변경되고, 그 반대도 가능해집니다. 따라서 프로그램을 읽는 프로그래머는 total과 sum이 같은 공간을 가리키는 것을 반드시 기억해둬야 하는 불편함이 있습니다. 결국 프로그램 내의 별칭이 많을 수록 검증이 더욱 어려워집니다. C 언어의 포인터가 대표적인 별칭의 예시입니다. 또한 부프로그램의 매개변수를 통해서 생성될 수도 있는데, 이것은 9장에서 부프로그램에 대해서 다룰 때 더 자세하게 논의하겠습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;타입&lt;/strong&gt; : 변수의 타입은 그 변수가 저장할 수 있는 값들의 범위와 정의될 수 있는 연산들의 집합을 결정합니다. 예를 들어, Fortran에서의 Integer 타입은 -32,768 ~ 32,767 사이의 값을 가질 수 있으며, 사칙연산이 가능합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;값&lt;/strong&gt; : 변수의 값은 그 변수에 저장된 메모리 셀의 내용입니다. 변수는 등호(=)를 기준으로 왼쪽에 있을 때는 &lt;span style=&quot;color:red&quot;&gt;l-value&lt;/span&gt;, 오른쪽에 있을 때는 &lt;span style=&quot;color:red&quot;&gt;r-value&lt;/span&gt;로 부릅니다. l-value는 변수의 주소, r-value는 변수의 값을 나타냅니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;바인딩(Binding)&lt;/span&gt;은 연산과 기호 같은 하나의 속성과 하나의 개체 간의 연관성입니다. 바인딩이 일어나는 시기를 &lt;span style=&quot;color:red&quot;&gt;바인딩 시간(Binding Time)&lt;/span&gt;이라고 부릅니다. 바인딩 시간은 다음과 같이 다양한 경우로 분류할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;언어 설계 시간 : ‘*’ 기호는 일반적으로 언어 설계 시 곱셈 연산으로 바인딩됩니다.&lt;/li&gt;
  &lt;li&gt;언어 구현 시간 : Integer와 같은 데이터 타입이 어떤 범위의 값을 가질지는 언어 구현 시간에 바인딩됩니다.&lt;/li&gt;
  &lt;li&gt;컴파일 시간 : Pascal로 구현된 프로그램에서 변수가 어떤 데이터 타입을 가질지는 컴파일 시간에 바인딩됩니다.&lt;/li&gt;
  &lt;li&gt;링크 시간 : 라이브러리 부프로그램에 대한 호출은 링크 시간에 부프로그램 코드에 바인딩됩니다.&lt;/li&gt;
  &lt;li&gt;로드 시간 : 프로그램이 메모리에 로드될 때 변수가 메모리 셀에 바인딩됩니다.&lt;/li&gt;
  &lt;li&gt;실행 시간 : 프로시저의 변수는 프로시저가 실제로 호출될 때 메모리 셀에 바인딩됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 오른쪽 구석에 있는 간단한 프로그램을 확인해봅시다. 가장 첫 줄에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int count;&lt;/code&gt;를 통해 count 변수를 int형 변수로 선언하였습니다. 이것은 컴파일 시간에 바인딩됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count = count * 5;&lt;/code&gt;에서 count가 가질 수 있는 값은 언어 구현 시간에 바인딩됩니다. 또한 ‘*’ 연산이 어떤 의미를 가질지는 피연산자의 타입이 결정되었을 때 바인딩되므로 컴파일 시간에 바인딩됩니다. 5라는 숫자 표현은 컴파일 설계 시간에 바인딩되며, count의 최종 값은 이 배정문의 실행 시간에 바인딩됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sub1(count);&lt;/code&gt;에서 count 변수는 이 부프로그램의 매개변수로 들어있습니다. 그러나 count의 값은 이전 구문에서 실행 시간에 바인딩되었으므로 이 때는 실행 시간에 바인딩됩니다. 그러다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sub1(int aa)&lt;/code&gt;에서 변수 aa는 매개변수로 처음 선언되는 변수입니다. 따라서 변수 aa는 count와는 다르게 로드 시간에 바인딩됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 바인딩이 실행 시간 이전에 일어나고 프로그램 실행 전체에 걸쳐서 변하지 않는다면 &lt;span style=&quot;color:red&quot;&gt;정적 바인딩(Static Binding)&lt;/span&gt;이라고 부릅니다. 반대로 프로그램 실행 과정에서 변경될 수 있다면 &lt;span style=&quot;color:red&quot;&gt;동적 바인딩(Dynamic Binding)&lt;/span&gt;이라고 부릅니다. 하드웨어에서 발생하는 동적 바인딩의 대표적인 예시는 가상 메모리입니다. 가상 메모리는 상황에 따라 실제 물리적 메모리에 다르게 바인딩될 수 있지만, 여기서 이러한 종류의 동적 바인딩까지는 고려하지 않도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 타입 바인딩의 경우를 살펴보겠습니다. 변수는 프로그램 내에서 참조되기 전까지 어떤 데이터 타입인지 바인딩되어야만 합니다. 변수에서 타입은 두 가지 선언 방법이 있습니다. 변수 이름과 특정 타입을 직접 명세함으로써 타입을 바인딩하는 &lt;span style=&quot;color:red&quot;&gt;명시적 선언(Explicit Declaration)&lt;/span&gt;이 있습니다. 1960년 이후 설계된 대부분의 프로그래밍 언어들은 명시적 선언 방법을 채택하고 있습니다. 반대로 직접 선언하지 않고 규칙에 의해 변수에 타입을 바인딩하는 것을 &lt;span style=&quot;color:red&quot;&gt;묵시적 선언(Implicit Declaration)&lt;/span&gt;이라고 합니다. 대표적으로 Fortran, Basic, PL/I가 이 방법을 사용합니다. 공통점은 이 두 방법 모두 정적 바인딩으로 분류된다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동적 타입 바인딩에서는 변수의 타입이 선언문이나 이름 그 자체로 정해지지 않습니다. 대신 변수에 어떤 값이 할당되는 순간 그 변수에 타입이 바인딩됩니다. 오른쪽 그림과 같이 변수 count는 1을 넣었을 때는 정수형, 3.0을 넣었을 때는 실수형, [1, 2, 3]을 넣었을 때는 배열로 바인딩됩니다. 대표적으로 Python이 이러한 동적 타입 바인딩 방식을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;동적 타입 바인딩의 장점은 프로그래밍 시의 유연성을 제공한다는 것입니다. 특히 Generic Program을 작성할 때 빛을 발휘할 수 있습니다. 그러나 프로그램의 신뢰성을 낮추는 단점이 있습니다. 동적 타입 바인딩을 가진 언어는 컴파일 시간에 오류를 탐지하기 더 어렵기 때문입니다. 따라서 타입 검사를 실행 시간에 수행해야만 하는데, 그로 인해 추가적인 비용이 드는 것이 문제입니다. 그렇기 때문에 동적 타입 바인딩을 갖는 언어는 컴파일러보다는 인터프리터를 사용해서 구현하는 경우가 많습니다. 왜냐면 어차피 인터프리터는 컴파일러에 비해 10배 이상 느리기 때문에 동적 타입 바인딩에서 발생하는 검사 시간이 인터프리터의 번역 시간에 묻히기 때문입니다.&lt;/p&gt;

&lt;p&gt;묵시적 선언에서 타입 선언을 하는 것을 &lt;span style=&quot;color:red&quot;&gt;타입 추론(Type Inference)&lt;/span&gt;라고 부르기도 합니다. ML이라는 언어에서 부프로그램은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fun circum(r) = 3.14 * r * r;&lt;/code&gt;과 같이 선언할 수 있습니다. ML 언어는 함수의 내부 구조를 통해 함수의 결과값이 어떤 타입인지 확인하는데, 이 경우 3.14라는 실수 값이 함수의 결과값에 영향을 주기 때문에 결과 값은 실수 타입으로 자동으로 추론됩니다.&lt;/p&gt;

&lt;p&gt;Generic Programming은 데이터 타입에 의존하지 않고, 하나의 변수가 여러 다른 데이터 타입을 가질 수 있게 만드는 프로그래밍 스타일입니다. 이것은 코드의 재사용성을 크게 높일 수 있으며, 이러한 접근 방식은 1973년 ML이라는 언어에서 처음 제안되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;변수의 &lt;span style=&quot;color:red&quot;&gt;수명(Lifetime)&lt;/span&gt;은 변수가 특정 메모리에 바인딩되어 있는 기간으로 정의됩니다. 즉, 변수가 특정 메모리 공간에 바인딩 될 때 시작되며 그 공간에서 해제될 때 종료됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;정적 변수(Static Variable)&lt;/strong&gt;는 프로그램이 실행되기 전에 메모리 공간에 바인딩되고, 프로그램 실행이 종료되면 해제됩니다. 대표적인 정적 변수는 전역 변수(Global Variable)가 있고, 부프로그램에서 기록에 민감한 변수의 경우에도 정적 변수로 선언됩니다. 정적 변수는 할당이나 해제를 위한 시간이 필요하지 않기 때문에 효율성을 높일 수 있다는 장점이 있지만, 유연성을 감소시킨다는 문제점이 있습니다. 특히 정적 변수만을 갖는 언어로는 재귀적 부프로그램을 만들 수 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스택 동적 변수(Stack Dynamic Variable)&lt;/strong&gt;는 선언문에 의해 지시될 때 기억공간 바인딩이 생성되지만, 타입은 정적으로 바인딩되는 변수를 말합니다. 따라서 바인딩 자체는 실행 시간에 일어나게 됩니다. 대표적인 스택 동적 변수의 예시는 프로시저에서의 지역 변수가 있습니다. 예를 들어, C나 Java와 같은 언어에서 함수에 선언된 변수는 그 함수가 호출될 때 기억공간에 바인딩됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스택 동적 변수의 장점은 재귀적 부프로그램을 가능하게 만들고, 서로 다른 프로시저에서 동일한 메모리 공간을 차지하게 만들 수 있습니다. 단점으로는 실행 시간에서 지역 변수의 메모리 할당 및 할당 해제를 위한 추가적인 비용이 필요하다는 것입니다. 또한 스택 동적 변수는 간접적인 주소지정을 필요로 하기 때문에 접근 속도가 더 느리다는 단점도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택 동적 변수의 예로 위와 같은 하나의 프로그램을 보겠습니다. 먼저 변수 a2와 변수 p는 sub()라는 부프로그램 안에서 선언되었기 때문에 스택 동적 변수입니다. 따라서 이 변수들은 sub() 종료시 메모리에서 자동으로 회수됩니다. 변수 a3은 부프로그램 안에서 선언되었지만, static으로 선언되었기 때문에 정적 변수이므로 sub()가 종료되더라도 자동으로 회수되지 않습니다. 변수 a3은 프로그램이 종료될 때 회수됩니다. 또한 변수 p는 a2와 다르게 포인터로 선언되어 있습니다. 그렇기 때문에 이것도 일단 실행 시간에서 기억공간에 할당되고 회수되지만, a2와는 다르게 힙(Heap)에 저장된다는 차이점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;묵시적 힙 동적 변수(Implicit Heap Dynamic Variable)&lt;/strong&gt;은 값이 배정될 때 힙 기억장소에 바인딩 되는 변수입니다. 다음과 같은 APL 언어의 LIST 변수는 이전에 어떤 용도로 사용되었는지에 상관 없이 list 형으로 값이 배정된다면 list 형으로 기억장소에 바인딩되고, 마찬가지로 정수형으로 배정된다면 기억장소에 정수형으로 바인딩됩니다. 장점으로는 높은 유연성을 갖는다는 것이지만, 타입 바인딩 때와 마찬가지로 실행 시간에서의 부담이 늘어나고 컴파일 시간에 오류를 탐지하는 것이 어려워진다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;명시적 힙 동적 변수(Explicit Heap Dynamic Variable)&lt;/strong&gt;은 프로그래머가 명시적으로 공간을 할당하고 회수되는 변수입니다. 명시적 힙 동적 변수는 포인터나 참조 변수에 의해서만 참조될 수 있으며 실행 시간에서 메모리 공간 바인딩과 해제가 모두 일어납니다. 명시적 힙 동적 변수의 타입은 컴파일 시간에 바운딩되지만, 기억장소에 바인딩 되는 것은 실행 시간입니다.&lt;/p&gt;

&lt;p&gt;명시적 힙 동적 변수를 이해하기 위해, 가운데에 있는 C++ 코드 예제를 보겠습니다. 이 예제에서 명시적 힙 동적 변수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new int&lt;/code&gt;를 통해서 생성됩니다. 그리고 이 변수는 포인터인 intnode를 통해 참조될 수 있습니다. 그리고 delete 명령어를 통해 기억공간에서 해제됩니다. C++는 쓰레기 수집(Garbage collection)과 같은 묵시적 기억공간 회수 방법을 사용하지 않기 때문에 명시적 연산자인 delete가 반드시 필요합니다. 반대로 Java는 명시적 힙-동적 변수를 사용하지만 쓰레기 수집을 지원하기 때문에 명시적으로 회수할 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;명시적 힙 동적 변수의 장점은 실행 시간 도중 크기가 커지거나 줄어들 수 있는 연결 리스트나 트리와 같은 동적인 구조체를 구현하는데 유용합니다. 그러나 참조 변수를 올바르게 사용하기가 어렵고, 참조 비용, 기억공간 관리를 구현하는게 어렵다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 확인해볼 사항은 &lt;span style=&quot;color:red&quot;&gt;타입 검사(Type Checking)&lt;/span&gt;입니다. 사실 10판 이후로 이 부분은 6장으로 넘어갔지만, 강의자료에서는 그것이 반영되지 않아 여전히 5장의 내용으로 나와있네요. 어쨌든 강의자료를 기반으로 설명드리는 것이기 때문에 타입 검사는 여기에서 짚고 넘어가겠습니다.&lt;/p&gt;

&lt;p&gt;타입 검사는 연산자와 피연산자가 &lt;span style=&quot;color:red&quot;&gt;호환 가능한 타입(Compatible Type)&lt;/span&gt;인지 확인하는 검사입니다. 호환 가능한 타입이란 연산자에 대해 적합하거나, 컴파일러에 의해 적합한 타입으로 변환되는 것이 허용되는 타입입니다. 이렇게 컴파일러에 의해 자동으로 변환되는 것을 &lt;span style=&quot;color:red&quot;&gt;타입 강제 변환(Coercion)&lt;/span&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;타입 검사에는 &lt;strong&gt;정적 타입 검사(Static Type Checking)&lt;/strong&gt;와 &lt;strong&gt;동적 타입 검사(Dynamic Type Checking)&lt;/strong&gt; 2가지 종류가 있습니다. 정적 타입 검사는 모든 변수의 타입 바인딩이 정적인 경우 수행되는 타입 검사이며, 동적 타입 검사는 실행 시간에 검사하는 타입 검사입니다. 예를 들어, JavaScript나 PHP 같은 언어는 동적 타입 바인딩으로 인해 동적 타입 검사만을 지원합니다.&lt;/p&gt;

&lt;p&gt;타입 검사도 컴파일 시간에 수행하는 것이 실행 시간에 수행하는 것보다 효율적입니다. 정적 검사는 컴파일 시간에 타입 검사를 실행함으로써 효율적인 검사가 가능하지만, 프로그래밍의 유연성이 낮다는 단점이 있습니다. 그러나 최근에는 이러한 유연성이 오히려 가독성에 악영향을 끼친다고 인식되고 있기 때문에 큰 문제는 아닙니다. 동적 타입 검사는 반대로 프로그래밍의 유연성이 증가하지만, 그만큼 타입 검사가 어려워진다는 문제가 있습니다. 특히, 실행 중에 서로 다른 유형의 값을 서로 다른 시점에 저장할 수 있도록 허용되는 경우 타입 검사가 매우 복잡해집니다. 오른쪽의 Pascal 언어의 예시와 마찬가지로, C언어의 공용체(Union)가 바로 이러한 경우입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1970년대 중요하게 여겨졌던 언어 설계의 아이디어 중 하나는 강 타입(Strong Typing)입니다. 프로그램 내에 모든 타입이 정적으로 바인딩되어 타입 오류가 항상 탐지되는 언어를 &lt;span style=&quot;color:red&quot;&gt;강 타입 언어(Strongly Typed Language)&lt;/span&gt;라고 부릅니다. 이것은 꼭 하나의 변수가 하나의 타입만 가져야할 것처럼 보이지만, 실제로 그렇지는 않습니다. 두 개 이상의 타입이 저장되는 변수의 경우에는 실행 시간에 탐지하는 것도 허용됩니다.&lt;/p&gt;

&lt;p&gt;대표적으로 Ada 언어가 강 타입 언어에 가장 가까운 언어이고, C 언어와 C++ 언어는 강 타입 언어가 아닌 대표적인 언어입니다. Java는 C++의 파생 언어이지만 강 타입 언어에 매우 가깝습니다. Fortran 77 언어는 실제 매개변수와 형식 매개변수 간의 관계가 타입 검사되지 않기 때문에 강 타입 언어가 아니며, Pascal 언어는 강 타입 언어에 가깝지만 레코드 설계 측면에서는 강 타입 언어가 아닙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로는 타입 동등(Type Equivalence)에 대해 살펴보겠습니다. 먼저 서로 다른 두 변수가 서로 가지고 있는 값을 다른 변수에게 할당할 수 있는 경우에는 &lt;span style=&quot;color:red&quot;&gt;타입 호환(Type Compatible)&lt;/span&gt;이 가능하다고 정의됩니다. 스칼라 타입 변수의 경우에는 대부분 단순하고 엄격한 조건을 가지고 있지만, 배열이나 레코드와 같은 구조화된 타입에서는 규칙이 더 복잡해집니다.&lt;/p&gt;

&lt;p&gt;이러한 강제 변환(Coercion) 없이, 어떤 타입의 피연산자가 다른 타입의 피연산자로 대체될 수 있을 때 타입 동등이라고 부릅니다. 타입 동등은 타입 호환성보다 엄격한 조건임을 알 수 있습니다. 타입 동등은 다음과 같은 2개의 종류로 구분됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이름 타입 동등(Name Type Equivalence)&lt;/strong&gt; : 두 변수가 동일한 선언, 또는 동일한 타입 이름을 사용하는 선언으로 정의된 경우 타입 동등으로 정의됩니다. 구현하기는 쉽지만, 매우 제한적이라는 특징이 있습니다. 예를 들어, 정수의 부분 범위를 갖는 변수는 정수 타입 변수와 동등하지 않게 정의됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구조 타입 동등(Structure Type Equivalence)&lt;/strong&gt; : 두 변수의 타입이 동일한 구조를 갖는 경우 타입 동등으로 정의됩니다. 구조 타입 동등은 이름 타입 동등보다 유연하지만 구현하기가 더 어렵습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;변수의 &lt;span style=&quot;color:red&quot;&gt;영역(Scope)&lt;/span&gt;은 변수를 볼 수 있는 범위를 일컫습니다. 만약 변수를 해당 문장에서 참조할 수 있는 경우, &lt;strong&gt;볼 수 있다(Visible)&lt;/strong&gt;고 표현합니다. 변수가 프로그램이나 블록 내에 정의되면 &lt;span style=&quot;color:red&quot;&gt;지역 변수(Local Variable)&lt;/span&gt;이라고 합니다. 반대로 &lt;span style=&quot;color:red&quot;&gt;비지역 변수(Nonlocal Variable)&lt;/span&gt;은 해당 프로그램이나 블록 내에서 볼 수 있지만, 그곳에서 선언되지 않은 경우를 말합니다. &lt;strong&gt;전역 변수(Global Variable)&lt;/strong&gt;은 비지역 변수 중 하나라고 볼 수 있습니다. 비지역 변수는 그 규칙에 따라 정적 영역과 동적 영역으로 구분할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정적 영역(Static Scoping)&lt;/strong&gt;은 ALGOL 60에서 처음 도입되었으며, 실행 전에 변수의 영역이 정적으로 정해지는 것을 말합니다. 정적 영역은 주로 중첩된 부프로그램에서 생성됩니다. 예를 들어 아래와 같은 경우, 변수 x는 big이라는 프로시저에서 선언되었습니다. 그런데 sub1이라는 프로시저에서 변수 x에 대한 참조가 발생합니다. sub1 내에서 변수 x를 선언하지 않았다고 하면, sub1의 상위 프로시저를 탐색하여 변수 x에 대한 선언을 찾습니다. 프로시저의 호출 순서가 big -&amp;gt; sub2 -&amp;gt; sub1이라서 sub1의 상위 프로시저가 sub2라고 착각할 수도 있지만, sub1의 프로시저는 big 프로시저 안에서 정의되어있기 때문에 (정적 영역 하에서는) 무조건 big의 변수 x를 참조함에 유의하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;몇몇 언어는 &lt;span style=&quot;color:red&quot;&gt;블록(Block)&lt;/span&gt;이라는 개념을 도입하여 새로운 정적 영역이 코드 중간에 정의되는 것을 허용하고 있습니다. 블록이라는 코드의 일부분에서만 사용할 수 있는 지역 변수를 선언할 수 있으며, 스택 동적으로 선언되기 때문에 블록 내에 진입할 때 기억공간에 할당되고 블록을 빠져나올 때 기억공간에서 해제됩니다. 이것은 C 언어에서 다음과 같이 temp라는 변수처럼 사용됩니다.&lt;/p&gt;

&lt;p&gt;정적 영역은 많은 상황에서 잘 작동하지만, 여러가지 문제점을 내포하고 있습니다. 첫째로, 호출할 수 없어야 하는 프로시저에 대한 오류는 컴파일러에서 오류로 감지되지 않는다는 문제가 있습니다. (영역 구멍) 둘째로, 변수와 부프로그램에 대한 접근을 너무 많이 허용한다는 것입니다. 또한 프로그램을 업데이트할 때 문제가 발생할 소지가 많은데, 이러한 접근 방식을 제대로 이해하지 못하고 코드를 추가할 경우 필요 이상으로 전역 변수를 사용하거나 접근 방식이 꼬일 가능성이 높습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;동적 영역(Dynamic Scope)&lt;/strong&gt;은 부프로그램들의 상호간의 공간 배치가 아닌, 부 프로그램의 호출 시퀀스에 기반한 영역 방식입니다. 따라서 동적 영역은 실행 시간에 결정됩니다. APL, SNOBOL4, LISP의 몇몇 분파 언어들에서 사용되는 방식이며, 프로그램 단위 간 편리하게 매개변수를 전달할 수 있다는 장점이 있습니다. 정적 영역에서 보았던 big, sub1, sub2 프로시저를 다시 보시면 호출 순서가 big -&amp;gt; sub2 -&amp;gt; sub1 이었습니다. 따라서 동적 영역이라고 가정하면 sub1에서 참조하는 x는 sub2에서 선언한 x가 됩니다.&lt;/p&gt;

&lt;p&gt;동적 영역 또한 문제가 발생할 수 있습니다. 첫째로, 부프로그램의 지역 변수는 실행 중인 다른 부프로그램에서 모두 볼 수 있습니다. 그들간의 코드상 거리와는 상관이 없기 때문에, 지역 변수를 보호할 수 있는 방법이 없고 결과적으로 정적 영역보다 덜 신뢰적인 프로그램이 만들어지게 됩니다. 둘째로, 비지역 변수를 참조할 때 정적으로 타입 검사할 수 없습니다. 마지막으로, 변수에 대한 참조가 항상 동일한 변수에 대해 일어나는 것이 아니기 때문에 가독성이 떨어지는 문제도 있습니다.&lt;/p&gt;

&lt;p&gt;따라서 동적 영역은 정적 영역에 비해 널리 사용되지 않고 있습니다. 일반적으로 정적 영역 언어가 가독성이 좋고, 더 신뢰적이고, 더 빠르게 실행되는 것이 정설입니다.&lt;/p&gt;

&lt;p&gt;다음으로는 변수의 영역과 수명에 대해 알아보겠습니다. 변수의 영역과 수명은 얼핏 보면 동일하거나, 거의 관련이 있는 것처럼 보입니다. 그러나 상황에 따라 완전히 달라질 수 있습니다. 먼저 변수의 영역과 수명에 대한 정의부터 다시 해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;영역(Scope)&lt;/strong&gt; : 변수의 선언부터 프로시저의 마지막 예약어까지의 범위&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수명(Lifetime)&lt;/strong&gt; : 프로시저에 진입한 시점부터 프로시저의 실행이 종료된 시점까지의 기간&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 오른쪽 코드에서 변수 sum의 영역과 수명을 각각 계산해보겠습니다. 먼저 변수 sum의 영역은 compute 프로시저에 완전히 포함됩니다. printheader 프로시저가 compute 프로시저 안에서 실행되지만, sum의 영역은 printheader 함수의 내부까지 포함하지는 않습니다. 그러나 sum의 수명은 printheader가 실행되는 시간도 포함되며, printheader 호출 전에 기억공간에 바인딩 된 sum은 printheader의 실행 동안과 그 이후에도 지속됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코드에 있는 어떤 문장의 &lt;span style=&quot;color:red&quot;&gt;참조 환경(Referencing Environment)&lt;/span&gt;은 그 문장에서 볼 수 있는 모든 이름의 모음입니다. 정적 영역 언어라면 어떤 문장의 참조 환경은 그 지역에서 선언된 변수와 그 조상 영역에서 선언된 변수의 모음이 됩니다. 동적 영역 언어라면 지역 변수와 함께 현재 활성화 되어있는 다른 모든 부프로그램(Active Procedure)에서 선언된 변수로 구성됩니다.&lt;/p&gt;

&lt;p&gt;참조 환경을 더 쉽게 이해하기 위해서 오른쪽의 코드를 보겠습니다. 1번 위치에서 참조 환경은 sub1 프로시저에서 선언된 x, y와 그 상위 프로시저인 example에서 선언된 a, b입니다. 2번 위치에서 참조 환경은 sub3에서 선언된 x와 example에서 선언된 a, b가 됩니다. sub2에서 선언된 x는 당연히 무시되는데, 이것을  숨겨진 변수(Hidden Variable)라고 합니다. 3번 위치에서 참조 환경은 sub2에서 선언된 x와 example에서 선언된 a, b입니다. 4번 위치에서 참조 환경은 example에서 선언된 a, b가 되는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;이름 상수(Name Constant)&lt;/span&gt;는 단지 한 번만 값에 바인딩되는 변수입니다. 예를 들어 원주율 3.14159265… 의 값을 PI로 할당해놓으면 가독성이 상승하는 효과가 있습니다. Java의 final 키워드가 대표적인 예시입니다.&lt;/p&gt;

&lt;p&gt;마지막으로 변수가 기억 공간에 바인딩되는 시점에 값을 바인딩 하는 것을 &lt;span style=&quot;color:red&quot;&gt;초기화(Initialization)&lt;/span&gt;라고 부릅니다. 만약 변수가 기억공간에 정적으로 바인딩되면 바인딩과 초기화는 실행 시간 이전에 일어납니다. 만약 기억공간 바인딩이 동적이라면 초기화도 동적입니다. 대표적으로 C 언어에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int sum = 0;&lt;/code&gt; 과 같은 문장이 초기화입니다.&lt;/p&gt;

&lt;p&gt;5장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Evolution of the Major Programming Languages</title><link href="http://localhost:4000/pl/evolution-of-the-major-programming-languages/" rel="alternate" type="text/html" title="Evolution of the Major Programming Languages" /><published>2023-08-23T00:00:00+09:00</published><updated>2023-08-23T00:00:00+09:00</updated><id>http://localhost:4000/pl/evolution-of-the-major-programming-languages</id><content type="html" xml:base="http://localhost:4000/pl/evolution-of-the-major-programming-languages/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로그래밍 언어론의 2장은 지금까지 개발되었던 프로그래밍 언어에 대한 간단한 정리입니다. 과거부터 지금까지 개발된 프로그래밍 언어의 종류는 매우 많지만, 이러한 프로그래밍 언어의 특징에 대해 하나하나 전부 외울 필요는 없습니다. 그 대신, 주요한 몇몇 언어에서 도입된 새로운 개념에 대해서만 간단하게 요약하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림은 이번 장에서 다룰 프로그래밍 언어의 계보입니다. 다루는 순서는 연도별로 정리되어 있지만, 같은 계보에 있는 언어들 (ex. FORTRAN과 그 후속 버전)은 한번에 같이 다루도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran은 Formula Translator의 약자로써, IBM이 개발한 IBM 704 하드웨어에서 동작하는 것을 목표로 개발된 프로그래밍 언어입니다. IBM 704는 부동 소수점 연산이 가능했던 최초의 하드웨어였기 때문에, 이를 구동하기 위해 1954년 IBM에서는 The IBM Mathematical Formular Translating System이라는 보고서를 작성하였고, 이것이 Fortran 언어의 원형인 Fortran 0입니다. Fortran 0가 실제로 구현되지는 않았지만, 구현 도중 언어 시스템이 계속 수정되면서, 1957년 드디어 Fortran 1이 개발됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran I의 특징은 동적 공간이 없었으며, 반복문을 동작하기 위하여 좋은 배열이 필요했습니다. 또한 변수 중 I, J, K, L, M, N은 정수형 타입이었으며, 다른 모든 변수는 부동 소수점 타입이라는 규약이 있었습니다. 하지만 문자열 처리가 불가능했고, 강력한 입출력 시스템을 갖지 못했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran I이 가지는 의의는 컴파일러를 사용하는 최초의 고급 언어라는 것입니다. Fortran I의 특징을 정리하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수의 이름은 최대 여섯 글자로 제한됨&lt;/li&gt;
  &lt;li&gt;반복문은 Do 반복문만 존재&lt;/li&gt;
  &lt;li&gt;입출력 형식이 정해져 있음&lt;/li&gt;
  &lt;li&gt;사용자 정의 부프로그램 생성 가능&lt;/li&gt;
  &lt;li&gt;3가지 분기를 가지는 선택문이 존재 (IF)&lt;/li&gt;
  &lt;li&gt;데이터 타입을 표기하는 문법이 없음&lt;/li&gt;
  &lt;li&gt;부분 컴파일이 불가능&lt;/li&gt;
  &lt;li&gt;컴파일러는 18명의 기술자에 의해 1957년 4월에 개발됨&lt;/li&gt;
  &lt;li&gt;IBM 704의 낮은 신뢰도로 인해, 400줄이 넘는 프로그램은 컴파일이 정상적으로 수행되지 않음&lt;/li&gt;
  &lt;li&gt;코드는 매우 빠르게 수행됨 (최적화가 잘됨)&lt;/li&gt;
  &lt;li&gt;불과 1년이 지나 IBM 704를 위한 코드 중 절반 이상이 Fortran I으로 작성될 정도로 널리 보급됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran II는 Fortran I이 나온지 약 1년 후에 배포되었습니다. Fortran I이 가지고 있던 단점을 보완하여 부분 컴파일을 가능하게 했고, 이로 인해 Fortran I보다 긴 프로그램 제작이 가능해졌습니다. 그 외에 Fortran I의 버그를 수정하여 안정성을 향상시켰습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran II 다음에 Fortran III이 개발되긴 하였으나, 널리 쓰여지지 않았기 때문에 금세 잊혀졌습니다. 대신 1960년대 초에 개발된 Fortran IV는 엄청난 성공을 거두었습니다. Fortran IV는 명시적 타입 선언, 논리 IF문, 그리고 부프로그램을 매개변수로 취급하여 다른 부프로그램에 전달할 수 있는 기능이 추가되었습니다. Fortran IV는 ANSI에 의해 1966년에 표준화가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran IV 다음으로는 Fortran 77이 발표되었습니다. Fortran 77은 문자 스트링 처리, 논리 반복 제어문, IF-THEN-ELSE 문이 추가되었습니다. Fortran 77은 1978년에 표준화가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 90은 Fortran 77에서 상당한 발전을 이루어서 모듈, 동적 배열, 포인터, 재귀문, Case문, 매개변수 타입 체크 기능이 추가되었습니다. Fortran 90은 1992년에 표준화가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 90 이후, Fortran은 5년 주기의 마이너 업데이트, 10년 주기의 메이저 업데이트를 개발하기로 결정됩니다. 그로 인해 Fortran 95는 Fortran 90의 마이너 업데이트 버전입니다. 기존 문법 중 쓰이지 않는 문법도 제거되었습니다.&lt;/p&gt;

&lt;p&gt;계획대로라면 Fortran 95 이후, 2000년에 메이저 업데이트를 포함한 Fortran 2000이 개발되었어야 했지만, 기술자들의 합의가 이루어지지 않아 2003년에야 Fortran 2003으로 발표됩니다. 사실 메이저 업데이트라고 해도 크게 변한 것은 없었습니다. (그래서 위와 동일하다고 ditto로 표시되어 있습니다)&lt;/p&gt;

&lt;p&gt;이 글을 쓰는 시점에서 최신 버전은 Fortran 2018입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran은 초창기에 개발된 고급 언어이지만, 현재까지도 적지 않은 사용자를 보유하고 있습니다. 가장 큰 이유로는 Fortran 90 이전의 모든 Fortran 언어는 최적화가 매우 훌륭하기 때문에, 모든 변수의 타입과 저장 공간이 런타임 이전에 고정되었다는 것입니다. 즉, 런타임에서 새로 할당되는 변수가 한 개도 없었다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;Fortran의 성공은 컴퓨터가 사용되는 방식을 크게 변화시켰고, 많은 프로그래밍 언어가 Fortran의 문법으로부터 영향을 받았기 때문에, 컴퓨팅 세계에서 &lt;em&gt;공통어(Lingua Franca)&lt;/em&gt;라고 불리기도 합니다. (Alan Perlis, 1978)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;처음으로 개발된 함수형 프로그래밍 언어는 LISP입니다. LISP는 1958년 MIT에 근무하던 John McCarthy에 의해 개발되었습니다. 이 당시에도 연구자들은 AI에 대한 관심이 있었기 때문에, AI 연산에 어울리는 프로그래밍 언어를 목표로 설계되었습니다. LISP의 문법은 Lambda Calculus를 기반으로 만들어졌다는 특징이 있습니다. 예를 들어, 1부터 10까지 출력하는 프로그램을 Python으로 구현하면 반복문을 사용한 방법이 먼저 떠오르지만, 람다식을 기반으로 만든다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[print(x) for x in range(10)]&lt;/code&gt;와 같이 나타낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LISP은 당시 유행하던 Fortran과는 다르게, Atom과 List라는 데이터 타입을 가지고 있습니다. Atom은 상수나 심볼을 의미하며, List는 Atom으로 이루어진 자료구조입니다. List는 저희가 자료구조 시간에 배운 연결 리스트와 동일한 구조이며, 위의 그림처럼 리스트 내부에는 부분 리스트가 존재할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LISP는 처음 개발된 이후부터 현재까지 AI 응용 분야에서 절대적인 위치에 존재하고 있습니다. LISP가 발전하면서 기존에 가지고 있던 느린 실행 시간이란 문제도 인터프리터도 컴파일러로 변경되면서 보다 빠른 실행 시간을 갖도록 개선되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LISP의 문법은 위와 같이 연산 기호가 앞에 오는 전위 표기(Prefix) 구조를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LISP에서 함수는 위와 같이 정의할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LISP에서 반복문은 위와 같이 나타낼 수 있습니다. 위 슬라이드의 함수는 구구단을 출력하는 함수로, (printDan 2)로 호출하여 구구단 2단을 출력하게 만드는 코드입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 LISP 계열 언어는 초창기에 개발된 LISP보다 그 개선형들이 더 많이 사용되고 있습니다. 1970년대 중반에 MIT에서 LISP의 파생 언어인 Scheme이 개발되었는데, LISP보다 작은 규모, 정적 영역의 활용, 함수를 일등급 객체로 취급하여 매개변수나 리스트의 원소 등으로 취급할 수 있는 기능이 추가되었습니다. Scheme은 그 간단한 문법으로 인해 교육용으로 많이 사용되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또 다른 LISP 계열 언어로써 Common LISP이 있는데, Scheme과는 다르게 오히려 초창기 LISP보다 복잡한 구조를 가지고 있습니다. 그 이유는 LISP 계열 파생 언어를 한 개로 결합했기 때문인데, 구조가 복잡한 대신 LISP 파생 언어들로 작성된 프로그램들을 모두 이식할 수 있다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 이전에 존재하던 프로그래밍 언어들은 모두 특정한 하드웨어에 종속된 언어였습니다. 따라서 범용성을 늘리고자 하는 연구 끝에 보편적으로 사용할 수 있는 최초의 프로그래밍 언어인 ALGOL 60 언어가 등장하게 됩니다. ALGOL은 Algorithmic Language의 약자입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL의 설계는 1958년부터 시작되었습니다. 이 때 설계의 목표는 수학적 표기에 가까운 문법, 알고리즘의 설명을 위해 이 언어를 사용하는 것이 가능해야할 것, 그리고 반드시 자동적으로 기계어로 번역되어야 한다는 것이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL에서 정립한 특징은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터 타입의 형식화&lt;/li&gt;
  &lt;li&gt;변수명 길이 제한이 없음&lt;/li&gt;
  &lt;li&gt;배열의 차원 제한이 없음&lt;/li&gt;
  &lt;li&gt;매개변수가 입출력에 따라 구분됨&lt;/li&gt;
  &lt;li&gt;색인 첨자를 괄호로 표시함&lt;/li&gt;
  &lt;li&gt;복합문을 가능하게 만듬 (begen - end로 표기)&lt;/li&gt;
  &lt;li&gt;각 문구는 세미콜론으로 구분함&lt;/li&gt;
  &lt;li&gt;배정문은 :=로 정의함&lt;/li&gt;
  &lt;li&gt;조건문 if에서 else-if 문을 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;프로그램에서 필요로하는 입출력이 없음 (이로 인해 기계에 종속적일 수 있기 때문에)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL은 1958년에 ALGOL 58이란 보고서로 처음 탄생하였습니다. 이것이 실제 구현되지는 않았지만, 이 보고서를 기반으로 MAD나 JOVIAL 등의 언어가 영향을 받아 구현되었습니다. ALGOL 58이 처음 발표되었을 때, IBM은 초기에 관심을 보였으나 이미 IBM 700번대 컴퓨터에 도입된 Fortran을 유지하기로 결정하여 포기하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 58을 실제로 구현하기 위해 연구자들은 파리에서 6일간 회의를 진행했습니다. 회의 기간이 길지는 않았지만, 이 때 추가된 기능들이 상당히 많은데요. 정리하자면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;블록 구조 (지역화의 도입)&lt;/li&gt;
  &lt;li&gt;부프로그램에 매개변수를 전달하는 두 가지 다른 방법이 도입됨 (Call by Value, Call by Name)&lt;/li&gt;
  &lt;li&gt;부프로그램을 재귀적으로 호출하는 것이 가능&lt;/li&gt;
  &lt;li&gt;스택 동적 배열이 허용됨 (6장에서 다룸)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만 입출력 형식은 기계에 종속적일 수 있기 때문에 여전히 다루지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 ALGOL 60이 성공한 것과 실패한 것을 나누어 생각해보겠습니다. 먼저 ALGOL 60이 성공한 것부터 말하자면, 컴퓨터 알고리즘을 표기하는 방식이 ALGOL 60을 기준으로 기술되었다는 것입니다. 그렇기 때문에 1960년 이후 설계된 모든 명령형 프로그래밍 언어는 ALGOL 60을 기반으로 설계되었습니다. (C, Java, Pascal 등) 그리고 처음에도 소개했듯이, ALGOL 60은 최초의 기계에 독립적인 프로그래밍 언어이고, 프로그래밍 언어의 문법을 BNF(Backus-Naur Form)으로 규정화하였습니다.&lt;/p&gt;

&lt;p&gt;ALGOL 60이 실패한 점은 결국 대중화되지 못했다는 것입니다. 특히 미국에서 굉장히 부진했는데, 그렇다고 유럽에서 널리 쓰인 것도 아니었습니다. 그 이유는 여러 가지가 있었지만, 몇 개만 소개하자면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입출력의 부재로 인해 다른 컴퓨터에 이식하는 것을 어렵게 만듬&lt;/li&gt;
  &lt;li&gt;언어가 너무 유연했기 때문에 구현하기 어려웠음&lt;/li&gt;
  &lt;li&gt;기존에 사용하던 Fortran의 견고한 대중성&lt;/li&gt;
  &lt;li&gt;처음 도입된 BNF 문법을 이해하기 어려웠음&lt;/li&gt;
  &lt;li&gt;IBM으로부터의 지원 결여&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 설명할 언어는 비즈니스 용도로 개발된 COBOL입니다. COBOL이 개발되기 전, 1957년에 FLOW_MATIC이라는 언어가 비즈니스 용도로 개발되었으나, 이 언어는 UNIVAC 회사의 소유로써 UNIVAC의 컴퓨터를 위해 설계되었었기 때문에 범용적이지 못했습니다. 또 다른 언어는 미국 공군(USAF)에 의해 개발된 AIMACO가 있었으나, FLOW-MATIC과 큰 차이가 없었고, IBM이 COMTRAN이라는 비즈니스용 언어를 설계하였으나, 결국 구현되지는 못했습니다. 이 외에도 여러 언어들이 비즈니스 용도로 계획되었으나, 각자 가지고 있는 단점으로 인해 주력화되지는 못했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;COBOL 언어는 기존 비즈니스용 언어였던 FLOW-MATIC을 기반으로 만들어졌습니다. 이 당시 FLOW-MATIC은 하이픈을 포함해 12개의 문자로 이름을 짓는 것이 가능했고, 영어로 연산을 표기했습니다. 이 말인 즉슨, 1 + 2와 같이 연산 기호를 사용하지 않고 ADD 1, 2 와 같이 표현했다는 뜻입니다. 또한 데이터와 코드는 완전히 구분되었고, 모든 구문의 첫 단어는 동사로 지정되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;COBOL을 위한 회의는 1959년 펜타곤에서 처음 열렸습니다. 비즈니스 용도가 목적인 만큼, 전문가가 아닌 일반인도 사용할 수 있도록 간단한 영어처럼 보이게 만들고, 보다 덜 효율적이더라도 사용하기 쉬워야만 했습니다. 또한 컴퓨터를 사용할 수 있는 사람들을 늘리고 현재 발생하고 있는 컴파일(구현) 문제들에 의해 지나치게 제약되어서는 안되었습니다.&lt;/p&gt;

&lt;p&gt;COBOL 설계를 위한 구성원들은 전부 컴퓨터 제조업자들과 국방 관계자였습니다. (Department of Defence; DoD)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;COBOL 언어는 Define으로 명명된 최초의 매크로가 포함된 첫 고급 언어입니다. 또한 Record라고 불리는 계층적 데이터 구조와 중첩된 선택문이 가능했습니다. 이름을 지을 때 FLOW-MATIC에서는 12개의 문자로 한정되었지만, COBOL은 30글자까지 가능하게 개선되었습니다. 또한 데이터 영역이 코드 영역과 완전히 구분되었다는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/32.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;COBOL에 가장 큰 영향을 미친 것은 바로 미 국방성이었습니다. 미 국방성의 설계 개입과 지원은 COBOL이 다른 언어들에 비해 성공할 수 있었던 주요한 이유로 평가됩니다. 미국에서는 여전히 국가 시스템의 일부분이 COBOL로 설계되었기 때문에 가끔 뜬금없이 COBOL 프로그래머를 구인하는 공고가 올라오곤 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/33.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이것은 COBOL로 작성된 프로그램의 예시입니다. 간단한 영어로 대부분 표현되어 있기 때문에 COBOL 언어를 모르더라도 대략적인 해석이 가능합니다. TIJA는 뭔가 싶었는데, 아무리봐도 그냥 임의로 지어진 이름인 것 같습니다. 혹시 다른 뜻으로 알고 계신 분이 있다면 댓글 부탁드립니다…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/34.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 소개할 언어는 BASIC 입니다. 두 수학자 John Kemeny와 Thomas Kurtz는 다트머스 대학교에서 근무하고 있었는데, 다트머스 대학교는 학부중심대학(Liberal Arts College)으로써 약 75%의 학생이 인문계열을 전공하였습니다. 두 수학자는 이러한 학생들을 위한 새로운 언어가 필요하다고 판단하여 이공계열 학생이 아닌 학생들이 이해하기 쉽도록 설계한 Beginner’s All-purpose Symbolic Instruction Code (BASIC)을 개발하였습니다.&lt;/p&gt;

&lt;p&gt;현재 BASIC 언어 중 가장 유명한 파생 언어는 마이크로소프트에서 개발한 Visual BASIC입니다. 아마 90년대에 태어나신 분이라면 한번쯤은 들어보신 언어일 것이라고 생각합니다.&lt;/p&gt;

&lt;p&gt;BASIC 언어는 시분할 개념을 도입한 최초의 언어입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/35.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PL/I는 모든 사람을 위해 개발된 첫 번째 대규모 언어입니다. IBM에 의하면, 이전까지 프로그래밍 언어를 사용하던 사용자들은 과학 용도로 사용하던 SHARE 그룹과 비즈니스적 용도로 사용하던 GUIDE 그룹이 있었습니다. SHARE 그룹은 Fortran을, GUIDE 그룹은 COBOL을 주로 사용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/36.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 1963년부터 두 사용자 그룹이 충돌하려는 조짐이 보이기 시작했습니다. 당시 과학 용도로 사용하던 사용자들은 대규모 데이터를 처리하기 위해 효율적인 입출력 기능을 가진 COBOL에 관심을 보였고, 비즈니스 용도로 사용하던 사람은 회귀 분석을 수행하기 위해 부동 소수점 데이터 처리와 배열 기능에 관심을 보이기 시작했습니다. 이것은 각각 분리되었던 두 사용자 그룹이 서로의 언어와 컴퓨터가 필요로 한다는 것을 의미했고, 이것으로 인해 두 종류의 컴퓨터 뿐만 아니라 각각의 프로그래밍 언어를 사용할 수 있는 프로그래머의 추가 고용이 필요했습니다.&lt;/p&gt;

&lt;p&gt;따라서 IBM은 두 용도로 모두 사용할 수 있는 범용적인 컴퓨터와 그 언어를 개발하는 작업에 착수합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/37.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 언어를 설계하기 위한 위원회가 만들어졌는데, 구성원은 IBM 직원 3명, SHARE 직원 3명으로 이루어졌습니다. 초창기 컨셉은 Fortran IV의 확장으로 기획되었으며, 코드명 NPL (New Programming Language)로 불렸습니다. 1965년에 비로소 현재의 이름인 PL/I (Programming Language One)로 변경됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/38.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PL/I가 프로그래밍 언어에 기여한 부분은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동시에 실행할 수 있는 부프로그램을 생성할 수 있음&lt;/li&gt;
  &lt;li&gt;발생할 수 있는 예외를 처리할 수 있음&lt;/li&gt;
  &lt;li&gt;부프로그램을 재귀적으로 사용하는 것을 허용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 타입에 포인터가 추가됨&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;배열의 일부분이 참조될 수 있음 (ex. 2차원 행렬의 특정 행이 1차원 배열인 것처럼 참조될 수 있음)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 PL/I에서 추가된 새로운 구조는 너무 많았고, 설계에 결함도 상당히 많았습니다. 게다가 프로그래밍 언어가 너무 방대하고 복잡하다는 단점이 있었습니다. 하지만 적어도 1970년대까지는 이 언어가 상당히 많이 사용되었기 때문에 어느 정도 성공은 거뒀다고 평가받고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/39.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 소개할 언어는 APL과 SNOBOL입니다. 이 두 언어는 앞서 소개했던 다른 언어들에 비해 중요도가 높지 않기 때문에 간단하게만 설명하고 넘어가도록 하겠습니다. APL과 SNOBOL은 최초의 동적 언어로서의 의미가 있지만, 이후에 나타나는 다른 언어들에 그다지 큰 영향을 남기지는 못했습니다.&lt;/p&gt;

&lt;p&gt;동적 언어로 불리는 이유는 기본적으로 동적 타입과 동적 공간 할당을 지원하기 때문입니다. 예를 들어, 이 언어들에서는 변수가 선언될 때 타입이 선언되지 않고 값이 배정될 때 타입이 결정됩니다. 또한 값이 할당되기 전에는 필요한 기억 공간을 알 수 없기 때문에, 변수는 값이 배정되어야만 기억 공간에 할당됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/40.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;APL(A Programming Language)은 1960년 쯤에 IBM의 Kenneth Iverson에 의해 설계되었습니다. 사실 초창기에는 하드웨어의 구조를 설명하는 의도로 제작되었지만, 나중에 프로그래밍 언어로써 목적이 바뀌게 됩니다. 그래서 그런지 몰라도, 이 언어는 굉장히 많은 연산자를 가지고 있으며, 대부분의 코드가 간단하게 표기되지만 읽기가 매우 힘들다는 단점이 있습니다. 예를 들어 Daniel McCracken이라는 프로그래머는 4줄로 작성된 APL 프로그램을 이해하는데 4시간이나 걸렸다고 합니다.&lt;/p&gt;

&lt;p&gt;그래서인지 APL은 널리 사용되지는 못했지만, 사용하고 있는 사람은 여전히 있습니다. 그리고 그 구조 또한 초창기에서 거의 변하지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/41.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SNOBOL은 1964년에 벨 연구소에 근무하던 Farber, Griswold, Polensky에 의해 설계되었습니다. SNOBOL은 텍스트 처리, 그 중에서도 문자열 패턴 매칭에 강한 성능을 가졌습니다. 그러나 특수 목적에 사용되는 것과 더불어 동적인 특징으로 인해 일반적인 다른 언어들보다 느리기 때문에, 그다지 많이 사용되지는 못했습니다. 그러나 여전히 몇몇 소수의 사용자들은 이 언어를 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/42.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 프로그램은 SNOBOL을 사용해서 더 이상 요청이 없을 때까지 문자열 입력을 계속 요청하는 프로그램입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/43.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SIMULA 67은 최초로 데이터 추상화에 대한 개념이 도입된 프로그래밍 언어입니다. 노르웨이 컴퓨팅 센터에서 일하던 Nygaard와 Dahl은 시스템 모의실험을 위해 SIMULA I 언어를 설계하였고, ALGOL 60 언어와 SIMULA I을 기반으로 SIMULA 67 언어를 구현하였습니다. 이 언어는 부프로그램의 실행이 끝나면 이전에 실행이 중단된 지점에서 다시 실행을 이어가는 Coroutine이라는 새로운 부프로그램을 설계하였으며, 그것을 위한 클래스, 객체, 그리고 상속이 도입되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/44.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 68은 ALGOL 60의 개정판이지만 ALGOL 60과 상당히 다른 구조를 가지고 있습니다. 안타깝게 ALGOL 60과 마찬가지로 그다지 널리 쓰이지는 못했지만, ALGOL 68은 프로그래밍 언어의 평가 기준 중 하나인 직교성을 처음으로 중요하게 논의하였다는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/45.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 68은 사용자 정의 데이터 구조와 동적 배열이라는 개념을 새로 도입하였습니다. 그러나 ALGOL 60에서 안좋은 점을 답습하여 언어 기술 문서를 너무 복잡하게 작성하였기 때문에 사람들로부터 외면받았습니다. 하지만 이 언어는 Pascal, C 언어를 포함한 후속 언어에 매우 강한 영향을 끼쳤기 때문에 역사적으로는 중요한 언어입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/46.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL의 후속 언어라고 볼 수 있는 언어 중 하나는 Pascal 언어입니다. 이 언어는 ALGOL 68을 설계했던 위원 중 하나인 Niklaus Wirth에 의해 설계되었습니다. Pascal은 작고 간단하다는 특징으로 인해 프로그래밍 교육에 지대한 영향을 끼쳤으며, 1970년대 중반부터 1990년대 후반까지 대학교에서 프로그래밍 교육 용도로 사용되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/47.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C언어는 벨 연구소에 근무하던 Dennis Richie에 의해 시스템 프로그래밍 용도로 설계된 언어입니다. C 언어는 BCLP, B, ALGOL 68로 부터 영향을 받았는데, 강력한 연산자를 가지고 있지만 타입 검사를 거의 하지 않는다는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;기존의 운영체제는 대부분 어셈블리어와 같은 저급 언어로 개발되었으나, C 언어는 처음부터 시스템 프로그래밍 용도로 설계된 언어이기 때문에 실제로 C 언어로 운영체제가 만들어졌습니다. 그 이름도 유명한 UNIX로써, UNIX의 성공과 더불어 C 언어는 현재까지도 널리 쓰이는 주요한 언어로 자리잡게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/48.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Prolog는 마르세유 대학교의 Comerauer, Roussel과 애든버러 대학교의 Kowalski에 의해 1970년대에 개발된 언어입니다. Prolog는 논리 프로그래밍을 위해 개발되었는데, 논리 프로그래밍은 술어 해석학 명제들을 명세화하는 것이라고 합니다. 즉, 관련된 정보와 요구한 결과를 계산하기 위한 추론 과정을 컴퓨터에게 제공함으로써 원하는 결과를 얻어내는 방식입니다. 그러나 Prolog는 매우 비효율적이라는 것이 증명되었고, 논리 프로그래밍을 필요로 하는 분야도 적었기 때문에 널리 사용되지 못했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/49.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어는 지금까지 나타난 언어 중에 가장 오랜 자원을 투자해 설계한 언어입니다. 이것은 COBOL과 마찬가지로 미 국방성(DoD) 주도로 개발이 시작되었으며, 무려 8년간의 기간동안 여러 제안서를 토대로 요구사항을 정립하였습니다. 이 언어의 이름은 최초의 프로그래머인 에이다 러브레이스로부터 딴 Ada로 붙여졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/50.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어는 패키지, 예외 처리, 포괄적 프로그래밍, 동시 실행에 대해 많은 기여를 남겼습니다. 그러나 설계 당시 경쟁적으로 요구사항이 추가되었고, 당시에 존재하던 소프트웨어 공학과 언어 설계에 대한 지식이 총동원되었기 때문에 Ada 언어의 컴파일러는 상당히 어려운 문제였습니다. Ada 언어 자체는 1980년 쯤에 등장했지만, Ada 언어를 컴파일할 수 있는 컴파일러는 1985년에서야 나타나기 시작했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/51.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 95는 Ada 언어의 개정판으로써 1988년부터 설계가 시작되었습니다. 이때부터 객체 지향 프로그래밍의 개념이 도입되었으며, 상속 시 파생 클래스에 새로운 요소를 추가하는 것이 가능해졌습니다. 또한 공유된 데이터에 대한 제어 메커니즘의 향상 (ex. private), 새로운 동시 프로세스, 더 유연한 라이브러리가 추가되었습니다. 그러나 C++ 언어의 등장으로 인해 Ada 언어는 빠르게 인기를 잃었기 때문에 현재는 그렇게 많이 사용하지는 않습니다. 가장 최근에 발표된 개정판은 Ada 2012입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/52.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Smalltalk는 1960년대 후반 유타 대학교에서 박사과정을 하던 Alan Kay로 부터 처음 제안되었습니다. 그러나 당시에는 그가 고안했던 기능을 구현하기 위한 하드웨어가 없었기 때문에, 1970년대에 되서야 구현되었습니다.&lt;/p&gt;

&lt;p&gt;지금까지 소개된 프로그래밍 언어에서 객체 지향 프로그래밍의 일부 기능을 지원하는 언어는 있었지만, 완전한 객체 지향 프로그래밍을 지원하는 언어는 소개되지 않았습니다. Smalltalk는 완전한 객체 지향 프로그래밍 언어를 지원하는 첫 언어라는데 그 의의가 있습니다. 또한 그래픽 유저 인터페이스를 지원했다는 특징도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/53.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어는 벨 연구소에서 근무하던 Bjarne Stroustrup에 의해 1980년에 개발된 언어입니다. 당시 존재하던 C 언어와 SIMULA 67 언어를 기반으로 만들어졌으며, Smalltalk와 같이 객체 지향 프로그래밍을 지원하기 위해 설계되었습니다. C 언어와 다르게 예외 처리를 지원한다는 특징이 있습니다. C++ 언어는 절차적 프로그래밍과 객체 지향 프로그래밍을 모두 지원하도록 설계되었기 때문에 굉장히 방대하고 복잡하게 설계되었습니다. 객체 지향 프로그래밍의 발전으로 인해 C++는 급격하게 인기를 얻게 되었고, 이것은 현재도 마찬가지입니다. 표준화는 ANSI에 의해 1997년에 제정되었고, 대표적인 분파로 마이크로소프트의 Managed C++가 있습니다. 참고로 현재 윈도우 운영체제는 C 언어와 C++ 언어를 기반으로 만들어지고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/54.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 외에 객체 지향 프로그래밍과 관련된 언어는 1992년에 개발된 Eiffel, 2000년에 개발된 Delphi가 있습니다. 그러나 이 언어들은 다음 페이지에 나오는 언어로 인해 묻혀버리고 맙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/55.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Java 언어는 썬 마이크로시스템즈에 의해 1990년대 초반에 개발되었습니다. 썬 마이크로시스템즈는 컴퓨터 뿐만이 아니라 냉장고나 TV, 오븐 같은 가전 기기들에서 사용할 수 있는 범용적인 언어가 필요했는데, 당시 널리 쓰이던 C와 C++ 언어는 이것이 불가능했기 때문입니다. Java 언어는 C++ 언어에서 신뢰성에 영향을 미치는 포인터나 구조체, 공용체와 같은 개념을 모두 빼버리고 오로지 객체 지향 프로그래밍만을 위해 설계되었습니다. 이것은 가전 기기에 신뢰성이 매우 중요한 요소였기 때문입니다. 또한 동시성을 위해 애플릿이라는 개념도 새로 도입하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/56.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Java는 그 외에도 GUI나 데이터베이스를 위한 라이브러리 추가, 자바 가상 머신으로 인해 이식성이 높은 특징이 있습니다. Java 언어는 웹 프로그래밍 분야에서 널리 쓰이게 되며 빠르게 사용자를 늘려왔습니다. Java 언어의 최신 버전은 2023년에 발표된 Java 20입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/57.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스크립트 언어는 스크립트(Script) 라는 명령어 리스트를 해석하기 위해 하나의 파일로 저장했던 것에서 유래했습니다. 초기 스크립트 언어는 프로그래밍 언어와 차이가 있었으나, 그 발전 과정에서 프로그래밍 언어와 같은 부프로그램, 변수, 제어문 등이 추가됨으로써 프로그래밍 언어와 점점 가까워졌습니다. 여기서는 대표적으로 몇 개의 스크립트 언어를 간단하게 소개하고 넘어가겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Perl&lt;/strong&gt; : Perl은 1987년 Larry Wall에 의해 개발되었습니다. Perl의 특징은 변수들이 정적 타입을 갖지만 묵시적으로 선언된다는 것입니다. Perl의 변수 타입은 변수명의 첫 글자로부터 정해지는데, 스칼라 변수는 $로 시작하고, 배열은 @, 해시는 %로 선언됩니다. Perl의 성능은 강력하지만, 안정성이 낮다는 단점이 있습니다. 주로 웹 프로그래밍 분야에서 많이 사용하며, 유닉스 시스템에서도 종종 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; : JavaScript는 1995년 넷스케이프에 근무하던 Brendan Eich에 의해 개발되었습니다. 원래 이름은 LiveScript였으나, 당시 유행하던 Java 언어의 인기에 편승하기 위해 JavaScript로 변경하였습니다. JavaScript는 주로 동적인 HTML 문서를 만들기 위해 웹 프로그래밍 분야에 사용되며, 클라이언트에서 인터프리팅 된다는 특징이 있습니다. Java와는 사실 그다지 큰 관련이 없습니다. 프로그래머 사이의 농담 중에, Java와 JavaScript의 관계는 인도와 인도네시아의 관계와 동일하다라는 말이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PHP&lt;/strong&gt; : PHP는 1994년 아파치 그룹의 회원인 Rasmus Lerdorf에 의해 개발되었습니다. JavaScript와는 다르게 PHP는 서버에서 인터프리팅하는 특징이 있습니다. 주로 웹에서 데이터베이스 관리 시스템을 운영할 때 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/58.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt; : Python은 1991년 네덜란드의 프로그래머 귀도 반 로썸에 의해 개발되었습니다. 1989년 크리스마스 주에 할게 없어서 연구실에 나와서 만든 에피소드로 유명합니다. Python은 객체 지향 스크립트 언어로써 타입 검사는 하지만 동적인 타입을 갖고 있다는 특징을 가지고 있습니다. Python은 CGI 프로그래밍과 폼 처리에 사용되며 리스트, 튜플, 해쉬 등의 자료구조를 지원합니다. 사실 요즘은 거의 만능으로 사용되는 언어입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Lua&lt;/strong&gt; : Lua는 1993년 리우 데 자네이루 교황청대학교의 Roberto Ierusalimschy, Waldemar Celes, Luis Herique de Figueiredo에 의해 개발되었습니다. Lua는 확장성을 갖는 절차적 함수형 언어를 지원하는 스크립트 언어를 목적으로 하였으며, 객체 지향 프로그래밍도 가능하도록 확장이 가능하다는 특징을 가지고 있습니다. Lua는 주로 게임 프로그래밍에서 많이 쓰이는 언어입니다. Lua의 테이블이라는 1개의 자료구조만 존재합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/59.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ruby는 1996년 Yukihiro Matsumoto에 의해 개발되었습니다. Ruby는 Perl과 Python과는 달리 순수 객체 지향 언어로써, 클래스와 객체들도 모두 동적이라는 특성을 가지고 있습니다. 또한 Python과 마찬가지로 Ruby도 사용자가 목적에 맞게 언어를 확장할 수 있다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/60.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C#은 마이크로소프트가 .NET 프로젝트와 함께 개발된 언어입니다. 기본적으로 C++, Java 등의 언어에서 강하게 영향을 받았으며, 컴포넌트 기반(특히 .NET Framework) 소프트웨어 개발을 위한 목적으로 설계되었습니다. 그리고 C#은 개발사인 마이크로소프트에서 사용하던 C#, Visual Basic, .NET, Managed C++ 등의 언어와 결합하기 위한 Common Type System을 사용합니다. 따라서 이들은 공통 라이브러리를 사용하고 동일한 중간 언어로 번역됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/61.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 마크업/프로그래밍 하이브리드 언어에 대해 두 개만 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;XSLT(eXtensible Stylesheet Language Transformation)&lt;/strong&gt; : XSLT가 나타난 배경은 기존에 사용하던 XML(eXtensible Markup Language)라는 마크업 언어로 생성된 XML 문서를 HTML 문서로 변환하기 위해서입니다. XML과 HTML 둘 다 마크업 언어이지만, XSLT는 마크업 언어를 기반으로 하면서도 반복문과 같은 프로그래밍 언어의 특징을 조금 갖고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JSP(Java Server Pages)&lt;/strong&gt; : JavaScript와는 다르게 JSP는 진짜 자바와 관련이 있는 언어입니다. 서블릿(Servlet)은 웹 서버 시스템에서 실행되는 Java 클래스이고, 웹 브라우저에 있는 HTML 문서에 의해 실행이 요청됩니다. JSP는 Java와 마찬가지로 자바 가상 머신 위에서 실행되므로, JSP 소스를 수정 없이 다른 Java 프로그램에 넣어도 실행이 가능합니다. JSP 문서의 처리를 제어하기 위해서는 JSTL(Java Server Pages Standard Tag Library)을 이용합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/62.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지금까지 많은 프로그래밍 언어를 살펴보았습니다. 특히 소개했던 주요 언어의 특징을 단순히 외우기보다는 해당 언어가 프로그래밍 언어의 역사에 어떤 영향을 끼쳤는지를 중심으로 생각해보시는 것을 권장드립니다. 최상단에 나와있는 프로그래밍 언어의 계보를 보면서 공부하시면 더 좋습니다.&lt;/p&gt;

&lt;p&gt;2장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Preliminaries</title><link href="http://localhost:4000/pl/preliminaries/" rel="alternate" type="text/html" title="Preliminaries" /><published>2023-08-18T00:00:00+09:00</published><updated>2023-08-18T00:00:00+09:00</updated><id>http://localhost:4000/pl/preliminaries</id><content type="html" xml:base="http://localhost:4000/pl/preliminaries/">&lt;p&gt;안녕하세요, 오늘은 프로그래밍 언어론의 첫 장인 Preliminaries를 다뤄보겠습니다. 모든 과목이 마찬가지이지만, 첫 장은 보통 이 과목에서 어떤 것을 배우는지에 대한 간략한 소개가 나와 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 프로그래밍 언어라는 것은 무엇일까요? 사람이 다른 사람들과 소통하기 위해 자연어(한국어, 영어, 일본어, 등등)를 사용해서 대화를 하는 것처럼, 사람이 컴퓨터와 소통하기 위해 사용하는 것이 프로그래밍 언어입니다. 프로그래밍 언어라고 하면 C, C++, Java, Python 등을 생각하겠지만, 이런 언어들은 비교적 최근에 개발된 고급 언어(High Level Language)입니다. 이러한 고급 언어들은 사람들이 사용하기 매우 편한 장점이 있지만, 처음부터 프로그래밍 언어가 이렇게 사용이 편한 것은 아니었습니다. 현대 프로그래밍 언어에는 이미 당연하다시피 적용되어 있는 개념이나 규칙은 과거에는 당연하지 않았기 때문입니다. 다양한 프로그래밍 언어들이 개발되어 옴에 따라 프로그래밍 언어를 편리하게 사용하기 위한 개념과 규칙이 정립되기 시작했는데, 본 과목은 이러한 것들을 학습하는 것을 목표로 합니다.&lt;/p&gt;

&lt;p&gt;그렇다면 이런 것들을 왜 배우는 것일까요? 프로그래밍 언어가 동작하는 과정을 이해하게 된다면, 프로그래밍을 할 때 좀 더 효율적으로 동작하게끔 설계할 수 있기 때문입니다. 예를 들어, 함수를 호출할 때는 스택(Stack)을 이용합니다. 어셈블리 언어 관련 수업을 들어보신 분이라면 스택을 쌓고 다시 불러오는 과정이 생각보다 많은 시간을 필요로 하게 되는데, 그렇기 때문에 재귀문(Recursion)은 보기에는 간단해보여도 동적 프로그래밍(Dynamic Programming) 같은 방법에 비해 실제 수행 시간이 높게 나오게 됩니다. 이렇게 스택이 가지는 특징을 이해하고 있다면, 프로그램을 구현할 때 재귀문을 최대한 배제하고 다른 방법으로 구현하게 되겠지요.&lt;/p&gt;

&lt;p&gt;또한 프로그래밍 언어들이 가지고 있는 특징이나 규칙을 배우고 나면 새로운 프로그래밍 언어를 배우게 쉬워집니다. &lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot;&gt;TIOBE INDEX&lt;/a&gt;에 따르면 현재 주로 사용되고 있는 언어는 Python, C, C++ 순입니다. 그러나 10년 전만 하더라도 Python은 5순위에도 못들던 언어였습니다. 10년 후에는 어떤 프로그래밍 언어가 대세가 될지 모릅니다. 그렇기 때문에 새로운 프로그래밍 언어를 배우는 능력은 컴퓨터공학자에게 있어서 매우 중요한 능력입니다. 프로그래밍 언어는 절차 언어(Procedural Language)와 적용 언어(Applicative Language) 두 가지 종류로 나뉘는데, 본 과목에서는 절차 언어를 주로 다루고, 필요한 경우에만 적용 언어를 언급하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;본 과목에서는 프로그래밍 언어의 필수 요소인 데이터(Date), 제어(Control), 부프로그램(Subprogram), 그리고 객체 지향 프로그래밍(Objective Oriented Programming)에 대한 개념을 정립하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로그래밍 언어론을 배우는 순서는 위 그림과 같습니다. Preliminaries 다음에 History 부분이 빠져있는데, 이 부분은 전체 내용에 크게 영향을 주지 않는 부분이라 그런 것 같습니다. 저는 이 부분도 배울 점이 있다고 생각해서 잠깐이지만 짚고 넘어가고자 합니다.&lt;/p&gt;

&lt;p&gt;그 다음에는 프로그래밍 언어에 대한 기본적인 특징을 배우게 됩니다. 타입 체킹, 데이터 타입, 표현식, 제어문 같은 것들을 다룹니다. 일반적으로 여기까지 배운 후 중간고사를 치르게 됩니다.&lt;/p&gt;

&lt;p&gt;다음은 후반부의 메인 파트인 부프로그램에 대해 배우고, 남은 시간에는 객체 지향 프로그래밍에 관련된 내용을 배우게 됩니다. 일반적으로 대학교 학부의 교육 시간 상 12장까지 배우게 되고, 조금 욕심을 부리면 13장까지 배울 수도 있긴 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이것은 프로그래밍 언어들의 족보라고 보시면 됩니다. 연도별, 프로그래밍 언어가 어느 언어를 근간으로 발전했는지 나와있습니다. 이 그림은 2장에서 조금 더 자세하게 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 1장의 본격적인 내용을 시작해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 프로그래밍 언어론을 배우는 이유에 대해 하나씩 자세하게 알아봅시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;생각을 표현할 수 있는 능력이 향상됨&lt;/strong&gt; : 프로그래밍 언어의 특징에 대해서 더 많이 알고 있다면, 사용할 수 있는 데이터의 구조나 제어 구조를 이해하여 더 효율적인 소프트웨어의 개발을 가능합니다. 만약 주로 사용하는 언어에서 지원하지 않는 기능에 대해 배운다고 할지라도, 그것을 시뮬레이션 할 수 있는 방법이 종종 있기 때문에 도움이 되는 것은 마찬가지입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;적합한 언어를 선택할 수 있는 능력이 향상됨&lt;/strong&gt; : 만약 프로그래머가 여러 프로그래밍 언어를 알고 있고, 각 프로그래밍 언어의 특징에 대해 자세히 알고 있다면 언어를 선택할 때 어떤 언어가 주어진 문제를 해결하는데 가장 적합할지 판단할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;새로운 언어를 배울 수 있는 능력이 향상됨&lt;/strong&gt; : 프로그래밍 언어가 가지고 있는 기본 개념을 이해한다면, 다른 언어를 배울 때도 훨씬 쉽게 이해할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구현의 중요성에 대해 더 많이 이해할 수 있음&lt;/strong&gt; : 이것은 프로그래밍 언어를 보다 효율적으로 사용할 수 있는 능력과 같습니다. 예를 들어, 부프로그램을 호출하는데 생각보다 많은 시간이 필요하다는 것을 이해하고 있다면, 자잘한 연산을 위한 부프로그램을 만들지 않도록 설계할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이미 알고 있는 언어를 더 효율적으로 사용할 수 있음&lt;/strong&gt; : 최근에 사용되고 있는 프로그래밍 언어는 지원하는 기능이 굉장히 많기 때문에 프로그래머가 모든 것을 잘 알고 사용하는 경우는 거의 없습니다. 하지만 프로그래밍 언어론을 학습한다면 이전에 몰라서 사용하지 못했던 기능을 배워서 사용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;컴퓨터에 대해 더 많이 이해할 수 있음&lt;/strong&gt; : 초기에는 컴퓨터공학에 대한 지식이 부족한 사람이 많았기 때문에 효율적인 프로그래밍 언어가 개발되더라도 프로그래머들이 메뉴얼을 이해하지 못하여 사용하지 못했던 경우가 있습니다. 프로그래밍 언어의 구조와 특징을 학습한다면, 이것이 수행되는 과정을 더욱 잘 이해할 수 있게 되므로 이러한 문제를 방지할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로그래밍 언어는 다양한 분야에 사용되고 있습니다. 간단하게 몇 개만 짚어보자면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;과학 분야&lt;/strong&gt; : 최초의 컴퓨터도 복잡한 계산을 용이하게 하기 위한 계산기였습니다. 따라서 초기 프로그래밍 언어도 행렬과 같은 복잡한 계산을 수행할 수 있도록 설계되었습니다. 과학 분야에 사용하도록 개발된 첫 언어는 바로 Fortran(Formula Translator)으로, 수식을 컴퓨터로 계산할 수 있게 만드는 프로그래밍 언어입니다. 현재 컴퓨터의 용도는 다양하지만, MATLAB과 같이 여전히 과학 분야에서 인간이 하기 힘든 계산을 도와주고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;비즈니스 분야&lt;/strong&gt; : 비즈니스에 필요한 기능은 정교한 입출력과 십진수의 처리 능력입니다. 이러한 용도에 적합하게 만들어진 최초의 프로그래밍 언어는 1960년대 COBOL이라는 언어로 구현되었습니다. 그러나 이 외의 사무용 언어는 별도로 개발되지 않았으며, 필요한 경우에는 여전히 COBOL을 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;인공지능 분야&lt;/strong&gt; : 인공지능 분야에서는 주로 기호 계산이 필요합니다. 기호 계산은 숫자가 아니라 문자와 같은 특정한 기호를 조작하는 연산입니다. (자연어 처리를 생각해보시면 됩니다) 이 분야에서 처음으로 사용된 프로그래밍 언어는 1959년에 개발된 LISP이며, 1970년에 그 대항마로 Prolog가 개발되었습니다. 현재는 인공지능 분야에 사용하기 위한 별도의 언어를 개발하기 보단, Python과 같은 시스템 프로그래밍 언어에서 추가적인 라이브러리를 적용하여 사용하고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시스템 프로그래밍&lt;/strong&gt; : 시스템 소프트웨어는 컴퓨터를 사용할 수 있게 만드는 운영체제와 같은 프로그램을 일컫는 말입니다. 컴퓨터를 사용하기 위해서는 반드시 필요하기 때문에 그 중요성이 다른 분야와 비교해서 매우 높고, 현재도 시스템 소프트웨어 개발자는 수요가 매우 많습니다. 최초의 시스템 소프트웨어는 어셈블리 언어나 그보다 조금 나은 수준의 언어로 개발되었으나, 현재는 C/C++ 등의 고급 언어로 개발되고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;웹 소프트웨어&lt;/strong&gt; : WWW(World Wide Web)은 프로그래밍 언어가 아닌 HTML과 같은 마크업 언어가 주로 사용되고 있습니다. 그러나 이러한 웹 콘텐츠도 동적인 컨텐츠가 필요하기 때문에, 프로그래밍 언어의 일부 기능이 지원됩니다. 이런 언어는 스크립트 언어라고 불리며 대표적인 예로 JavaScript나 PHP가 존재합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여러 프로그래밍 언어의 구조와 특징을 배우다보면 특정 프로그래밍 언어가 기존 프로그래밍 언어들에 비해 얼마나 우수한지를 평가해야할 수도 있습니다. 평가를 하기 위해서는 평가에 대한 기준이 있어야 보다 객관적인 평가가 가능합니다. 그러나 교재에서 소개하는 프로그래밍 언어의 평가 기준에는 주관적인 평가도 있기 때문에 완벽한 기준과는 거리가 있음을 기억하셔야 합니다.&lt;/p&gt;

&lt;p&gt;교재에서는 프로그래밍 언어의 평가 기준을 &lt;strong&gt;가독성(Readability)&lt;/strong&gt;, &lt;strong&gt;작성력(Writability)&lt;/strong&gt;, &lt;strong&gt;안정성(Reliability)&lt;/strong&gt;, &lt;strong&gt;비용(Cost)&lt;/strong&gt;으로 나누었습니다. 각각의 평가 기준에 어떤 요소가 포함되는지는 다음 슬라이드부터 하나씩 자세하게 소개하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 가독성은 해당 프로그래밍 언어로 작성한 프로그램을 얼마나 쉽게 이해할 수 있는지를 나타내는 척도입니다. 1970 ~ 80년대에 소프트웨어 생명 주기(Software Life Cycle)이란 개념이 도입되고 나서 프로그램을 제작하는 것 자체보다 유지 및 관리의 중요성이 부각되었습니다. 가독성이 좋은 프로그램일수록 유지 및 보수가 그만큼 간단하기 때문에 프로그래밍 언어의 우수성을 측정하는 중요한 척도가 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;가독성에 영향을 주는 요소 중 하나는 &lt;strong&gt;단순성(Simplicity)&lt;/strong&gt;입니다. 프로그래밍 언어에서 지원하는 기본적인 구조가 많을수록 배우기 어렵다는 것은 자명한 사실입니다. 또한 같은 연산을 수행하는데 여러 가지의 수행 방법을 갖는 특징 다중성(Feature Multiplicity)도 영향을 끼칩니다. 그리고 연산자 오버로딩(Operator Overloading)이 빈번하게 일어나는 언어라면 가독성에 악영향을 미칠 수 있습니다. 그렇다고 너무 단순해도 가독성에 나쁜 영향을 미칠 수 있는데, 대표적으로 어셈블리 언어는 매우 단순한 특징을 가지고 있지만, 그로 인해 동일한 기능을 수행하기 위해서 고급 언어보다 더 많은 코드가 필요하다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;또 다른 요소 중 하나는 &lt;strong&gt;직교성(Orthogonality)&lt;/strong&gt;입니다. 이 단어는 일상생활에서 잘 사용하지 않아서 단어만 보고 의미를 유추하기 힘든데, 쉽게 말하면 프로그래밍 언어의 제어 및 데이터 구조를 구축하기 위해 결합할 수 있는 구성 집합이 얼마나 적은지를 나타냅니다. 더 간단하게 말하자면 프로그래밍 언어에서 사용되는 규칙에 예외가 적을수록 직교성이 높습니다. 예를 들어, C언어에서 a + b라는 문구는 일반적으로 변수 a와 b의 값을 더하는 것을 의미합니다. 그런데 만약 a가 정수형 포인터라면, b의 값에 4가 곱해져서 a + b = 50이 됩니다. 이것은 + 연산의 예외로써, 직교성을 나쁘게 만드는 것으로 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;세 번째 요소는 &lt;strong&gt;제어문(Control Statements)의 적절한 사용&lt;/strong&gt;입니다. 특히, 프로그램은 위에서 아래로 읽을 수 있도록 만드는 것이 가독성을 높이는 방법입니다. 초기 프로그래밍 언어에서는 Go To라는 문법이 있어서, 원하는 곳으로 라인을 점프할 수 있었습니다. 이것은 프로그램을 작성할 때 도움이 될 수도 있지만, 읽는 사람의 입장에서는 이곳 저곳으로 점프하면서 읽어야 하기 때문에 가독성을 해치게 됩니다. 따라서 최근 개발되는 프로그래밍 언어들은 Go To 문을 사용하지 않는 GOTO-less 형식으로 디자인됩니다.&lt;/p&gt;

&lt;p&gt;다음 고려할 수 있는 요소는 &lt;strong&gt;데이터 타입과 구조체(Data Types and Structures)&lt;/strong&gt;입니다. 이것은 프로그래밍 언어에서 데이터 타입이나 데이터 구조를 정의할 수 있는 충분한 기능이 존재하는지에 대한 여부입니다. 예를 들어, Boolean 형의 데이터 타입이 제공되지 않는다면, 총합(sum)이 너무 큰 경우를 나타내는 변수를 sum_is_too_big = 1와 같이 표현해야 할 것입니다. 이 경우 의미가 분명하지 않아서 가독성이 떨어질 수 있는데, 만약 Boolean 형의 데이터 타입이 제공된다면 sum_is_too_big = true와 같이 보다 명확하게 나타낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 말씀드릴 요소는 &lt;strong&gt;구문 설계(Syntax Considerations)&lt;/strong&gt;입니다. 프로그래밍 언어에 따라 변수를 선언할 때 밑줄이 허용되는 경우도 있고, 허용되지 않는 경우도 있습니다. 만약 밑줄이 허용된다면 SUM_OF_SQUARE와 같이 변수가 어떤 것을 의미하는지 보다 명확하게 이름을 작성할 수 있습니다. 또한 프로그램 내에서 사용되는 특수어를 만들어서, 프로그램 내의 제어문의 범위를 명확화게 표현해줄 수 있습니다. 예를 들어, if 문을 시작하고 나서는 마지막에 end if로 마무리해서 if 문의 범위를 명확하게 표시하는 방법이 있습니다. C-like 언어들은 특수어를 사용하지 않고 중괄호를 사용하기 때문에 이 부분에서 다소 가독성이 떨어진다고 볼 수 있습니다. 또한 같은 문법을 사용할 때 매개변수의 위치에 따라 의미가 달라지는 경우도 구문 설계를 잘못한 예시 중 하나입니다.&lt;/p&gt;

&lt;p&gt;다음은 작성력이란 척도입니다. 작성력은 풀고자 하는 문제를 해결하기 위한 프로그램을 작성하는 데 해당 프로그래밍 언어가 얼마나 쉽게 사용할 수 있는지를 나타냅니다. 작성력에는 가독성에서와 같이 단순성과 직교성이 영향을 미칩니다. 이것은 가독성을 설명할 때 설명한 요소이므로 생략하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;가독성과 다르게 작성력에 영향을 미치는 요소 중 하나는 &lt;strong&gt;추상화를 지원(Support for Abstraction)&lt;/strong&gt;하는가의 여부입니다. 추상화는 세부적인 구현 내용을 무시하고 데이터 구조나 연산을 정의하여 사용하는 방법입니다. 추상화는 프로세스 추상화와 데이터 추상화 2가지 종류로 나눌 수 있는데, 프로세스 추상화의 예시는 부프로그램 이용, 데이터 추상화는 레코드 타입을 이용하는 것이 그 예가 될 수 있습니다. C 언어에서 부프로그램은 함수, 레코드 타입은 구조체로 구현되어 있습니다.&lt;/p&gt;

&lt;p&gt;작성력에 영향을 미치는 또 다른 요소는 &lt;strong&gt;표현력(Expressivity)&lt;/strong&gt;입니다. 표현력은 같은 양의 계산을 보다 적은 코드로 수행이 가능하게 만드는 것입니다. 예를 들어, C 언어에서 count라는 변수를 1 증가시키는 방법은 count = count + 1도 있지만, count++로 간단하게 대체할 수 있습니다. count++이 count = count + 1보다 훨씬 간단한 표기이기 때문에 작성력을 향상시킨다고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 척도는 신뢰성입니다. 만약 프로그램이 모든 조건 하에서 주어진 명세에 따라 수행된다면 신뢰적이라고 말할 수 있습니다. 이번에는 신뢰성이 영향을 미치는 요소를 하나하나 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;가장 먼저 신뢰성에 영향을 미치는 요소는 &lt;strong&gt;타입 검사(Type Checking)&lt;/strong&gt;입니다. 여러 개의 변수를 포함한 연산을 수행할 때, 그 변수간의 연산이 가능한지 타입을 체크해야 합니다. 일반적으로 런타임 시간 검사는 비효율적이기 때문에 컴파일 시간 검사를 구현하는 것이 바람직합니다. 고전적인 C 언어가 대표적으로 타입 검사를 하지 않는 언어이며(현재는 매개변수 타입 검사를 컴파일 시간에 수행합니다), Pascal 언어는 대부분 컴파일 시간에 타입 검사를 수행하지만, 범위 검사와 같은 일부분의 검사는 런타임에 수행합니다.&lt;/p&gt;

&lt;p&gt;신뢰성에 영향을 미치는 두 번째 요소는 &lt;strong&gt;예외 처리(Exception Handling)&lt;/strong&gt;입니다. 예외 처리는 컴파일 시간에서는 알 수 없고 런타임 시간에 발생할 수 있는 오류를 대처하는 방법입니다. C 언어는 대표적으로 예외 처리가 지원되지 않는 언어이고, Java는 강력한 예외 처리를 지원하고 있습니다.&lt;/p&gt;

&lt;p&gt;신뢰성에 영향을 미치는 또 다른 요소로는 &lt;strong&gt;별칭(Aliasing)&lt;/strong&gt;이 있습니다. 별칭은 동일한 메모리 공간에 대해 서로 다른 두 가지 이상의 접근 방법이 존재하는 것입니다. 이것은 의도치 않게 저장된 데이터를 변경시킬 수 있는 위험이 있기 때문에, 대부분 프로그래밍 언어에서 지양하는 특징입니다. 최근에 사용되는 프로그래밍 언어에서는 아예 지원하지 않거나, 제한된 방법으로만 별칭을 사용할 수 있게 제한하고 있습니다. 별칭을 구현한 대표적인 방법은 포인터가 있습니다.&lt;/p&gt;

&lt;p&gt;마지막으로 고려할 수 있는 요소는 가독성과 작성력입니다. 만약 가독성이 낮다면 프로그램의 유지 보수에 큰 영향을 미치기 때문에 신뢰성을 낮출 위험이 있고, 작성력이 낮다면 프로그램을 구현할 때 보다 부자연스러운 방법으로 구현하기 때문에 신뢰성에 악영향을 미칠 가능성이 높아지기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 프로그래밍 언어에서 고려하는 기준은 비용입니다. 프로그래밍 언어에서 비용은 다양한 측면에서 고려될 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로그래머를 교육하는 비용&lt;/strong&gt; : 배우기 어려운 언어일수록 프로그래머를 교육시키는데 많은 비용이 들어감 (ex. C++)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로그램을 작성하는 비용&lt;/strong&gt; : 작성력이 낮은 언어일수록 작성하는 데 오랜 시간이 소모됨&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로그램을 컴파일 하는 비용&lt;/strong&gt; : 컴파일 시간이 오래 걸릴수록 오랜 시간이 소모됨 (ex. 초기 Ada)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로그램을 실행시키는 비용&lt;/strong&gt; : 런타임 시간에 타입 검사를 많이 할수록 오랜 시간이 소모됨.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로그램을 유지, 보수하는 비용&lt;/strong&gt; : 가독성이 낮은 언어일수록 코드를 수정하는데 오랜 시간이 소모됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;제시한 기준 외에도 프로그래밍 언어를 평가하는데 다른 기준을 세울 수도 있습니다. 예를 들어, 언어가 얼마나 표준화가 잘 되었는지 판단하는 &lt;strong&gt;이식성(Portability)&lt;/strong&gt;, 얼마나 광범위한 분야에 응용할 수 있는지 나타내는 &lt;strong&gt;일반성(Generality)&lt;/strong&gt;, 프로그래밍 언어가 얼마나 명세화가 잘 되었는지 나타내는 &lt;strong&gt;분명성(Well-definedness)&lt;/strong&gt; 등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로는 프로그래밍 언어 설계에 영향을 미친 요소들을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;가장 먼저 살펴볼 것은 컴퓨터 구조(Computer Architecture)입니다. 특히 지금까지 프로그래밍 언어에 가장 큰 영향을 미친 구조는 폰 노이만 구조(von-Neumann Architecture)입니다. 폰 노이만 구조에 영향을 받은 프로그래밍 언어를 &lt;strong&gt;명령형 언어(Imperative Languages)&lt;/strong&gt;라고 합니다. 명령형 언어는 데이터와 프로그램이 동일한 기억 장소에 저장되며, 변수, 배정문, 반복문 등의 특징을 가지고 있습니다. 그렇기에 명령형 언어는 문제를 어떻게 풀 것인가에 초점을 맞추게 됩니다.&lt;/p&gt;

&lt;p&gt;명령형 언어의 단점 중 하나는 &lt;strong&gt;폰 노이만 병목(von-Neumann Bottleneck)&lt;/strong&gt; 현상이 발생할 수 있다는 것입니다. 컴퓨터 하드웨어에서 CPU의 처리 속도는 매우 빠르지만, 저장 장치에서 CPU까지 전달 속도가 느리기 때문에 CPU가 대기하는 상태를 말합니다. 이 문제를 해결하기 위한 방법 중 하나가 바로 캐시(Cache)이지만, 이것으로도 폰 노이만 병목 현상은 완전히 해결할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령형 언어와는 다르게, 폰 노이만 구조에 영향을 받지 않은 프로그래밍 언어를 선언형 언어(Declarative Languages)입니다. 이러한 언어들은 배정문이나 반복문 없이 함수형 언어로 프로그래밍이 가능합니다. 그러나 아직 선언형 언어를 완벽하게 수행할 수 있는 하드웨어가 개발되지 않았기 때문에, 이러한 컴퓨터가 개발되기 전까지는 명령형 언어를 대체할 수 없다고 보여집니다.&lt;/p&gt;

&lt;p&gt;폰 노이만 구조가 아닌 컴퓨터는 순차 제어나 변수의 개념이 없을 수 있고, 높은 수준의 병렬 처리와 변수의 사용 대신 이름과 상수 값 간의 강한 구속력이 존재할 것으로 예상하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로그래밍 언어의 설계에 영향을 미친 또 다른 하나는 해당 시기에 중요하게 생각했던 소프트웨어 개발 방법론입니다. 시간이 지날수록 하드웨어의 비용은 감소하고, 소프트웨어의 비용이 증가함에 따라 소프트웨어를 쉽게 만들 수 있는 방법을 연구하기 시작했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;70년대 초에는 GOTO 문의 비효율성을 인식하고, 위에서 아래로 읽어나갈 수 있는 구조적 프로그래밍이란 개념이 정립되었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;70년대 말부터는 데이터 설계를 중요하게 생각하였기 추상 데이터 타입과 같이 데이터 추상화를 지원하기 시작하였습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;80년대 초에는 객체지향 프로그래밍의 개념이 도입되어 상속과 같이 기존 프로그램을 재사용성을 늘리게 되었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비주류적인 방법론 중 대표적으로 프로세스 지향 프로그래밍이 있습니다. 프로세스 지향 프로그래밍은 데이터 지향 방법과 달리 동시성(Concurrrency)을 도입하여 동일한 시간 내에 여러 프로세스를 실행할 수 있는 방법을 고안하였습니다. Java는 프로세스 지향 프로그래밍에 영향을 받은 언어 중 하나입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로그래밍 언어를 설계할 때, 지금까지 제시한 모든 기준을 만족시키고 싶지만 아쉽게도 여러 기준을 서로 상충하는 단점이 있습니다. 대표적으로 몇 가지를 소개하자면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;신뢰성과 실행 비용은 서로 상충됩니다. 예를 들면, Java는 모든 Index의 범위를 검사함으로써 신뢰성을 향상시켰지만, 이로 인해 실행 비용이 늘어나는 단점이 있습니다. 반대로 C 언어는 Index의 범위를 전혀 검사하지 않아 신뢰성이 떨어지지만, 그만큼 실행 비용이 낮아지는 장점도 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;표현적이 높아지면 코드는 그만큼 깔끔해지지만, 반대로 가독성이 떨어진다는 단점이 있습니다. 예를 들면, APL은 복잡하고 많은 연산을 간단한 연산자로 표현이 가능하지만, 가독성이 심각하게 떨어진다는 단점이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;유연성과 안정성, 유연성과 효율성도 서로 상충됩니다. 예를 들면, C++ 언어는 포인터를 다양한 방법으로 조작할 수 있어서 유연성이 높지만, 그만큼 안정성이 떨어진다는 단점이 있습니다. 또한 프로그래밍 언어에서 유연성이 늘어날수록 예외 사항이 늘어나기 때문에, 코드를 읽을 때나 작성할 때 효율성이 낮아진다는 단점이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 컴퓨터 하드웨어는 기계어만 이해합니다. 그렇기 때문에 컴퓨터에 고급 언어를 이해시키기 위해서는 별도의 소프트웨어가 필요합니다. 이러한 예로써는 컴파일러, 인터프리터, 또는 하이브리드 구현 시스템이 있습니다.&lt;/p&gt;

&lt;p&gt;고급 언어 구현에는 운영체제에서 지원하는 많은 기능들이 필요하기 때문에, 대부분의 고급 언어는 컴퓨터 하드웨어에 직접 연결되지 않고 운영체제에 기능들에 연결되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;컴파일러(Compiler)&lt;/strong&gt;는 고급 언어로 작성된 프로그램을 기계어로 번역하는 방법입니다. 기계어로 번역을 완료한 후에는 또 번역할 필요가 없으므로, 실행 시간이 매우 빠르다는 장점이 있습니다. 그러나 프로그램을 조금만 수정해도 다시 처음부터 번역을 수행해야 하므로, 잦은 수정이 필요한 프로그램에는 적합하지 않습니다. 컴파일러를 사용하는 대표적인 언어로 C 언어가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하이브리드 구현 시스템(Hybrid Implementation System)&lt;/strong&gt;은 고급 언어로 작성된 프로그램을 중간 언어로 번역한 뒤, 중간 언어를 인터프리터처럼 한줄 한줄 번역하는 방법입니다. 이것은 컴파일러와 인터프리터를 적절히 조율한 방법입니다. 하이브리드 구현 시스템을 사용하는 대표적인 예시로 Java 언어가 있습니다. Java 언어는 먼저 작성한 프로그램을 바이트코드(Bytecode)로 번역한 다음, 자바 가상 머신을 통해 기계어로 번역합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/001/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;인터프리터(Interpreter)&lt;/strong&gt;는 컴파일러와 달리 고급 언어를 번역하지 않고, 코드를 한줄 한줄 읽으며 실행하는 방법입니다. 인터프리터는 실행하다가 오류가 발생한 라인에서 멈추기 때문에 디버깅이 용이하다는 장점이 있으나, 실행 시간이 컴파일러에 비해 매우 느리다는 단점이 있습니다. 게다가 실행하는 과정에서 컴파일러보다 더 많은 메모리 공간을 요구하기도 합니다. 최근 가장 많이 사용하는 Python이 인터프리터 방식으로 실행되며, JavaScript와 같은 웹 프로그래밍 언어도 인터프리터를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;사전처리기(Preprocessor)&lt;/strong&gt;는 프로그램이 컴파일되기 전에 프로그램을 처리하는 프로그램으로, 다른 파일에 있는 코드를 현재 프로그램에 포함시키는 역할을 합니다. 예를 들면, C 언어에서는 #include 를 통해 외부 파일의 코드를 불러옵니다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;strong&gt;프로그래밍 환경(Program Environment)&lt;/strong&gt;은 프로그램을 작성하기 위한 도구를 일컫는 말입니다. 이러한 도구들은 파일 시스템, 편집기, 링커, 컴파일러, 디버거, 사용자 인터페이스와 같은 기능을 내장하고 있습니다. 대표적으로 Microsoft의 Visual Studio, Apple의 Xcode, JetBrains의 IntelliJ IDEA 등이 있습니다.&lt;/p&gt;

&lt;p&gt;1장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html">안녕하세요, 오늘은 프로그래밍 언어론의 첫 장인 Preliminaries를 다뤄보겠습니다. 모든 과목이 마찬가지이지만, 첫 장은 보통 이 과목에서 어떤 것을 배우는지에 대한 간략한 소개가 나와 있습니다.</summary></entry><entry><title type="html">Introduction</title><link href="http://localhost:4000/pl/introduction/" rel="alternate" type="text/html" title="Introduction" /><published>2023-08-17T00:00:00+09:00</published><updated>2023-08-17T00:00:00+09:00</updated><id>http://localhost:4000/pl/introduction</id><content type="html" xml:base="http://localhost:4000/pl/introduction/">&lt;p&gt;안녕하세요, 이번에는 새로운 공부 카테고리인 프로그래밍 언어론을 시작하게 되었습니다. 사실 올해는 지난번에 작성하던 자료구조 관련 포스트를 마무리할 계획이었습니다. 게다가 프로그래밍 언어론은 제 전공과도 거리가 멀기 때문에 블로그에 정리할 생각이 없었는데, 제가 2023-2학기에 성신여대에서 이 과목을 담당하게 되어 복습도 할 겸 포스트를 남겨보고자 합니다. 저도 학부 시절 이 과목을 수강했었고 나름 성적도 괜찮게 받았았는데, 지금 다시 보니 기억이 거의 나지 않더라구요. 개강까지 얼마 남지 않았기 때문에 공부를 빡세게 해봐야할 것 같습니다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어론은 컴퓨터공학과 과목에서 흔치 않은 이론 수업입니다. 대부분 컴퓨터공학과 과목들은 이론과 함께 실습을 통한 구현을 중요하게 생각하지만, 프로그래밍 언어론은 지금까지 배운 여러 프로그래밍 언어에 대한 지식을 토대로 프로그래밍 언어에 공통적으로 내제되어 있는 기능들에 대한 분석을 하는 과목입니다. 따라서 이 수업은 수강생들마다 호불호가 있는 과목입니다. 코딩에 자신이 없는 수강생들은 좋아하는 경우가 많지만, 코딩을 통한 구현을 즐기는 수강생들에게는 다소 지루할 수 있습니다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어론을 다루는 교재는 여러 가지가 있지만, 서강대학교 기준으로는 Robert W. Sebesta 저자의 &lt;strong&gt;Concepts of Programming Languages&lt;/strong&gt;라는 교재를 사용합니다. 이 교재는 작성 시점을 기준으로 12판까지 나왔는데, 아직까지 대부분의 학교에서는 10판을 사용하더라구요. 어차피 각 판쇄별 차이는 그다지 크지 않으니, 아무거나 읽으셔도 상관이 없을 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/000/01.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다만 이 책은 교내 서점이 아니면 은근히 구하기 힘들다는 단점이 있습니다. 알라딘에서 찾아보니 12판의 가격이 10만원이 넘더라구요. 제가 학부 시절에 그렇게 비싸게 구매한 것 같지는 않은데 이상하네요. 구글에 찾아보니 10판 교재의 PDF 파일이 인터넷에 올라와 있긴 한데, 이게 합법적인 경로인지는 잘 모르겠습니다. 이것이 꺼림칙하시다면 번역본의 경우에는 합리적인 가격에 팔고 있으니 이걸 알아보시는 것도 좋을 것 같습니다. 아쉬운 점은 번역 품질이 그렇게 좋지는 않더라구요. 번역본의 경우 알라딘 기준 33,000원에 팔고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/000/02.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또는 좀 더 간단한 교재를 이용하시는 방법도 있습니다. 제가 학부 때는 한빛아카데미에서 출판한 서적을 종종 읽으며 공부했었는데, 전공 교재에 비해서 확실히 쉽게 쓰여있었습니다. 다만 이 교재는 후반부의 객체 지향 프로그래밍 관련 내용이 많이 빠져있고, 이전 부분에도 전공 교재에 비해 생략한 부분이 종종 있기 때문에 조금 애매합니다. 비전공자의 경우에는 확실히 도움이 되지만, 이 책만 읽기보다는 이 책으로 개념을 정립한 후에 전공 서적을 읽으며 복습하시는 것을 추천드립니다. 가격은 이 책이 가장 저렴합니다. (알라딘 기준 20,000원)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/000/03.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저는 Concepts of Programming Languages 교재를 기준으로 포스트를 작성하겠습니다. 해당 교재를 기반한 PPT 슬라이드가 있기 때문에, 이것을 같이 올리며 하나하나 설명하도록 하겠습니다. Concepts of Programming Languages의 10판 기준 목차는 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Preliminaries&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Evolution of the Major Programming Languages&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Describing Syntax and Semantics&lt;/li&gt;
  &lt;li&gt;Lexical and Syntax Analysis&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Names, Bindings, and Scopes&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Data Types&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Expressions and Assignment Statements&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Statement-Level Control Structures&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Subprograms&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Implementing Subprograms&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Abstract Data Types and Encapsulation Constructs&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Support for Object-Oriented Programming&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Concurrency&lt;/li&gt;
  &lt;li&gt;Exception Handling and Event Handling&lt;/li&gt;
  &lt;li&gt;Functional Programming Languages&lt;/li&gt;
  &lt;li&gt;Logic Programming Languages&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;물론 일반적으로 프로그래밍 언어론 수업에서 이 모든 것을 다루지는 않습니다. 대표적으로 3장과 4장은 Syntax에 관한 중요한 내용으로 구성되어 있지만, 이 부분은 컴퓨터공학과의 다른 과목인 컴파일러와 중복된 내용이기 때문에 다루지 않는 학교가 많습니다. 또한 13장, 14장은 객체 지향 프로그래밍 언어를 배울 때 다루는 내용이기 때문에 역시 생략하는 학교가 많고, 15, 16장은 특정 프로그래밍 언어에 관련된 내용이 많기 때문에 굳이 다룰 필요가 없는 부분입니다. 제가 포스트에서 다룰 부분은 볼드체로 표시해 놓았습니다.&lt;/p&gt;

&lt;p&gt;과목 소개는 이것으로 마치고, 다음 포스트부터 각 장을 하나씩 정리하도록 하겠습니다. 감사합니다.&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html">안녕하세요, 이번에는 새로운 공부 카테고리인 프로그래밍 언어론을 시작하게 되었습니다. 사실 올해는 지난번에 작성하던 자료구조 관련 포스트를 마무리할 계획이었습니다. 게다가 프로그래밍 언어론은 제 전공과도 거리가 멀기 때문에 블로그에 정리할 생각이 없었는데, 제가 2023-2학기에 성신여대에서 이 과목을 담당하게 되어 복습도 할 겸 포스트를 남겨보고자 합니다. 저도 학부 시절 이 과목을 수강했었고 나름 성적도 괜찮게 받았았는데, 지금 다시 보니 기억이 거의 나지 않더라구요. 개강까지 얼마 남지 않았기 때문에 공부를 빡세게 해봐야할 것 같습니다.</summary></entry><entry><title type="html">도쿄 여행기 (10)</title><link href="http://localhost:4000/travel/tokyo-10/" rel="alternate" type="text/html" title="도쿄 여행기 (10)" /><published>2023-08-14T00:00:00+09:00</published><updated>2023-08-14T00:00:00+09:00</updated><id>http://localhost:4000/travel/tokyo-10</id><content type="html" xml:base="http://localhost:4000/travel/tokyo-10/">&lt;p&gt;결국 길었던 도쿄 여행이 끝나고 어느덧 귀국하는 날이 왔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/01.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막 날에도 역시 호텔 조식을 먹어야겠지요. 지금까지 맛있게 먹었던 메뉴들만 가득 담아와서 식사를 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/02.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;식사 후에는 호텔 방으로 돌아와 짐을 다시 꾸렸습니다. 방을 꼼꼼히 둘러보면서 놓고 가는 물건이 없는지 계속 확인했네요. 좋았던 방을 놔두고 떠나려니 여러모로 아쉬운 기분이 듭니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/03.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직전에 묵었던 렘 플러스 긴자도 기계를 이용한 체크아웃을 했었는데, 여기도 마찬가지로 기계를 사용하는 방식이네요. 일본에서는 이게 대중적인 체크아웃 방식인가 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/04.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;체크아웃용 기계에서 한국어도 지원했었기 때문에 간단하게 체크아웃을 끝냈습니다.&lt;/p&gt;

&lt;h2 id=&quot;하네다-공항으로-가는-길&quot;&gt;하네다 공항으로 가는 길&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d51902.602004209446!2d139.71063272071305!3d35.605221824121855!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e3!4m5!1s0x60188be9c8ba51c5%3A0x7655519b9b5d879b!2z7J2867O4IOuPhOy_hOuPhCDrr7jrgpjthqDqtawg7Iug67CU7IucIDIg7KGw66mU4oiSMjAsIOyLoOuwlOyLnOyXrQ!3m2!1d35.665877!2d139.759521!4m5!1s0x6018640ba43192e3%3A0xd32c3a9d146f8df!2z64-E7L-EIOq1reygnOqzte2VrSAoSE5EKSBIYW5lZGFrdWtvLCBPdGEgQ2l0eSwgVG9reW8gMTQ0LTAwNDEg7J2867O4!3m2!1d35.5493932!2d139.7798386!5e0!3m2!1sko!2skr!4v1691989286258!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;라비스타 도쿄베이에서 하네다 공항까지 가는 경로는 의외로 꽤 많았습니다. 구글 지도상으로 추천해주는 경로는 유리카모메를 타고 도요스 역으로 가서 하네다 공항버스를 타는 것이었는데, 버스는 도로 상황에 따라 시간 변동이 크고 탑승 위치나 방법을 정확하게 모르고 있었기 때문에 기차를 이용하기로 했습니다.&lt;/p&gt;

&lt;p&gt;약간 돌아가는 경로긴 하지만, 저는 유리카모메를 타고 신바시 역으로 갔습니다. 신바시 역에서는 케이큐 공항선이 지나가는데, 급행 열차를 타면 30분 안에 하네다 공항까지 갈 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/05.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일본의 지하철과 기차는 다소 복잡한 구조를 가지고 있습니다. 제가 케이큐 공항선을 탄다고 했지만, 실제로 케이큐 공항선은 하네다 공항부터 케이큐카마타 역 까지로 구성되어 있습니다. 그럼 어떻게 신바시 역에서 하네다 공항까지 한번에 가느냐? 그 이유는 케이큐 공항선이 아사쿠사 선과 직통으로 연결되어 있기 때문입니다. 즉, 신바시 역에서 아사쿠사 선 승강장에 간 후, 목적지를 확인하여 하네다 공항으로 가는지를 확인하고 탑승하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/06.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하네다 공항행 열차는 특급, 쾌특, 에어포트 특쾌 이렇게 3가지 종류가 있습니다. 사실 세 종류 열차 모두 하네다 공항으로 가기 때문에 뭘 타도 상관은 없습니다. 차이가 나는 것은 하네다 공항까지 가는 동안 어떤 정거장에서 멈추는지에 대한 차이 뿐입니다. 속도로만 따지면 특급 &amp;lt; 쾌특 &amp;lt; 에어포트 특쾌입니다만, 구글 지도에서 경로를 확인해보니 늦게 출발하는 에어포트 특쾌가 먼저 출발하는 특급을 앞서지는 않더라구요. 그냥 목적지가 하네다 공항행이기만 한다면 아무거나 탑승하셔도 무방합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/07.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저는 사진을 찍는 동안 열차를 하나 놓쳐버려서 에어포트 특쾌를 탔습니다. 열차 앞에 행선지를 나타내는 부분의 글자가 깨져서 뭔가 세기말 느낌이 나네요.&lt;/p&gt;

&lt;h2 id=&quot;하네다-공항-라운지&quot;&gt;하네다 공항 라운지&lt;/h2&gt;

&lt;p&gt;제가 이용했던 전일본공수(ANA)는 공항 라운지 입장권을 별도로 판매했습니다. 구매할 당시 약 4만원 정도였는데, 음식도 제공해주기 때문에 비행기 탑승시간까지 편안하게 대기하는게 가능합니다. 저는 오후 4시 10분에 출발하는 일정이었는데, 시간을 따져보니 라운지에서 4시간 정도 머물 수 있을 것 같았습니다. 식사도 해결할 수 있고 커피도 마음껏 마실 수 있는데 시간당 만원 꼴이라고 생각하니 가성비가 나쁘지 않다고 생각했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/08.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하네다 공항 라운지는 출국수속 후 면세점이 있는 곳에 위치해 있습니다. 출국수속을 마치니 바로 오른쪽에 라운지의 위치를 안내하는 간판이 보여서 바로 이동하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/09.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;라운지는 2가지 종류가 있더라구요. 저처럼 입장권을 구매하신 분은 ANA LOUNGE로 가면 됩니다. ANA SUITE LOUNGE는 VIP 고객을 위한 라운지인 것 같네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/10.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;라운지에 들어가니 항공사 직원분이 여권을 확인하고 바로 입장을 도와줬습니다. 가는 도중에 보니 샤워실도 따로 마련되어 있더라구요. 저는 호텔에서 샤워를 하고 나와서 이용하지는 않았지만, 유용하게 사용하는 사람도 있을 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/11.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;라운지의 모습입니다. 좌석은 카페 좌석, 소파 좌석, 도서관 좌석 등등 굉장히 다양합니다. 저는 식사를 할 때는 식당 좌석 처럼 보이는 곳에 앉아서 식사했고, 커피를 마실 때는 소파 좌석에 앉아 책을 읽으며 시간을 보냈습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/12.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;라운지에서는 술까지 무료로 제공하네요. 저녁 시간이었으면 저도 마셨을 것 같은데, 대낮부터 술을 마시긴 좀 그래서 눈물을 머금고 걸렀습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/13.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가자마자 점심을 해결할 겸 음식을 받아왔습니다. 메뉴는 많지 않았지만 그래도 간단하게 식사를 할 수 있는 빵 종류와 가라아게가 보여서 가져왔습니다. 그리고 여기 소바가 맛있다는 소문을 들어서 소바도 한 그릇 받아왔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/14.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;창가쪽 좌석을 앉아 식사를 했는데, 바깥에서 비행기가 지나가는 모습이 그대로 보여서 풍경이 꽤 괜찮았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/15.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;식사를 마치고 소파 좌석에서 책을 보다가, 메뉴가 바뀌었길래 또 음식을 들고 왔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/16.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/17.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;라운지에서 시간을 보내고 탑승시간이 슬슬 다가오자 면세점으로 가서 기념품을 구매하기로 했습니다. 뭘 살까 하다가, 시로이 코이비토를 우선 사고, 녹차맛 포키를 사는 사람이 많이 보여서 그 두 개를 구매했습니다.&lt;/p&gt;

&lt;h2 id=&quot;비행기-탑승&quot;&gt;비행기 탑승&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/18.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;면세점에서 기념품을 구입한 후에 바로 비행기를 타러 갔습니다. 전일본공수가 일본의 FSC이기 때문에 당연히 탑승교를 통해서 탑승할줄 알았는데, 버스를 타고 가서 계단을 직접 올라가야되더라구요. 전 이걸 굉장히 싫어해서 조금 실망했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/19.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비행기가 이륙하고 나서 곧 기내식이 나왔는데, 진짜 별로였습니다. 밥도 밥이지만 밥 위에 올라온 생선이 참 표현하기 어려운 묘한 맛이 났습니다. 그렇다고 밑반찬이 맛있는 것도 아니고… 아무리 생각해봐도 기내식은 아시아나 압승입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/016/20.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기내식을 먹고 얼마 지나지 않아 곧 착륙한다는 방송이 나오더니 금방 도착했습니다. 표기 시간으로는 제주도보다 2배 이상 걸리는데, 체감상으로는 이상하게 제주도보다 빨리 도착한다는 느낌이네요. 기내식을 먹어서 그런걸까요?&lt;/p&gt;

&lt;p&gt;이렇게 9박 10일 도쿄 여행이 모두 끝이 났습니다. 정말 재밌었고 기회가 된다면 또 가보고 싶네요. 도쿄는 근교를 포함하면 관광지가 엄청 많아서, 한 달 정도 머무르면서 여행해도 좋을 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;여행-경비-정리&quot;&gt;여행 경비 정리&lt;/h2&gt;

&lt;p&gt;이번 여행에서 쓴 돈을 정리해 보았습니다. 다만 이번에는 메모를 좀 게을리한 것도 있어서 누락한 금액도 있을 것 같습니다. 대충 참고만 해주시기 바랍니다.&lt;/p&gt;

&lt;h3 id=&quot;krw&quot;&gt;KRW&lt;/h3&gt;

&lt;h4 id=&quot;여행-전&quot;&gt;여행 전&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;항공료 (전일본공수) : 580,200&lt;/li&gt;
  &lt;li&gt;라운지 입장권 : 38,600&lt;/li&gt;
  &lt;li&gt;숙박비 (캡슐 호텔 안신 오야도 신바시 시오도메) : 44,430&lt;/li&gt;
  &lt;li&gt;숙박비 (렘 플러스 긴자) : 578,831&lt;/li&gt;
  &lt;li&gt;숙박비 (라비스타 도쿄베이) : 543,612&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;합계&lt;/strong&gt; : 1,785,673 KRW&lt;/p&gt;

&lt;h3 id=&quot;jpy&quot;&gt;JPY&lt;/h3&gt;

&lt;h4 id=&quot;2023-07-14&quot;&gt;2023-07-14&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;파스모 충전 : 10,000 (사용 후 2천엔 정도 남음)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2023-07-15&quot;&gt;2023-07-15&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;헤어 살롱 메구미 : 1,300&lt;/li&gt;
  &lt;li&gt;도쿠나이 패스 1일권 : 760&lt;/li&gt;
  &lt;li&gt;규동전문 산보 (보통 + 된장국 + 날달걀): 760&lt;/li&gt;
  &lt;li&gt;스타벅스 아이스 아메리카노 (톨 사이즈) : 445&lt;/li&gt;
  &lt;li&gt;렘 플러스 긴자 숙박세 : 600&lt;/li&gt;
  &lt;li&gt;이타마에 스시 (참치 &amp;amp; 연어 세트) : 2,780&lt;/li&gt;
  &lt;li&gt;세븐일레븐 (수플레 푸딩) : 320&lt;/li&gt;
  &lt;li&gt;돈키호테 (휴족시간) : 545&lt;/li&gt;
  &lt;li&gt;이자카야 묘우레이 : 2,800&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2023-07-16&quot;&gt;2023-07-16&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;46ma (카레 정식) : 1,500&lt;/li&gt;
  &lt;li&gt;지하돌 공연 : 3,600&lt;/li&gt;
  &lt;li&gt;지하돌 체키 : 2,000&lt;/li&gt;
  &lt;li&gt;우동 오니얀마 : 590&lt;/li&gt;
  &lt;li&gt;지하돌 공연장 재입장 : 600&lt;/li&gt;
  &lt;li&gt;긴자 300바 : 1,980&lt;/li&gt;
  &lt;li&gt;세븐일레븐 (스트롱제로) : 162&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2023-07-17&quot;&gt;2023-07-17&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;엔가쿠지 입장료 : 500&lt;/li&gt;
  &lt;li&gt;엔가쿠지 오미쿠지 : 200&lt;/li&gt;
  &lt;li&gt;켄쵸지 입장료 : 500&lt;/li&gt;
  &lt;li&gt;와사이 야쿠라 (시라스동) : 1,480&lt;/li&gt;
  &lt;li&gt;스타벅스 아이스 아메리카노 (그란데 사이즈) : 490&lt;/li&gt;
  &lt;li&gt;에노덴 열차 1일권 : 800&lt;/li&gt;
  &lt;li&gt;Dennys (햄버그 + 밥 + 드링크) : 2,090&lt;/li&gt;
  &lt;li&gt;긴자 300바 : 1,980&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2023-07-18&quot;&gt;2023-07-18&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;도쿠나이 패스 1일권 : 760&lt;/li&gt;
  &lt;li&gt;스타벅스 아이스 아메리카노 (톨 사이즈) : 445&lt;/li&gt;
  &lt;li&gt;야키니쿠 규톤 (런치 세트) : 1,100&lt;/li&gt;
  &lt;li&gt;넷카페 3시간 : 500&lt;/li&gt;
  &lt;li&gt;우동 오니얀마 : 520&lt;/li&gt;
  &lt;li&gt;네코 노 오카 : 3,740&lt;/li&gt;
  &lt;li&gt;버레스크 음료 : 1,000&lt;/li&gt;
  &lt;li&gt;택시비 : 2,300&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2023-07-19&quot;&gt;2023-07-19&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;유리카모메 1일권 : 820&lt;/li&gt;
  &lt;li&gt;유나이티드 시네마 도요스 (청춘돼지 영화) : 1,200&lt;/li&gt;
  &lt;li&gt;덴푸라 스시 세트 : 1,628&lt;/li&gt;
  &lt;li&gt;호텔 내 카페 (아이스 커피) : 350&lt;/li&gt;
  &lt;li&gt;라비스타 도쿄베이 숙박세 : 1,000&lt;/li&gt;
  &lt;li&gt;토리타무라 : 4,360&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2023-07-20&quot;&gt;2023-07-20&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;유리카모메 1일권 : 820&lt;/li&gt;
  &lt;li&gt;자판기 음료수 : 160&lt;/li&gt;
  &lt;li&gt;Cafe La Boheim (런치 세트) : 1,300&lt;/li&gt;
  &lt;li&gt;신주쿠교엔 입장료 : 500&lt;/li&gt;
  &lt;li&gt;츠루하시 후케츠 오다이바점 (오코노미야키 + 생맥주) : 1,950&lt;/li&gt;
  &lt;li&gt;이자카야 大露路 : 2,140&lt;/li&gt;
  &lt;li&gt;세븐일레븐 (푸딩) : 374&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2023-07-21&quot;&gt;2023-07-21&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;유리카모메 1일권 : 820&lt;/li&gt;
  &lt;li&gt;스타벅스 아이스 아메리카노 (그란데 사이즈) : 490&lt;/li&gt;
  &lt;li&gt;지로 라멘 : 1,380&lt;/li&gt;
  &lt;li&gt;이자카야 大露路 : 3,130&lt;/li&gt;
  &lt;li&gt;세븐일레븐 (푸딩) : 598&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2023-07-22&quot;&gt;2023-07-22&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;유리카모메 1일권 : 820&lt;/li&gt;
  &lt;li&gt;돈키호테 (면세쇼핑) : 7,342&lt;/li&gt;
  &lt;li&gt;우동 오니얀마 : 520&lt;/li&gt;
  &lt;li&gt;자판기 음료수 : 170&lt;/li&gt;
  &lt;li&gt;네코 노 오카 : 6,160&lt;/li&gt;
  &lt;li&gt;세븐일레븐 (술, 과자) : 575&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;합계&lt;/strong&gt; : 87,754 JPY&lt;/p&gt;

&lt;p&gt;환전 당시 환율 적용 (100엔 = 960원)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;총 합계&lt;/strong&gt; : 2,628,111원 (소수 첫째자리에서 반올림)&lt;/p&gt;

&lt;p&gt;이번 여행은 지난번보다 항공료와 숙소비가 비싸서 총액은 꽤 크게 나왔습니다. 다만 돈 씀씀이는 평균적이었다고 생각합니다. 9박 10일 일정에 9만엔 좀 안썼으니, 1박에 1만엔보다 조금 덜 쓴 정도네요.&lt;/p&gt;

&lt;p&gt;이렇게 도쿄 여행은 끝났지만, 도쿄에서도 못 가본 곳이 많아서 다음에 또 오고 싶습니다. 내년 여름에도 일정이 딱히 없다면 도쿄로 알아봐야겠네요.&lt;/p&gt;

&lt;p&gt;지금까지 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="travel" /><category term="tokyo" /><summary type="html">결국 길었던 도쿄 여행이 끝나고 어느덧 귀국하는 날이 왔습니다.</summary></entry><entry><title type="html">도쿄 여행기 (9)</title><link href="http://localhost:4000/travel/tokyo-9/" rel="alternate" type="text/html" title="도쿄 여행기 (9)" /><published>2023-08-13T00:00:00+09:00</published><updated>2023-08-13T00:00:00+09:00</updated><id>http://localhost:4000/travel/tokyo-9</id><content type="html" xml:base="http://localhost:4000/travel/tokyo-9/">&lt;p&gt;도쿄에서의 9번째 날입니다. 제가 도쿄 여행을 떠나기 전에, LG전자 산학장학생에 지원했었는데, 여행 전주에 갑자기 연락이 오더니 코딩테스트와 인적성 검사가 이날로 통보가 되었습니다. 여행기간 도중이라 혹시 연기가 되는지 문의했더니, 연기는 불가능하다고 해서 어쩔 수 없이 현지에서 응시하기로 했습니다. 그런데 갑자기 코딩테스트는 대상자가 아니라며 취소가 되었고, 인적성 검사만 오후 1시부터 3시까지 실시하게 되었습니다. 굉장히 어중간한 시간이라, 오전에 잠깐 나가서 면세 쇼핑을 하고, 오후에 잠깐 돌아다니다가 하루를 마무리하기로 결정했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/01.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여느 때처럼 아침은 든든하게 먹고 하루 일정을 시작했습니다.&lt;/p&gt;

&lt;h2 id=&quot;돈키호테-긴자본관&quot;&gt;돈키호테 긴자본관&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3241.4032274819824!2d139.75953687712072!3d35.66707213074959!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188be80f065c13%3A0x5f71c9a560322bca!2z64-I7YKk7Zi47YWMIOq4tOyekOuzuOq0gA!5e0!3m2!1sko!2skr!4v1691919890517!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/02.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;내일이 귀국날이다 보니 슬슬 면세 쇼핑을 해야겠다고 생각했습니다. 돈키호테 긴자본관의 위치는 제가 이전에 머물던 렘 플러스 긴자 바로 옆에 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/03.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;돈키호테에서 가장 먼저 찾은건 산토리 가쿠빈입니다. 일본에서는 싸구려 술 느낌이라지만, 한국에서는 재패니즈 위스키를 구하기 쉽지 않을 뿐더러 가격이 비싸서, 일본 여행시 구매해두면 좋습니다. 저 제품이 인기가 많은지 한국어로도 설명이 있었는데, 1인 1병 제한이 있다고 합니다. 가격은 1.92리터에 단돈 5천엔 정도였습니다. 사두고 두고두고 마시면 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;그리고 휴족시간도 좀 많이 사갔습니다. 부모님께서 산책을 자주 하시는데, 선물해드리면 좋을 것 같았습니다.&lt;/p&gt;

&lt;h2 id=&quot;우동-오니얀마-신바시점&quot;&gt;우동 오니얀마 신바시점&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3910.761931569289!2d139.75944382388386!3d35.6671900278495!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188bea3144c0c7%3A0x3a038fe3937f34be!2z7Jqw64-ZIOyYpOuLiOyWgOuniCDsi6DrsJTsi5zsoJA!5e0!3m2!1sko!2skr!4v1691920294326!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/04.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쇼핑이 끝나고 또 우동 오니얀마를 방문했습니다. 벌써 3번째 방문이네요. 냉우동이 진짜 너무 맛있어서 잊을 수가 없더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/05.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 가게는 이렇게 바깥에 있는 자판기에서 원하는 메뉴 티켓을 구매한 다음 음식을 받아가는 구조입니다. 전 역시 520엔짜리 토리 붓카케 냉우동을 구매했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/06.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쫄깃쫄깃한 면발과 바삭한 닭튀김의 조합이 정말 최고입니다. 정말 강력추천드립니다!&lt;/p&gt;

&lt;h2 id=&quot;lg-인적성-검사&quot;&gt;LG 인적성 검사&lt;/h2&gt;

&lt;p&gt;우동을 먹고는 호텔로 돌아가 인적성 검사를 준비했습니다. 적성 검사와 인성 검사를 따로 보는데, 적성 검사는 1과목당 15문제를 풀어야 하는데 시간이 과목당 10분밖에 주어지지 않습니다. 생각보다 시간이 매우 빠듯해서 과목당 3~4문제는 놓친 것 같습니다. 인성 검사는 어려운 것은 아니지만 시간이 촉박해 거의 문제를 읽는 즉시 답을 해야하는 구조였습니다. 저는 나름 열심히 풀었는데, 이틀 후에 바로 탈락했다는 안내를 받았습니다. 이럴거면 그냥 여행에나 집중할껄 하는 생각이 들었네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/07.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/08.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인적성 검사를 하면서 머리를 많이 썼더니 입이 심심해져서 어제 사둔 푸딩을 먹었습니다. 일본 푸딩 너무 맛있어요!&lt;/p&gt;

&lt;h2 id=&quot;다이바&quot;&gt;다이바&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/09.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오다이바에 온 김에, 오다이바에서 유명한 실물 크기 건담 스태츄와 건담베이스를 방문하려고 다이바에 왔습니다. 유리카모메 다이바 역에 내려서 보니 바로 앞에 후지 테레비 건물이 보이네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/10.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반대쪽에는 무슨 행사를 하고 있는지 사람들이 굉장히 많이 몰려있었습니다. 아마 이 날이 토요일이라 그런 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/11.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다이바 시티 프라자 앞으로 가니 실물 크기의 유니콘 건담이 보였습니다. 시간에 맞춰가면 변신하는 장면도 볼 수 있다는데, 저는 시간이 애매해서 그냥 사진만 한 장 남기고 이동했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/12.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다이바 시티 프라자 안에는 일본에서 가장 큰 건담 베이스가 있습니다. 그런데 알고보니 건담 베이스는 한국에 가장 먼저 생겼다고 하네요. 저는 건프라도 꽤 좋아하는 편인데, 한국에서는 요즘 MG 이상 등급의 건프라를 구하는 것이 꽤 어려워서, 기회가 되면 여기서 건프라도 하나 구매해보려고 생각하고 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/13.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;손님이 워낙 많아서인지, 입장을 위한 티켓을 따로 배부하더라구요. 세상에, 물건을 사기 위한 대기도 아니고 단지 가게에 들어가기 위한 대기권입니다. 이런건 또 처음 들어보는 개념이네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/14.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어찌어찌 입장 대기 시간까지 기다리고 나서 건담 베이스에 입장했습니다. 전체적으로 굉장히 잘 꾸며놓았습니다. 입구에는 건프라 콘테스트 입상작들을 전시해 놓았더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/15.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/16.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;안쪽에는 최근 핫한 작품인 수성의 마녀를 전시하고 있었습니다. 큰 사이즈의 건담 에어리얼부터, 수성의 마녀에서 벌어진 사건의 일대기 등등을 정리해두었습니다. 메인 스테이지의 판매 제품들은 대부분 수성의 마녀에 등장한 기체였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/17.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주인공인 슬레타 머큐리가 마지막에 탑승한 건담 캘리번입니다. 마치 마녀의 빗자루를 연상케 하는 무기의 반응이 굉장히 좋았던 것으로 기억합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/18.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/19.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;수성의 마녀에서 명장면들을 실제로 건프라로 표현해둔 모습도 있었습니다. 다만 저는 굉장히 불만족스러웠는데, 막상 판매하고 있는 건프라의 종류는 별 것 없었기 때문입니다. PG는 사실상 거의 전멸이었고 MG 조차도 인기 기체들은 죄다 동나서 살 만한 물건이 하나도 없었습니다. 그 큰 가게에 판매하고 있는 건프라의 종류가, 한국 온라인몰보다도 적었습니다. 이런거 전시해둘 시간에 물량이나 확보좀 하지… 라는 생각이 들었습니다.&lt;/p&gt;

&lt;h2 id=&quot;신바시-역&quot;&gt;신바시 역&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/20.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;건담 베이스를 본 후, 신바시 역으로 돌아왔습니다. JR을 타러 가던 중에 요요 공연을 하던 사람을 봤습니다. 신기한 묘기를 많이 보여줘서 한동안 넋놓고 봤네요.&lt;/p&gt;

&lt;h2 id=&quot;네코-노-오카&quot;&gt;네코 노 오카&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3239.7434235551345!2d139.66296587712188!3d35.70793102850467!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6018f290d2e10001%3A0xf7c8a5253d2ef6fa!2sNeko_no_Oka!5e0!3m2!1sko!2skr!4v1691303931629!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/21.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도쿄에서의 마지막 밤에는 5일차에 방문했던 네코 노 오카에 다시 방문했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/22.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 날은 메이드 카페 하면 떠오르는 오므라이스를 주문해봤습니다. 메이드들이 바에서 직접 만들어주는 모습을 봤는데, 밥은 레토르트 제품을 전자레인지에 데워서 만들고, 계란은 직접 그 자리에서 부치더라구요. 맛은 그저 그랬습니다. 메이드들도 오랜만에 만들어보는지, 허둥대며 만드는  과정을 지켜보는게 재밌긴 했네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/23.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지난번에 왔을 때 시켰던 일본주를 또 시켜봤습니다. 맛은 청하랑 거의 비슷한데, 술이 약한지 취기가 안올라와서 조금 별로였네요. 메이드들이 저보고 술 잘마신다고 하더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/24.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;근무하던 메이드 중 한명이 식사를 안하고 왔는지 계속 오이를 꺼내 먹더라구요. 근데 전 오이를 이렇게 자르지도 않고 씹어먹는게 신기해서 사진 좀 찍어도 괜찮냐고 물어보고 사진을 찍어봤습니다. 일본에서는 이렇게 오이를 먹는게 일반적인건가 궁금하더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/015/25.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;네코 노 오카에서 몇 잔을 마셨지만, 술이 하나같이 너무 약해서 취기가 너무 안올라오더라구요. 그래서 호텔에 돌아오는 길에 편의점에 들러 간단한 안주와 스트롱제로를 구매했습니다. 역시 스트롱제로는 마시니까 바로 취기가 올라오네요. 도쿄에서의 마지막 밤을 술과 함께 즐기며 하루를 마무리했습니다.&lt;/p&gt;

&lt;p&gt;9일차 일정은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="travel" /><category term="tokyo" /><summary type="html">도쿄에서의 9번째 날입니다. 제가 도쿄 여행을 떠나기 전에, LG전자 산학장학생에 지원했었는데, 여행 전주에 갑자기 연락이 오더니 코딩테스트와 인적성 검사가 이날로 통보가 되었습니다. 여행기간 도중이라 혹시 연기가 되는지 문의했더니, 연기는 불가능하다고 해서 어쩔 수 없이 현지에서 응시하기로 했습니다. 그런데 갑자기 코딩테스트는 대상자가 아니라며 취소가 되었고, 인적성 검사만 오후 1시부터 3시까지 실시하게 되었습니다. 굉장히 어중간한 시간이라, 오전에 잠깐 나가서 면세 쇼핑을 하고, 오후에 잠깐 돌아다니다가 하루를 마무리하기로 결정했습니다.</summary></entry><entry><title type="html">도쿄 여행기 (8)</title><link href="http://localhost:4000/travel/tokyo-8/" rel="alternate" type="text/html" title="도쿄 여행기 (8)" /><published>2023-08-12T00:00:00+09:00</published><updated>2023-08-12T00:00:00+09:00</updated><id>http://localhost:4000/travel/tokyo-8</id><content type="html" xml:base="http://localhost:4000/travel/tokyo-8/">&lt;p&gt;도쿄에서의 여덟번째 날입니다. 이 날부터는 슬슬 피로가 쌓여 돌아다니기가 귀찮아지기 시작했습니다. 그래서 가고 싶은 곳을 최소로만 방문하고, 그 외에는 호텔에서 시원한 에어콘을 쐬며 쉬었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/01.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역시 호텔 조식을 먹으면서 하루를 시작했습니다. 뽕을 뽑기 위해 회 위주로 반찬을 집어왔습니다. 연어알은 처음 먹어봐서 밥 위에 잔뜩 얹어왔는데, 생각보다 금방 물리더라구요.&lt;/p&gt;

&lt;h2 id=&quot;도요스-시장&quot;&gt;도요스 시장&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d12967.795852761592!2d139.7667489316745!3d35.65362904714766!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6018898de24f1911%3A0x6ab786a75d8ff16b!2z64-E7JqU7IqkIOyImOyCsOyLnOyepQ!5e0!3m2!1sko!2skr!4v1691846151512!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;제가 묵던 호텔은 시조마에라는 역 앞이었습니다. 시조마에는 한국어로 번역하면 “시장 앞”이라는 뜻인데, 여기서 말하는 시장이 바로 도요스 시장입니다. 도요스 시장은 수산물 시장으로 유명한데, 그래서 한번 구경해보기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/02.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시장이 개업하는 날에는 시조마에 역 앞에 이렇게 시장개업일이라는 안내가 붙습니다. 견학은 오전 5시부터 오후 5시까지 가능하다고 나와있어서 저는 아침을 먹고 천천히 가봤는데, 상인들이 직접 수산물을 경매하는 장면을 보려면 오전 5시에 칼같이 가야하더라구요. 그걸 미리 알았으면 일찍 갔을텐데, 조금 아쉬웠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/03.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도요스 시장은 시조마에 역 앞에서 보일 정도로 가깝습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/04.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도요스 시장에 입장하면 두 갈래 길이 있습니다. 왼쪽이 관광객용 코스이고, 오른쪽이 시장 관계자를 위한 길입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/05.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;관광객용 코스에 입장하면 커다란 참치 모형이 눈에 들어옵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/06.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/07.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러고 나서는 위에서 시장을 내려다 볼 수 있는데… 오전 10시쯤 되는 시간이다보니 상인들은 아무도 없고 그냥 휑한 시장터만 남아 있습니다. 사진을 딱 두장 찍어놨는데, 정말 이 두 장이 관광객용 코스의 전부입니다. 시장이 열리는 시간이 아니면 솔직히 올만한 가치가 딱히 없어보입니다. 시장 개장에 맞춰 방문한 모습은 &lt;a href=&quot;https://gall.dcinside.com/dcbest/154575&quot;&gt;이 글&lt;/a&gt;을 참고해주시기 바랍니다.&lt;/p&gt;

&lt;h2 id=&quot;도쿄-빅사이트&quot;&gt;도쿄 빅사이트&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3242.820744398902!2d139.79285038821178!3d35.63214537212531!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x601889dc629d1e7b%3A0xa4d1509a76045a01!2z64-E7L-E67mF7IKs7J207Yq4ICjrj4Tsv4Tqta3soJzsoITsi5zsnqUp!5e0!3m2!1sko!2skr!4v1691846172103!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/08.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 방문한 곳은 도쿄 빅사이트입니다. 정식 명칭은 도쿄 국제전시장이라고 하는데, 딱히 목적이 있다기 보다는 나름 오다이바의 관광지로 소개된 곳이길래 찾아가보기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/09.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도쿄 빅사이트는 유리카모메 도쿄 빅사이트 역 바로 앞에 있습니다. 가까이서 보니 생각보다 엄청 큰 건물이네요. 일본에서 유명한 행사 중 하나인 코미케가 여기서 열린다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/10.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 방문했을 당시 도쿄 빅사이트 내부는 그냥 63빌딩처럼 비즈니스맨들만 잔뜩 보였습니다. 무슨 행사가 있긴 한 것 같은데, 오타쿠를 위한 행사라기 보단 그냥 학회 같은 행사인 것 같았습니다. 기념품을 파는 곳이 있긴 했는데 딱히 사고싶은 것은 없어서 대충 둘러보고 도쿄 빅사이트 안에 있던 스타벅스에서 아이스 아메리카노나 한잔 마셨습니다.&lt;/p&gt;

&lt;h2 id=&quot;야로-라멘&quot;&gt;야로 라멘&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3240.051374012459!2d139.76582676172265!3d35.70035336802408!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188c1c353734cd%3A0xd0324bf62d4cf56d!2sYar%C5%8D%20Ramen!5e0!3m2!1sko!2skr!4v1691846512808!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/11.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도쿄 빅사이트를 구경하고 나니 슬슬 점심시간이 다가왔습니다. 뭘 먹을까 하다가, 생각해보니 아키하바라에 있는 야로 라멘에서 청춘 돼지 콜라보 이벤트를 한다고 들었기 때문에, 방문해보기로 했습니다. 이번 여행에서 청춘 돼지 관련 컨텐츠를 정말 많이 즐기는 것 같네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/12.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가게 입구부터 내부까지 청춘 돼지 관련 굿즈로 가득 차 있었습니다. 청춘 돼지 시리즈를 좋아하시는 분이라면 한번 방문해보시는 것도 괜찮아 보입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/13.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;라멘의 가격은 보통 사이즈 기준으로 1380엔이었습니다. 다만 맛은 별로… 일본에서 라멘을 많이 먹어본 것은 아니지만, 먹을때마다 하나같이 너무 짜다는 생각이 들었습니다. 제가 나름 한국에서도 짜게 먹는 편인데도 그러네요. 호텔에서 주던 라멘처럼 소금을 별도로 제공했으면 좋았을텐데 말입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/14.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;라멘을 먹고 나면 기념으로 청춘 돼지 콜라보 굿즈를 줍니다. 엽서 사이즈의 포스터인데, 제가 외국인이라 그런지 한 장을 더 주더라구요.&lt;/p&gt;

&lt;p&gt;점심을 먹고 난 뒤에는 호텔에서 쭉 쉬었습니다. 도쿄에 머무는 동안 계속 돌아다니기도 했고, 날씨가 덥다보니 너무 지쳐있었습니다. 낮잠도 자고, 수영도 하면서 저녁까지 시간을 보냈습니다.&lt;/p&gt;

&lt;h2 id=&quot;大露路&quot;&gt;大露路&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3241.453886647589!2d139.7532589771209!3d35.66582443081811!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188bebb336bce1%3A0xaaa0a67b49e31e91!2z6YWS5YemIOWRs-WHpiDlpKfpnLLot68!5e0!3m2!1sko!2skr!4v1691761169454!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/15.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저녁이 되자 다시 배가 고팠기 때문에 식사 겸 술을 한잔 하려고 나왔습니다. 어디를 갈까 하다가 어제 갔던 이자카야가 마음에 들어서 재방문했습니다. 구글 지도 상으로 6시 30분이 오픈시간이었는데, 제가 거의 오픈 시간 직후에 갔음에도 불구하고 사람이 가득 차 있었습니다. 현지인에게 인기가 많은 곳인가 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/16.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 날은 츄하이를 한번 시켜봤습니다. 저는 지난번에 마셨던 스트롱제로 같은 맛을 기대했는데, 그거보다는 약한 맛이었습니다. 제 입맛에는 스트롱제로가 더 나은 것 같네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/17.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;안주는 지난번에 시켰던 시샤모를 또 시켰습니다. 술 안주로 정말 좋더라구요. 양이 좀 부족한게 흠이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/18.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 시킨 것은 주인분께 추천받은 회무침인데, 맛있긴 했으나 이것도 양이 조금 애매했습니다. 저녁도 안먹은 상태라 더 배고팠어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/19.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그래서 어제 시켰던 두부고기를 또 시켰습니다. 맛도 맛있지만 양이 푸짐해서 마음에 드네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/014/20.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;술을 마시다가 옆에 앉은 직장인 분과 잠깐 이야기를 했는데, 그 분이 한번 먹어보라고 햄카츠를 한조각 주셨습니다. 맛있게 먹고 감사하다고 말씀드렸습니다.&lt;/p&gt;

&lt;p&gt;두 시간 정도 마시다가 숙소로 돌아와 쉬었습니다. 라멘을 먹으러갈까 하다가 배도 부르고 귀찮아서 그냥 씻고 잤네요.&lt;/p&gt;

&lt;p&gt;8일차 일정은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="travel" /><category term="tokyo" /><summary type="html">도쿄에서의 여덟번째 날입니다. 이 날부터는 슬슬 피로가 쌓여 돌아다니기가 귀찮아지기 시작했습니다. 그래서 가고 싶은 곳을 최소로만 방문하고, 그 외에는 호텔에서 시원한 에어콘을 쐬며 쉬었습니다.</summary></entry><entry><title type="html">도쿄 여행기 (7)</title><link href="http://localhost:4000/travel/tokyo-7/" rel="alternate" type="text/html" title="도쿄 여행기 (7)" /><published>2023-08-11T00:00:00+09:00</published><updated>2023-08-11T00:00:00+09:00</updated><id>http://localhost:4000/travel/tokyo-7</id><content type="html" xml:base="http://localhost:4000/travel/tokyo-7/">&lt;p&gt;도쿄에서의 일곱째날 아침입니다. 새로 옮긴 호텔에서의 조식이 정말 맛있다고 소문이 자자한 상태였기 때문에 잔뜩 기대를 하고 식당으로 내려갔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/01.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;엘리베이터 안에서 찍은 풍경인데, 바다가 보여서 경치가 꽤 괜찮네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/02.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;식당으로 가니 듣던대로 굉장히 훌륭했습니다. 식당의 크기도 매우 컸는데, 다른 호텔에서 볼 수 없는 각종 회가 즐비하게 놓여있는 것이 굉장했습니다. 이 정도 퀄리티면 점심이나 저녁으로 먹어도 훌륭하다는 생각이 드네요. 세 끼를 전부 이걸로 먹어도 좋겠다는 생각이 들 정도였습니다.&lt;/p&gt;

&lt;h2 id=&quot;죠치대학&quot;&gt;죠치대학&lt;/h2&gt;

&lt;p&gt;오늘의 일정은 죠치대학을 기점으로 그 근처의 명소를 탐방하는 것이었습니다. 뜬금없이 죠치대학을 왜 방문하는지 궁금하신 분들도 있으실텐데, 죠치대학은 제 모교인 서강대학교와 같은 예수회 재단의 학교로써 교류가 많았기 때문입니다. 예전에는 연고전 같은 체육대회도 열었는데, 어느 순간부터 없어져버렸더라구요. 여튼, 말로만 듣던 죠치대학이 어떤 곳일까 궁금해서 한번 방문해보기로 했습니다.&lt;/p&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d25931.65950401819!2d139.7424076976799!3d35.665736962008026!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e3!4m5!1s0x601889284cb62b09%3A0x373d48d832ff842!2z7J2867O4IFRva3lvLCBLb3RvIENpdHksIFRveW9zdSwgNi1jaMWNbWXiiJI04oiSNDAg652867mE7Iqk7YOAIOuPhOy_hOuyoOydtA!3m2!1d35.6466503!2d139.78400879999998!4m5!1s0x60188c629eb7437b%3A0xd59d9eba882319b6!2z7KGw7LmYIOuMgO2VmSA3LTEgS2lvaWNobywgQ2hpeW9kYSBDaXR5LCBUb2t5byAxMDItODU1NCDsnbzrs7g!3m2!1d35.6831167!2d139.7319235!5e0!3m2!1sko!2skr!4v1691736917041!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;죠치대학은 숙소인 시조마에 역에서 꽤 먼 곳에 있었습니다. 다만 도요스 역까지만 가면 그 곳에서 죠치대학 근처까지 한 번에 가는 노선이 있었기 때문에 그걸 이용하기로 했습니다. 그래도 거리가 꽤 멀어서 40분이 넘게 걸리더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/03.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조치대학이 있는 고지마치 역입니다. 역 자체는 매우 아담하네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/04.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;구글 지도를 보며 따라가다보니 금방 죠치대학의 입구가 나왔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/05.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;입구가 조금 작은데, 이게 정문이 아니라 동문이기 때문에 그렇습니다. 그런데 입구 옆의 캠퍼스 지도를 보니 학교 자체도 매우 작아 보였습니다. 제가 다닌 서강대학교도 캠퍼스 크기가 작은 걸로 유명한데, 여기는 그보다도 훨씬 작아보입니다. 어느 정도냐면, 동문에서 육안으로 서문이 보일 정도입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/06.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;캠퍼스 분위기가 딱히 축제 같지도 않은데 푸드트럭이 몇 개 보였습니다. 일본에서는 교내에 푸드트럭이 있는게 자연스러운 걸까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/07.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/08.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;교내에 있던 프란시스코 하비에르의 동상입니다. 제가 이 분은 잘 모르지만, 저희 학교에 하비에르 관(X관)이라는 건물이 있었기 때문에 종종 들어본 이름이라 뭔가 반가운 느낌이 났습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/09.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;교내 캠퍼스의 분위기는 나쁘지 않았지만, 건물이 대부분 오래되어 보였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/10.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이건 캠퍼스 주차장 쪽에 있던 액화질소 보관함인데… 위험한 물질은 아니지만 그래도 화학물질인데 이렇게 길에 대놓고 보관하고 있는게 좀 놀라웠습니다. 보통 이건 연구실에서 따로 보관하지 않나요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/11.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기숙사로 보이는 건물 앞에는 이렇게 재학생들이 쉴 수 있는 공간이 만들어져 있었습니다. 외국인들이 이런 쉼터를 좋아하는지, 일본 학생보다는 외국인 학생들이 많이 보이더라구요. 일본 학생들은 주로 도서관이나 카페에서 공부를 하고 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/12.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;날씨가 덥다보니 저도 좀 쉬었다 가려고 자판기에서 음료수를 한잔 뽑았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/13.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;벤치에 앉아서 쉬다보니 웬 도마뱀이 하나 지나가더라구요. 뭔지는 모르겠지만 신기해서 찍어봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/14.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조금 쉬다가 다른 곳으로 이동하기 위해 정문으로 나가기로 했습니다. 학교 정문 방향을 보면서 한 컷 찍어봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/15.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;건물이 옹기종기 밀집해 있는걸 보니 저희 학교가 떠오르네요. 그런데 이렇게 작은 학교에 재학생이 저희 학교보다 5천명이나 많다니 놀라울 따름입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/16.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정문 근처로 가니 졸업식 관련 홍보문이 보였습니다. 제가 보기엔 졸업식에 입을 전통 의상을 대여한다는 광고로 보입니다. 한국에서는 보통 졸업식 때 검은색 졸업 가운을 입는데, 일본에서는 이렇게 전통 의상을 입고 하나보네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/17.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여담으로 일본에서는 이 학교가 죠치대학이지만, 영문 표기로는 소피아 대학교입니다. 대체 어쩌다가 죠치대학이라고 이름이 붙었나 찾아보니, 천주교에서 사용하는 Sapientiae라는 단어를 한자로 上智라고 번역했기 때문이 이렇게 이름이 붙었다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/18.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 다니고 있는 서강대학교는 천주교 재단 학교라 건물 이름이 전부 천주교 성인의 이름을 따서 지어졌는데, 여긴 천주교 학교라도 그런게 딱히 없는 것 같네요. 이 건물은 그냥 7호관이라는 평범한 이름이 붙었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/19.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정문은 다른 문에 비해 상당히 큰 모습이었습니다. 정문 옆에는 이렇게 SOPHIA UNIVERSITY라고 새겨져 있네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/20.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정문 바깥에서 정문을 바라보며 한 컷 찍어봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/21.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정문 바깥에서 보이는 건물에는 한자로 죠치대학이라고 적혀있었습니다. 학교 이름이 걸린 것으로 보아 학교를 상징하는 건물인 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;스가-신사&quot;&gt;스가 신사&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d3240.6665227004864!2d139.724625976423!3d35.68521237975418!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x60188c629eb7437b%3A0xd59d9eba882319b6!2z7KGw7LmYIOuMgO2VmSA3LTEgS2lvaWNobywgQ2hpeW9kYSBDaXR5LCBUb2t5byAxMDItODU1NCDsnbzrs7g!3m2!1d35.6831167!2d139.7319235!4m5!1s0x6018ece406d552f1%3A0x440be600a9c6807c!2z7J2867O4IOuPhOy_hOuPhCDsi6Dso7zsv6Dqtawg7Iqk6rCA7LSIIO-8lSDsiqTqsIAg7Iug7IKs!3m2!1d35.6852851!2d139.7224783!5e0!3m2!1sko!2skr!4v1691740916296!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;다음은 너의 이름은 계단으로 유명한 스가 신사를 보러 가기로 했습니다. 죠치대학에서 멀지 않은 곳에 있었기 때문에 도보로 이동했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/22.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주변 경치를 구경하며 가다보니 저 멀리 스가 신사 계단이 보입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/23.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이곳이 바로 너의 이름은 마지막에 나오는 계단입니다. 워낙 유명한 장소라 그런지, 오전 시간에도 관광객이 꽤 있었습니다. 영화가 개봉한지 오래 지났는데도 여전히 인기가 많네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/24.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;계단 위로 올라가보니 신사 입구가 보였습니다. 크기는 사진상으로 보이는 건물이 전부일 정도로 그다지 크지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/25.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;너의 이름은 계단 말고도 스가 신사로 통하는 계단이 또 있더라구요. 영화에서는 미츠하가 내려가고 타키가 올라가는 모습으로 나왔었는데, 아마 미츠하가 이 곳으로 올라왔다가 그쪽으로 내려간게 아닐까 하는 생각이 듭니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/26.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;신사하면 또 오미쿠지가 빠질 수 없지요. 저는 또 사기에는 아까워서 이번에는 그냥 넘겼습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/27.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;본당 내부의 모습인데, 겉모습과는 다르게 꽤 화려합니다. 관리가 잘 되어 있다는 느낌을 받았어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/28.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;본당 옆에는 나무조각이 걸려있었는데, 이 나무조각은 에마(絵馬)라고 불리며 이루고싶은 소원을 적어 놓는 것이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/29.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;에마를 구경하다가 뜬금없이 블리치를 봤습니다. 나중에 알아보니 최근 방영하고 있는 천년혈전 애니메이션 감독인 타구치 토모히사가 남긴 에마였습니다. 저는 블리치를 굉장히 좋아하는데, 천년혈전 편 애니가 감독의 소망대로 잘 나왔으면 좋겠네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/30.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스가 신사는 천천히 둘러봐도 20분 정도면 충분했습니다. 조금 쉬다가, 다음 장소로 이동했습니다.&lt;/p&gt;

&lt;h2 id=&quot;한국-문화원&quot;&gt;한국 문화원&lt;/h2&gt;

&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d1620.3163530312747!2d139.7187345889422!3d35.686044871706606!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x6018ece406d552f1%3A0x440be600a9c6807c!2z7J2867O4IOuPhOy_hOuPhCDsi6Dso7zsv6Dqtawg7Iqk6rCA7LSIIO-8lSDsiqTqsIAg7Iug7IKs!3m2!1d35.6852851!2d139.7224783!4m5!1s0x60188cec7cdd1a75%3A0xe6721409bb32d460!2z7J2867O4IOuPhOy_hOuPhCDsi6Dso7zsv6Dqtawg7JqU7JOw7JW8IDQg7KGw66mU4oiSNOKIkjEwIOyjvOydvOuMgO2VnOuvvOq1reuMgOyCrOq0gCDtlZzqta3rrLjtmZTsm5A!3m2!1d35.687252!2d139.71722699999998!5e0!3m2!1sko!2skr!4v1691744271215!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;다음 목적지는 한국 문화원입니다. 주일한국 대사관에서는 일본에서 한국 문화를 알리기 위해 한국 문화원을 운영한다고 하는데, 과연 어떻게 운영되고 있는지 궁금해서 한번 방문해봤습니다. 한국 문화원은 스가 신사에서 도보로 갈 수 있을 만큼 가까운 거리에 위치해 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/31.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한국 문화원의 입구입니다. 저는 아기자기한 건물로 생각하고 있었는데, 생각보다 큰 건물이어서 놀랐습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/32.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;입구 옆에는 한국 정부의 상징과 함께 한국어로 한국 문화원이라는 글이 적혀있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/33.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;옆에는 한국 문화를 소개하는 영상이 흘러나오는 TV가 진열되어 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/34.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한국 문화원은 8층까지 있었습니다. 각 층이 전부 방문해보고 싶었긴 했는데, 6 ~ 8층은 당시 입장이 불가능했고, 5층과 2층도 행사가 없는 날에는 운영되지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/35.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/36.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1층에 있는 갤러리에는 한국의 문화제 복제품들과 미술 작품들이 전시되어 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/37.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4층에 사랑방에는 조선 시대 느낌의 방이 있었습니다. 나름 잘 묘사해둔 것 같네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/38.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/39.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사랑방 옆에는 바깥으로 나갈 수 있는 문이 있었는데, 밖으로 나가니 한국식 정원이 나와있었습니다. 생각보다 잘 꾸며놨더라구요. 여기서 장독대를 볼 줄은 몰랐습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/40.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3층의 도서관에서는 한국 도서들이 다수 있었습니다. 옛날 도서 뿐만 아니라 최근에 발매된 도서들도 다수 소장되어 있었고, 한국어 교재들도 있었습니다. 다른 곳에서는 사람들을 못봤는데, 여긴 이용하고 있는 사람들이 꽤 보였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/41.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도서관에 온 김에 휴식할 겸 보이는 책 중 하나를 잠깐 읽었습니다. 신오쿠보역에서 취객을 구하다 사망하신 이수현 씨에 대한 이야기였는데, 다 읽지는 못했지만 그 분의 행적을 구체적으로 알 수 있어서 흥미롭게 읽었습니다. 한국에 돌아가게 되면 책을 구해서 끝까지 읽어봐야겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/42.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한국 문화원에는 (당연하겠지만) 한국인 직원들이 근무하고 있었습니다. 직원들끼리 얘기할 때는 한국어를 사용했는데 제가 엘리베이터에 같이 타니 일본인인줄 알고 일본어로 말을 걸더라구요.&lt;/p&gt;

&lt;h2 id=&quot;cafe-la-boheme&quot;&gt;Cafe La Boheme&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d1620.2930886886522!2d139.71347393860893!3d35.687190279041516!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x60188cec7cdd1a75%3A0xe6721409bb32d460!2z7J2867O4IOuPhOy_hOuPhCDsi6Dso7zsv6Dqtawg7JqU7JOw7JW8IDQg7KGw66mU4oiSNOKIkjEwIOyjvOydvOuMgO2VnOuvvOq1reuMgOyCrOq0gCDtlZzqta3rrLjtmZTsm5A!3m2!1d35.687252!2d139.71722699999998!4m5!1s0x60188cea1ff82e8f%3A0xc4f768329b5ee283!2sCafe%20La%20Boheme!3m2!1d35.6875891!2d139.7128716!5e0!3m2!1sko!2skr!4v1691746301023!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/43.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한국 문화원까지 둘러보고 나니 점심시간이 다되서 점심을 먹으러 갔습니다. 이번에 방문한 곳은 “너의 이름은”의 주인공인 타키가 일하고 있던 레스토랑인 Cafe La Boheme입니다. 한국 문화원에서 가까운 위치에 있었기 때문에 걸어갔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/44.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;대기가 조금 있었지만, 금방금방 자리가 빠졌기 때문에 곧 안내를 받았습니다. 저같은 외국인 관광객이 많이 오는지, 직원들의 영어가 아주 능숙하더라구요. 점심용 메뉴판이 따로 있었는데, 저는 Monthly Special 파스타를 포함한 B세트로 주문했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/45.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 에피타이저로 스프와 빵, 샐러드가 나왔습니다. 평소에 샐러드를 즐겨먹는 편은 아닌데, 레스토랑 분위기 때문인지 맛있게 느껴지더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/46.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Monthly Special 파스타는 솔직히 좀 실망했습니다. 멸치와 고추가 들어있는 파스타였는데, 맵기만 하고 영… 그냥 차라리 무난한 까르보나라 같은걸 주문할걸 그랬어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/47.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가격은 1300엔으로 그렇게 비싸지 않습니다. “너의 이름은”을 재밌게 본 분이면 한 번 쯤 방문해보시는 것도 괜찮을 것 같아요.&lt;/p&gt;

&lt;h2 id=&quot;신주쿠-교엔&quot;&gt;신주쿠 교엔&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3240.6678124029454!2d139.7074767764229!3d35.685180629755976!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188cc21b93233f%3A0x6a1eb1b5a117f287!2z7Iug7KO87L-gIOq1kOyXlA!5e0!3m2!1sko!2skr!4v1691746742872!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/48.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 방문한 곳은 신주쿠 교엔입니다. 신주쿠 교엔은 점심식사를 했던 Cafe La Boheme 바로 앞에 있습니다. 도쿄에서 가장 유명한 공원이고, “언어의 정원”의 성지이기 때문에 겸사겸사 들렀습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/49.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;신주쿠 교엔은 꽤 이른시간인 오후 5시 ~ 6시에 문을 닫기 때문에 방문하시려면 일찍 가시는 것이 좋습니다. 심지어 10월부터 3월 14일까지는 오후 4시에 닫네요. 입장료도 있는데, 성인 500엔, 학생 250엔입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/50.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 입장한 곳은 오키도 문이었습니다. 정문이 아니어서 그런지 입구가 조금 작네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/51.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀리 고층 빌딩이 보이는데 무슨 건물인지는 모르겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/52.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/53.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;신주쿠 교엔의 풍경은 정말 기대 이상이었습니다. 일본에서 입장료를 내고 들어갔던 곳들은 솔직히 돈이 좀 아까운 면이 없잖아 있었는데, 여긴 입장료 내고도 들어올만하다 라는 느낌이 들었습니다. 솔직히 켄조지 같은 곳에 500엔 내고 들어가느니 그 돈으로 신주쿠 교엔에 오는게 훨씬 낫겠다고 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/54.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;처음에 이 정자가 언어의 정원에 나오는 정자인줄 알았는데, 알고보니 아니더라구요. 그래도 여기 앉아서 호수를 바라보면 경치가 괜찮았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/55.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호수 한가운데 조그마한 섬 같은게 있고, 거기에 소나무가 자란 모습이 낭만있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/56.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호수는 생각보다 넓었습니다. 물고기가 있었던 것 같기도 한데… 기억이 잘 안나네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/57.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어떤 나무에는 거미줄이 잔뜩 쳐져있던데 조금 징그러웠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/58.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기가 바로 언어의 정원에 나오는 정자입니다. 두 주인공이 비가 오면 항상 이곳에서 만났던 곳이었죠.&lt;/p&gt;

&lt;p&gt;영화 이후로 방문객이 많아지자 출입금지가 되었다고 들었는데, 제가 갔을 때는 앉아볼 수도 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/59.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/60.png&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;언어의 정원으로 유명한 정자이다보니 사진을 찍으려는 관광객이 많았습니다. 느긋하게 앉아서 주변을 감상하고 싶었는데, 민폐가 될까봐 얼른 사진 찍고 다른 곳으로 이동했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/61.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/62.png&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;후반부에 주인공 두 명이 호수를 바라보던 곳도 찍어봤습니다. 저 왼쪽에 있는 건물도 실제로 있었는데, 사진으로 남기진 못했네요. 사실 내부는 별 거 없었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/63.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/64.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;신주쿠 교엔도 어느정도 다 보고, 호텔로 돌아가 쉬기로 했습니다. 언어의 정원 성지에서 가장 가까운 역은 센다가야 역이었는데, JR과 지하철이 모두 다니기 때문에 편한 걸로 타시면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;호텔-수영장&quot;&gt;호텔 수영장&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/65.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;숙박하던 호텔에서는 원래 수영장이 유료라고 합니다. 다만 이벤트로 7월에는 오후 3시 ~ 6시 사이에 무료로 개장한다고 해서 방문해 봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/66.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/67.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이럴 줄 알고 수영복을 챙겨왔습니다만, 생각보다 수영장이 크지 않았습니다. 호텔 크기에 비해 많이 작아서 실망스럽네요. 돈 내고 들어왔으면 정말 아까웠을뻔 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;츠루하시-후게츠-오다이바점&quot;&gt;츠루하시 후게츠 오다이바점&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d9859.460921740781!2d139.77442726612577!3d35.627002916971854!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x601889f63b3df157%3A0x289b14d0a66ecd1c!2z7Lig66Oo7ZWY7IucIO2bhOqyjOy4oCDsmKTri6TsnbTrsJTsoJA!5e0!3m2!1sko!2skr!4v1691761455637!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/68.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;수영을 좀 즐기고 방에서 쉬다가, 배가 고파져서 저녁을 먹으러 갔습니다. 뭘 먹을까 하다가 신바시로 가는 길에 오코노미야키 가게가 있길래 거길 방문해봤습니다. 구글 평점이 나쁘지는 않았는데, 가게 입구에서 한국어를 보니 뭔가 외국인용 가게같은 느낌이 들어서 망설여졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/69.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/70.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그래도 여기까지 왔는데 다른데 가기는 귀찮아서 그냥 들어가기로 했습니다. 메뉴판을 보니 오코노미야키 하나에 1400~1600엔 정도였습니다. 이걸 맥주랑 안먹으면 섭섭하니 맥주까지 하나 시켰는데, 이렇게만 시켜도 2천엔입니다. 생각보다 값이 꽤 나가네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/71.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주문한지 얼마 지나지 않아 직원이 오코노미야키 재료가 들은 그릇을 부어서 불판에 올려줬습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/72.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아무래도 이걸 처음 먹어보는 사람은 어떻게 조리해야하는지 모를 수 있기 때문에 직원이 처음부터 끝까지 전부 조리해준다고 합니다. 얼마나 걸리냐고 물어보니 앞판 10분/뒷판 10분씩 익혀야 한다고 하네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/73.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/74.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/75.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;20분 정도 지나니 드디어 먹을 수 있는 상태가 되었습니다. 소스까지 직원이 다 뿌려줘서 먹기만 하면 되네요. 맛은 나쁘진 않았으나 양이 살짝 부족했습니다. 2명이서 3판을 시키면 배부르게 먹을 수 있을 것 같네요. 다만 가성비는 별로 좋아보이진 않습니다.&lt;/p&gt;

&lt;h2 id=&quot;大露路&quot;&gt;大露路&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3241.453886647589!2d139.7532589771209!3d35.66582443081811!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188bebb336bce1%3A0xaaa0a67b49e31e91!2z6YWS5YemIOWRs-WHpiDlpKfpnLLot68!5e0!3m2!1sko!2skr!4v1691761169454!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/76.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;밥도 먹었으니 또 이자카야에 가서 한잔 하기로 했습니다. 신바시에 널린게 이자카야기 때문에 어디를 갈까 고민하다가, 시샤모를 먹고 싶어서 구글 지도에 시샤모를 치고 가장 가까운 가게로 갔습니다. 가게 이름은 어떻게 읽어야할지 모르겠습니다. 후기를 보니 가격이 저렴하고 혼자 방문해도 좋다고 하니 제게 딱인 것 같았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/77.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가게 입구인데, 가게가 상당히 작습니다. 많아봤자 15명 정도 들어갈 수 있는 크기 같습니다. 그러다보니 서로서로 합석해야하는 경우가 많습니다. 사실 이런 가게를 기대해서 일본 사람과 이야기할 기회가 있을까 기대했는데, 각자 자기 술마시고 핸드폰 보느라 바빠서 이야기는 서로 안하더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/78.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 먼저 시샤모를 주문했습니다. 일본식 가정식을 보면 시샤모가 굉장히 자주 보이는데, 막상 한국에는 없는 물고기라서 어떤 맛인지 정말 궁금했습니다. 시샤모는 크기가 작아서 머리부터 꼬리까지 그냥 다 먹는다는데, 그래서 그런지 찍어먹을 수 있게 마요네즈도 같이 나왔습니다. 맛은 정말 맛있었습니다. 한국에도 있었다면 자주 먹었을 것 같은데, 아쉽네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/79.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시샤모를 먹고 나서 뭘 주문할까 하다가 고기두부를 주문했습니다. 원래 고기감자(니쿠쟈가)를 먹고 싶었는데, 이 가게에는 없다고 해서 대신 이걸 주문했습니다. 가격이 300엔인가로 기억하는데 생각보다 양이 많았습니다. 저는 맥주랑 같이 먹긴 했는데, 소주랑 같이 먹어도 맛있을 것 같네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/013/80.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호텔로 돌아와서는 또 야식으로 무료 라멘을 먹고 잤습니다. 이건 진짜 돈받고 팔아도 팔릴만한 맛이네요.&lt;/p&gt;

&lt;p&gt;7일차 일정은 이렇게 끝났습니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="travel" /><category term="tokyo" /><summary type="html">도쿄에서의 일곱째날 아침입니다. 새로 옮긴 호텔에서의 조식이 정말 맛있다고 소문이 자자한 상태였기 때문에 잔뜩 기대를 하고 식당으로 내려갔습니다.</summary></entry><entry><title type="html">도쿄 여행기 (6)</title><link href="http://localhost:4000/travel/tokyo-6/" rel="alternate" type="text/html" title="도쿄 여행기 (6)" /><published>2023-08-10T00:00:00+09:00</published><updated>2023-08-10T00:00:00+09:00</updated><id>http://localhost:4000/travel/tokyo-6</id><content type="html" xml:base="http://localhost:4000/travel/tokyo-6/">&lt;p&gt;도쿄에서의 여섯번 째 날입니다. 이 날은 다른 호텔로 이동하는 날이었는데, 전날 늦게 자서 그런지 아침부터 매우 피곤했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/01.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호텔을 떠나는 기념으로 마지막 식사는 양식으로 먹어봤습니다. 양식도 딱히 나쁘진 않더라구요.&lt;/p&gt;

&lt;h2 id=&quot;호텔-체크아웃&quot;&gt;호텔 체크아웃&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/02.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아침 식사 후에는 호텔을 떠나기 위해 짐을 챙겼습니다. 짐을 다 챙기고 호텔을 떠나려고 로비로 가니, 직원이 직접 체크아웃을 하지 않고 기계를 이용하여 체크아웃을 할 수 있게 만들어놨습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/03.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;체크아웃 기계에서는 다행히 한국어 옵션이 있어서 편하게 체크아웃할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/04.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호텔을 나와 신바시 역으로 이동하던 중에 나무에 앉아있는 까마귀를 봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/05.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;나고야에서도 느꼈지만 일본에는 까마귀가 참 많은 것 같습니다. 한국에서는 까마귀를 거의 못봤던 것 같은데요.&lt;/p&gt;

&lt;h2 id=&quot;유리카모메&quot;&gt;유리카모메&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/06.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 머물 호텔은 오다이바에 있었습니다. 오다이바는 도쿄에서도 교통이 불편한 곳 중 하나인데, 머물던 호텔에서 가장 가까운 역인 신바시 역에서 유리카모메를 타면 한 번에 갈 수 있었습니다.&lt;/p&gt;

&lt;p&gt;다만 유리카모메는 관광용 열차이기 때문에 다른 지하철이나 기차에 비해 요금이 매우 비싼 편입니다. 도쿄 내의 지하철을 전부 탈 수 있는 도쿄 서브웨이 티켓도 1일 무제한 이용권이 800엔인데, 노선 길이도 짧은 유리카모메의 1일 무제한 티켓은 820엔이나 합니다. 오다이바 내에 있는 호텔에서 도쿄 시내로 나오기 위해서는 무조건 탑승해야 하기 때문에 1일 무제한 티켓을 뽑을 수 밖에 없는데, 이러면 교통비가 정말 많이 나올 수밖에 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/07.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 다음에 머물 호텔은 시조마에 역 앞에 있었습니다. 신바시에서 13개의 역을 지나가야 하네요. 직선거리로는 짧은 거리지만, 유리카모메가 오다이바를 빙 둘러서 가기 때문에 생각보다 시간이 오래 걸립니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/08.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유리카모메의 특징은 로망스카처럼 맨 앞에 앞을 볼 수 있게 만든 좌석이 있다는 것입니다. 다만 이 좌석의 경쟁이 꽤 치열하기 때문에, 종점인 신바시 역이나 도요스 역이 아니면 앉기가 어렵습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/09.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유리카모메는 지상을 달리고, 모노레일 같은 느낌이 나기 때문에 맨 앞좌석에서 보는 풍경이 나름 괜찮습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/10.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지나가다보니 항구 느낌이 나는 건물도 보이네요.&lt;/p&gt;

&lt;h2 id=&quot;유나이티드-시네마-도요스&quot;&gt;유나이티드 시네마 도요스&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3241.928081231535!2d139.7915476282204!3d35.65414351241483!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188998ad95e545%3A0xbd16e6b1c1ebebc3!2sUnited%20Cinemas%20Toyosu!5e0!3m2!1sko!2skr!4v1691651860453!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/11.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호텔 체크인 까지 시간이 좀 남았었기 때문에, 그 시간 동안 영화를 하나 보기로 했습니다. 제가 보고싶었던 영화는 월요일에 성지순례를 했던 청춘돼지 시리즈의 신 극장판인데, 한국에 수입되기까지는 시간도 꽤 걸리고 개봉되더라도 극소수의 영화관에서만 볼 수 있을 것 같았기에 일본에 간 김에 보기로 했습니다. 제가 일본어를 엄청 잘하는건 아니지만, 그래도 원작 소설을 읽었기 때문에 스토리는 이미 알고 있어서 괜찮을 것 같았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/12.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;영화는 11시 40분 시작이었는데 아슬아슬하게 시작 전에 표를 구매할 수 있었습니다. 표값은 1200엔이었는데, 한국보다는 확실히 저렴한 것 같습니다. 개봉한지 3주 정도 지나서 그런지 좌석은 많이 남아있더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/13.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;입장하러가는 도중에 청춘 돼지 관련 홍보물이 많이 보였습니다. 팜플렛도 하나 챙기고 싶었는데, 아쉽게도 팜플렛은 없었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/14.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;영화의 장면이 그려진 그림들도 전시되어 있었습니다. 이 장면은 고등학교 진학 시험을 준비하는 카에데의 공부를 도와주는 마이의 모습으로 보이네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/15.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;영화를 입장할 때 특전이랍시고 뭔가 받았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/16.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;나중에 확인해보니 특전은 몇몇 장면의 원화였습니다. 특전이 있다면 캐릭터 상품 같은걸 주지 어디다 쓰라고 이걸 주는지 모르겠네요…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/17.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;영화를 보고 나오니 청춘 돼지 관련 굿즈를 파는게 보였습니다. 저 포스터는 살 의향이 있었는데 아쉽게도 포스터는 파는 물건이 아니었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/18.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;굿즈 샵에서 신기했던 점은 영화 등장인물의 냄새를 맡을 수 있는 디퓨저를 팔고 있다는 것이었습니다. 어떤 냄새인지 궁금하긴 했지만 여기에 2만원이 넘는 돈을 태우기는 아까워서 구경만 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;스시츠네-타쿠미-라라포트-도요스&quot;&gt;스시츠네 타쿠미 라라포트 도요스&lt;/h2&gt;

&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d4584.605198341513!2d139.7915287808685!3d35.65716524780242!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188998ad95e545%3A0xe8d1c3626901efca!2sSushitsune%20Takumi%20Lalaport%20Toyosu!5e0!3m2!1sko!2skr!4v1691653736906!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;영화를 보고나니 배가 고파 점심을 먹기로 했습니다. 원래 도요스 시내에 있는 음식점을 가려고 했는데, 날씨가 더우니 돌아다니기 귀찮더라구요. 마침 영화관이 있던 곳이 라라포트라는 종합 쇼핑몰이었기 때문에, 여기 입점한 가게 중 하나를 방문하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/19.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 갔던 곳은 체인점으로 보이는 일식집이었는데, 생각보다 손님이 많았습니다. 대기하고 있던 손님까지 있더라구요. 원래 대기를 싫어서 다른곳을 갈까 하다가 대기번호가 그렇게 길지 않아서 그냥 기다리기로 했습니다. 대기번호는 가게 밖에 있는 기계를 이용해서 받을 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/20.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 가게는 점심용 메뉴가 따로 있었습니다. 뭘 먹을까 하다가 새우튀김을 곁들인 초밥 세트가 1480엔 밖에 안하길래 그걸로 주문했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/21.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메뉴를 받아보니 사진하과 거의 동일하더라구요. 초밥 갯수가 적어서 양이 좀 적긴 했지만, 여행할 때는 적게 자주 먹는게 좋기 때문에 신경쓰지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/22.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;계산할 때 보니 메뉴판에 있던 가격은 세금을 제외한 금액이었습니다. 일본은 이상하게 메뉴판에 세후 가격을 구석에 조그맣게 적어놓더라구요. 세금 10%를 포함하니 1628엔이었습니다.&lt;/p&gt;

&lt;h2 id=&quot;유린도-서점&quot;&gt;유린도 서점&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3241.9103803897024!2d139.7940999!3d35.6545796!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x601889e19bfc6b9d%3A0xe1b4a505df5571cf!2sYurindo!5e0!3m2!1sko!2skr!4v1691654551726!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/23.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;식사를 마치고 도요스 역으로 돌아가는 길에 라라포트 안에 있는 서점이 보였습니다. 일본에서는 어떤 책을 팔고 있을까 궁금했고, 특히 한국어 교재가 궁금했었기 때문에 들러봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/24.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한국어 교재 중에 “드라마로 배우는 한국어” 라는 책이 있길래 한번 펴봤는데 내용이 재밌었습니다. 한국으로 치면 “애니메이션으로 배우는 일본어” 같은 느낌이네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/25.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생각보다 고급 어휘들도 나오네요. 전공의라는 단어까지 배울 필요가 있을까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/26.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;보다보니 뭔가 현실에서 쓰기에 부끄러워질만한 대사도 있어서 재밌었습니다. 일본 사람들이 느끼는 애니식 말투가 이런 느낌일까요?&lt;/p&gt;

&lt;h2 id=&quot;라비스타-도쿄베이&quot;&gt;라비스타 도쿄베이&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3242.2320263895804!2d139.7814338764218!3d35.64665463187153!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x601889284cb62b09%3A0x373d48d832ff842!2z652867mE7Iqk7YOAIOuPhOy_hOuyoOydtA!5e0!3m2!1sko!2skr!4v1691651623193!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/27.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 새로 묵을 호텔은 라비스타 도쿄베이입니다. 오다이바 안쪽에 있어서 교통은 조금 불편하지만, 그래도 시조마에 역 바로 앞에 있어서 그나마 다행이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/28.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호텔은 13층까지 있었는데, 제가 배정 받은 객실은 11층에 있었습니다. 높은 층에 배정받은 것은 마음에 들었지만, 객실이 복도 끝에 있어서 엘리베이터까지 꽤 멀다는 것은 단점이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/29.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객실에 들어서고 깜짝 놀랐습니다. 일본의 호텔은 대부분 크기가 작아서 원룸 같은 구조로 되어 있는데, 여긴 현관이 별도로 분리되어 있는 구조더라구요. 보이시는 곳에서 정면의 문이 침실 쪽 문이고, 왼쪽이 화장실 쪽 문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/30.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 침실로 들어가봤는데, 렘 플러스 긴자와는 비교도 할 수 없을 만큼 방이 넓었습니다. 저 조그만 테이블 위에 캐리어를 펴고도 움직이는데 하나도 불편함이 없을 정도였습니다. 이 정도면 두 사람이 묵어도 넉넉할 만한 크기네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/31.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 화장실입니다. 변기와 샤워실도 분리되어 있었습니다. 변기 오른쪽의 문을 열면 샤워실이 나옵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/32.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;샤워실 내에 욕조는 없었지만, 그래도 크기가 넉넉해서 샤워하는데 불편함은 없었습니다.&lt;/p&gt;

&lt;h2 id=&quot;토리타무라-본점&quot;&gt;토리타무라 본점&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3240.408669867801!2d139.7038012764233!3d35.69155972940539!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60188cdb7de261e9%3A0xb01003eebe9b6ff6!2z7Yag66as7YOA66y06528IOuzuOygkA!5e0!3m2!1sko!2skr!4v1691657051580!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/33.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호텔에서 짐을 풀고, 어제 쌓인 피로가 풀리지 않아서 낮잠을 조금 잤습니다. 그래도 저녁까지 호텔에 있긴 아까워서, 월요일에 못간 토리타무라를 다시 방문했습니다. 토리타무라가 있는 신주쿠는 오다이바에서 완전 반대 방향에 있었기 때문에 가는데 시간이 꽤 많이 걸렸습니다. 과연 토리타무라가 그렇게 맛있을지 궁금하네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/34.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;들어가자마자 생맥주를 하나 시켰습니다. 일본 생맥주는 무슨 비결인지 한국과 다르게 진짜 맛있더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/35.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/36.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;토리타무라의 메뉴판입니다. 위쪽이 음식, 아래쪽이 음료 메뉴입니다. 저는 우선 1150엔짜리 야키토리 코스를 주문했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/37.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;야키토리 코스는 꼬치 6개가 종류별로 나왔습니다. 저는 저 파가 중간에 꽂혀있는 꼬치가 제일 맛있었는데, 저게 뭔지 이름을 모르겠네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/38.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중간에 술이 부족해서 하이볼을 추가했는데, 전 왠지 하이볼이 딱히 맛있지가 않더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/39.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저녁을 안먹어서 그런지 배가 덜차서 소금구이 꼬치와 생맥주를 추가했습니다.&lt;/p&gt;

&lt;p&gt;맛은 괜찮았는데, 이것저것 주문하다보니 계산서에 4천엔이 넘게 찍혔더라구요. 일본에서 한 끼에 이렇게 큰 돈을 쓴 적은 처음이네요.&lt;/p&gt;

&lt;h2 id=&quot;야식&quot;&gt;야식&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/012/40.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 묵었던 라비스타 도쿄베이에서는 밤 10시부터 야식으로 무료 라멘을 제공했습니다. 저녁도 어중간하게 먹었고, 이 라멘이 맛있다는 소문을 들어서 먹으러 갔는데 듣던대로 꽤 맛있었습니다. 예전에 먹었던 일본 라멘은 너무 짜서 제 입맛에 안맞았는데, 여기는 소금을 개인 취향에 따라 넣어 먹을 수 있도록 따로 제공해서 그런지 짜지 않고 맛있었습니다.&lt;/p&gt;

&lt;p&gt;6일차 일정은 이렇게 마무리가 되었습니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="travel" /><category term="tokyo" /><summary type="html">도쿄에서의 여섯번 째 날입니다. 이 날은 다른 호텔로 이동하는 날이었는데, 전날 늦게 자서 그런지 아침부터 매우 피곤했습니다.</summary></entry></feed>