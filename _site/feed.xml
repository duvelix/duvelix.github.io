<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-13T15:43:23+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">KEEPMIND</title><subtitle>A place I record so that I don&apos;t forget.</subtitle><author><name>Joonsu Ryu</name></author><entry><title type="html">교토 여행기 (3)</title><link href="http://localhost:4000/travel/kyoto-3/" rel="alternate" type="text/html" title="교토 여행기 (3)" /><published>2023-10-13T00:00:00+09:00</published><updated>2023-10-13T00:00:00+09:00</updated><id>http://localhost:4000/travel/kyoto-3</id><content type="html" xml:base="http://localhost:4000/travel/kyoto-3/">&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/01.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세 번째 날 조식은 고민할 것도 없이 바로 부페로 갔습니다. 이 호텔의 조식이 맛있다는 후기가 많았는데, 저는 라비스타에서의 화려한 조식을 맛보고 나니 그냥 평범해보이더라구요. 다만 직접 그 자리에서 만들어주는 오믈렛은 괜찮았고, 저 닭고기 반찬은 굉장히 맛있었습니다.&lt;/p&gt;

&lt;h2 id=&quot;아라시야마로-가는-길&quot;&gt;아라시야마로 가는 길&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d26146.451436983934!2d135.69624914633653!3d34.99903366507269!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e3!4m5!1s0x6001089572eaf6db%3A0x469c370f6f1f1b0b!2z7J2867O4IOq1kO2GoOu2gCDqtZDthqDsi5wg7Iuc66qo6rWQ6rWsIOuLpOydtOuniOyTsOy0iCDrpqzqsIAg66Gc7JaEIO2YuO2FlCDqtZDthqA!3m2!1d34.986385299999995!2d135.75269509999998!4m5!1s0x60010751678b6c0d%3A0x59dca24d07f3db74!2z7JWE65287Iuc7JW866eIIEFyYXNoaXlhbWEgSGlnYXNoaWljaGlrYXdhY2jFjSwgTmlzaGlreW8gV2FyZCwgS3lvdG8sIDYxNi0wMDAyIOydvOuzuA!3m2!1d35.0103668!2d135.68160989999998!5e0!3m2!1sko!2skr!4v1697161387752!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;아라시야마로 가는 길은 버스도 있고 기차도 있는데, 숙소 바로 근처에 한 번에 갈 수 있는 버스가 있기에 그냥 버스를 타고 갔습니다. 리가 로얄 호텔 기준, 28번 버스를 타고 가면 아라시야마로 한 번에 갈 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/02.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;워낙 유적지가 많은 교토다보니, 버스 정류장 앞에도 절 같은 유적지가 보이네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/03.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 부근에 버스 정류장이 엄청 많은데, 28번 버스를 타기 위해서는 F 정류장으로 가셔야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/04.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;28번 버스의 시간표입니다. 한 시간에 3대 정도가 다니네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/05.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;버스로 40분 정도 달리다보면 아라시야마에 도착합니다. 아라시야마가 관광지라서 굉장히 북적일 줄 알았는데, 내리고보니 그냥 일반 주택가나 다름이 없어서 조금 당황했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/06.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;구글 지도를 보면서 걷다보니 갈림길이 하나 나왔습니다. 다리를 건너가면 아라시야마 죽림과 텐류지로 갈 수 있는데, 저는 그 전에 다른 곳을 들르기 위해 왼쪽에 있는 골목으로 들어갔습니다.&lt;/p&gt;

&lt;h2 id=&quot;몽키파크&quot;&gt;몽키파크&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3267.7511644643205!2d135.6740886912721!3d35.01293363525606!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x600100ab6efb49bd%3A0x1b3493b0430734b2!2z66q97YKk7YyM7YGs!5e0!3m2!1sko!2skr!4v1697162593351!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/07.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;바로 몽키파크입니다! 아라시야마 근처에 원숭이가 뛰노는 공원이 있다고 하는데, 그걸 빼먹고 갈 수가 있나요. 가는 길이 조금 험하다는 말은 들었지만, 이 때 아니면 언제 가볼 수 있을까 싶어서 고민없이 첫 일정으로 결정했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/08.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역시나 일본 관광지 답게 입장료가 있습니다. 입장료는 성인 기준 600엔입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/09.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;몽키파크 입장권 사진입니다. 특이하게 주의사항이 일본어와 영어로 적혀있습니다. 원숭이에게 먹이를 주지 말고, 만지지 말고, 3m 이상 떨어지라네요. 또 원숭이 눈을 똑바로 쳐다보지 말라고 합니다. 싸우자는 의미라고 하네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/10.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;몽키파크는 산 중턱에 있기 때문에 가기 위해서는 등산을 해야합니다. 그런데 일본은 굉장히 덥기 때문에, 그냥 맨몸으로 올라가는 것은 권하지 않는데요, 다행히 입구에 자판기가 있어서 음료수를 뽑아갈 수 있습니다. 자판기에도 음료수를 가지고 올라가라는 주의사항이 적혀있네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/11.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저는 칼피스를 하나 구매했습니다. 맛은 밀키스랑 비슷하더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/12.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가는 길에도 원숭이에 대한 주의사항이 계속 나오는데, 음식을 눈앞에 보이게 하지 말라고 합니다. 아마 음식이 보이면 원숭이가 훔치거나 뺏거나 하는 것 같아요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/13.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역시 산길은 쉽지 않습니다. 끝이 보이지 않는 계단이 눈에 들어오네요… 다행히 중간중간 벤치가 있어서 힘들면 쉬었다 갈 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/14.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한참을 올라온 것 같은데, 지도를 보니 아직 조금밖에 못올라왔네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/15.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래 지점에서 사진을 찍었는데, 저 위에 꼭대기까지 올라가야 합니다. 큰일났습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/16.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간신히 중턱까지 올라왔습니다. 이곳에는 힘들게 올라온 관광객을 위한 휴게소가 있는데, 에어컨도 있기 때문에 여기서 쉴 수 있습니다. 다만 그렇게 시원하진 않더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/17.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;휴게소 앞에는 조그마한 공원이 있는데, 고등학생 정도 되보이는 학생들이 여기서 재밌게 놀고 있더라구요. 기운도 좋아라…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/18.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원숭이 출몰 지역(?)으로 가니 그냥 길에 대놓고 원숭이가 돌아다닙니다. 분명히 원숭이 3m 이내에는 접근하지 말라고 했던 것 같은데… 다들 신경쓰지 않더라구요. 나중에는 그냥 원숭이 옆에 앉아도 원숭이가 사람을 돌 보듯 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/19.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이곳도 나름 산이다보니 주변을 내려다볼 수 있는 전망대가 있는데, 교토 시내가 한 눈에 들어옵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/20.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원래 원숭이에게는 함부로 먹이를 줄 수 없지만, 공원에서 정해진 장소로 가면 먹이 주는 것을 체험해볼 수 있습니다. 다만 아무 음식이나 줄 수는 없고, 공원 측에서 판매하고 있는 먹이만 줄 수 있습니다. 땅콩과 사과 2종류가 있는데, 어떤 것이든 50엔에 판매하고 있으니 아무거나 사서 주면 됩니다. 재밌게도, 땅콩을 주면 껍질을 까서 먹는게 아니라 그냥 통째로 씹어먹더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/21.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원숭이에게 먹이를 주는 곳에는 원숭이의 생태에 관련된 여러 글이 있습니다. 원숭이 얼굴은 왜 빨간색일까? 같은 내용이요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/22.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;겁도없이 사람 틈바구니에 앉아있는 원숭이입니다…만 근데 저거 설마 오줌일까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/23.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/24.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주변에는 조그만 웅덩이도 있습니다. 그런데 신기하게 여기도 물고기가 살고 있네요. 이 조그만 웅덩이에 물고기가 먹을 만한 것이 있을까요? 그리고 원숭이들이 이 물고기를 그냥 놔둘까요? 여러 궁금증이 생기네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/25.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;몽키파크를 다 보고 내려가는 길에 또 조그만 신사가 하나 보입니다. 일본은 신사가 진짜 많네요.&lt;/p&gt;

&lt;h2 id=&quot;도게츠-교&quot;&gt;도게츠 교&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3267.7511644643205!2d135.6740886912721!3d35.01293363525606!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001075300916977%3A0xec14f8e82496283d!2z64-E6rKM7LigIOq1kA!5e0!3m2!1sko!2skr!4v1697164688964!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/26.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로는 아라시야마 죽림과 텐류지를 보러 가기로 했습니다. 몽키파크에서 그곳으로 가기 위해서는 도게츠 교를 지나가야 하는데, 도게츠 교 자체의 경치도 나름 볼만합니다. 여긴 여러 개의 뗏목이 있는데, 돈을 내면 뗏목 투어를 할 수 있더라구요. 가격은 역시나 상당히 비쌌습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/27.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/28.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;강 주변에는 여유롭게 감상할 수 있도록 벤치가 많이 있습니다. 안그래도 산을 타느라 조금 지쳐있어서, 저도 여기서 조금 쉬면서 경치를 구경했습니다.&lt;/p&gt;

&lt;h2 id=&quot;아리사야마-죽림&quot;&gt;아리사야마 죽림&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3267.6885318916834!2d135.67198217640208!3d35.01450121631!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001abebbf5c8bad%3A0xfb9ffc7bbdd67cdd!2z7JWE65287Iuc7JW866eIIOy5mOy_oOumsA!5e0!3m2!1sko!2skr!4v1697164879994!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/29.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 아라시야마 죽림으로 가보기로 했습니다. 대로를 통해서 갈 수도 있는데, 그럼 텐류지는 지나서 가야합니다. 이렇게 가면 다음 일정으로 가는 길이 조금 꼬일 것 같아, 저는 강을 따라 가는 경로로 이동했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/30.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중간중간에 아라시야마 죽림으로 가는 이정표가 있기 때문에 길을 찾는 것은 어렵지 않습니다. 한글로도 나와있네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/31.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아라시야마 죽림으로 가는 산책로도 잘 정비되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/32.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;슬슬 대나무가 보이기 시작합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/33.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아라시야마 죽림으로 가기 전까지는 사람이 그렇게 많지 않았는데, 여기에 도착한 순간 엄청난 인파가 눈에 들어왔습니다. 솔직히 말씀드리면 대나무보다 사람이 더 많이보일 정도입니다. 원체 유명한 관광지이긴 하지만, 이 인파 때문에라도 다른 사람에게 별로 추천해주고 싶은 곳은 아니네요. 솔직히 그냥 대나무 숲일 뿐인데 말이에요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/34.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아라시야마 죽림에는 대나무가 굉장히 빽빽하게 자라있는데, 그 때문인지 몇몇 대나무는 영양 공급을 받지 못해 죽어가고 있었습니다. 사진에서도 건강한 대나무와 죽어가는 대나무가 보일 정도입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/35.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아라시야마 죽림의 길이는 약 50m 정도입니다. 죽림이 끝나는 곳에 텐류지 후문이 있기 때문에, 바로 다음 관광을 시작할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;텐류지&quot;&gt;텐류지&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3267.638325574394!2d135.67141354809092!3d35.01575774625823!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001aa01b80f9e93%3A0xcd9c3edaff3348c0!2z7YWQ66WY7KeA!5e0!3m2!1sko!2skr!4v1697165627105!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/36.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/37.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;텐류지도 역시 입장료가 있습니다. 입장료는 성인 기준 500엔입니다. 다만 이 곳은 입장료 장난질이 좀 심한데, 정원 입장료가 500엔이고 본당에 들어가려면 추가로 300엔, 그리고 운용도에 들어가려면 또 500엔을 추가로 내야합니다. 저는 그냥 정원만 구경하고 돌아가기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/38.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/39.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;물론 텐류지도 유명한 관광지인 만큼 정원만 보더라도 볼 거리는 있습니다만, 500엔의 가치를 하냐면 글쎄요…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/40.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/41.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;텐류지 내에는 여러 종류의 식물이 자라고 있었는데, 그 식물들이 어떤 식물인지 알려주는 안내판이 있었습니다. 한국어로도 번역해놓았더라구요. 그런데 식물에 조예가 없어서 이름을 봐도 뭔지 모르겠네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/42.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/43.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;텐류지 안에도 호수가 있었는데 역시나 물고기들이 살고 있었습니다. 물고기들도 햇빛이 싫은지 그늘 아래에 다 몰려있더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/44.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;텐류지의 호수를 바라보는 풍경도 괜찮아서 많은 관광객들이 앉아서 경치를 감상하고 있었습니다. 저는 신주쿠 교엔의 풍경이 더 좋았던 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/45.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/46.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이곳이 바로 500엔을 추가로 내야 들어갈 수 있는 운용도입니다. 저는 들어가지 않아서 건물만 찍고 왔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/47.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/48.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;텐류지는 생각보다 그렇게 넓지 않아서 넉넉잡고 30분 정도면 다 둘러볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;금각사로-이동&quot;&gt;금각사로 이동&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d26138.55995706554!2d135.68496029638578!3d35.02372380391705!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e3!4m5!1s0x6001aa01b80f9e93%3A0xcd9c3edaff3348c0!2z7YWQ66WY7KeAIO-8lu-8mCBTYWdhdGVucnl1amkgU3VzdWtpbm9iYWJhY2hvLCBVa3lvIFdhcmQsIEt5b3RvLCA2MTYtODM4NSDsnbzrs7g!3m2!1d35.0165855!2d135.6745843!4m5!1s0x6001a820c0eb46bd%3A0xee4272b1c22645f!2z6riI6rCB7IKsIOmHkemWo-Wvug!3m2!1d35.03937!2d135.7292431!5e0!3m2!1sko!2skr!4v1697172093097!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;원래 이 날 일정은 텐류지 다음에 닌나지/료안지/금각사를 모두 보려고 했습니다만, 이틀 동안 절을 보고 나니 절에 대한 흥미가 팍 사라졌습니다. 사실 전부 안볼까 생각도 했습니다만, 그래도 금각사는 교토의 대표적인 관광지였기 때문에 금각사 하나만 보고 들어가기로 결정했습니다. 텐류지에서 란덴을 타면 금각사 근처까지 갈 수 있었기 때문에 전 란덴을 탔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/49.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아라시야마에서 란덴을 타려고 하시는 분은 정말 잘 찾아보셔야합니다. 역이 정말 생각치도 못한 곳에 있었기 때문입니다. 겉보기에는 그냥 상가처럼 보이는데, 알고보니 이게 란덴 정거장이었더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/50.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;게다가 열차가 상가 안으로 직접 들어옵니다! 개찰구 같은 것도 없어요. 요금은 내릴 때 내거든요. 그래서 처음 봤을 때는 열차가 여기까지 들어온다고? 하는 느낌이 들었습니다. 그리고 열차도 관광열차같이 특이한 디자인을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/51.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;열차는 2량으로 구성되어 있는데, 서로 분리된 구조라 열차를 건너갈 순 없습니다. 이거보다 더 인상깊었던 점은, 란덴은 분명 기차인데도  내리고 싶으면 버스처럼 벨을 눌러야 합니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/52.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;금각사에 가기 위해서는 기타노하쿠바이초 역에서 내리시면 됩니다. 이 역으로 오기 위해서는 가타비라노쓰지 역에서 란덴 B로 환승하신 다음 종점까지 쭉 가시면 됩니다. 이 역에서는 개찰구가 있어서 내리고 여기서 IC 카드를 찍으면 되는데, 개찰구가 없는 역에서는 열차 내에서 IC 카드를 찍는 구조로 되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/53.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기타노하쿠바이초 역에서 금각사까지 가기 위해서는 약 20분 정도 걸어야합니다. 버스로 가는 방법도 있지만 버스 정류장을 찾고 버스를 기다리는 시간을 따져보면 거기서 거기입니다. 게다가 버스는 버스비 230엔도 추가로 내야 하구요.&lt;/p&gt;

&lt;h2 id=&quot;sakura-an&quot;&gt;Sakura-an&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d943.6203296003924!2d135.7305214866753!3d35.032940082868265!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001078c8e59cbc3%3A0x336555e6402d1744!2sSakura-an!5e0!3m2!1sko!2skr!4v1697173620453!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/54.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;금각사로 가는 길에 슬슬 배가 고파졌길래 식사를 하고 가기로 했습니다. 뭘 먹을까 하다가, 지난번 도쿄 여행 때 냉우동을 맛있게 먹은 기억이 나서 우동 가게에 들어갔습니다. 구글 평가도 좋더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/55.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가격은 대부분의 메뉴가 850엔이었습니다. 제가 교토에 와서 본 메뉴판 중에 가장 저렴한 가격이네요. 냉우동 중에서는 유자 냉우동이 제일 잘나간다고 하길래 그걸 주문했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/56.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주문하고 나니 물 대신 차가운 차 한잔을 주더라구요. 맛있었습니다만 잔이 너무 작아서 한모금 마시면 없어지더라구요. 또 달라고 하면 주긴 하는데 계속 달라고하기 조금 미안해서 콜라를 하나 주문했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/57.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여긴 특이하게 병콜라를 주네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/58.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;식사는 양이 조금 적긴 했지만, 지금까지 먹었던 창렬같은 식사에 비하면 매우 마음에 들었습니다. 유자 소스가 조금 시큼하긴 했는데, 그래도 면발이 쫄깃해서 맛있게 잘 먹었습니다.&lt;/p&gt;

&lt;h2 id=&quot;다시-금각사로-이동&quot;&gt;다시 금각사로 이동&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/59.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;금각사로 가는 길에는 주택가가 있습니다. 저는 일본 주택가의 모습을 구경하면서 참 좋더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/60.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중간중간 금각사를 안내하는 표지판도 있는데, 한국어로도 안내가 되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/61.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;금각사 주변에는 역시나 상점들이 많이 있습니다. 그런데 금각사가 워낙 유명한 관광지다보니 상점들의 폭리가 장난 아니더라구요. 소프트 아이스크림 하나에 750엔인 곳은 처음 봤습니다. 금각사 컨셉에 맞게 금가루를 뿌렸다고는 하는데 진짜 금가루인지는…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/62.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;금각사로 들어가는 입구부터 매우 많은 사람이 보입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/63.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/64.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역시나 금각사도 입장료를 받습니다. 다만 텐류지처럼 양심없게 이것저것 받아먹지는 않고, 깔끔하게 입장료 500엔만 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/65.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;금각사의 티켓도 지쇼지처럼 부적 모양이네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/66.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;매표소를 지나오면 바로 눈앞에 금빛 건물이 보입니다. 진짜 금으로 만들어졌다는데, 그래서 그런지 눈에 확 띄네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/67.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가까이서 보니 1층은 일반 건물인데, 2층과 3층이 금박으로 되어 있습니다. 나중에 알고보니, 원래 금이 이렇게 많지는 않았는데, 80여년 전 쯤에 방화사건으로 금각사가 소실되자 재건축을 한 것이라고 합니다. 원래 사용되던 금보다 훨씬 많은 금을 사용해서 약간 과장스럽게 표현했다네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/68.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/69.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/70.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;절에는 이 외에도 소소하게 볼 것이 있긴 하지만 다른 절에도 다 있을법한 볼거리라 특이한 점은 없었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/71.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀리 언덕에서 보니 1층이 안보이고 2, 3층만 보여서 완전 금빛 건물처럼 보이네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/72.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/73.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이곳에서도 오미쿠지를 팔고 있습니다. 다만 제비뽑기로 하는 일반적인 신사와는 달리 여기는 현대적(?)인 자판기로 오미쿠지를 판매하고 있네요. 그래서 그런지 가격도 다른 곳의 절반인 100엔에 팔고 있습니다. 교토에서 오미쿠지를 한번도 안해봐서, 온 김에 한번 해보기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/74.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자판기에 100엔을 넣으면 오미쿠지가 나옵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/75.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지금까지는 오미쿠지를 하면 항상 대길만 나왔는데, 이번에는 그냥 길만 나왔네요. 내용이 뭔가 추상적으로 적혀있어서 이전에 봤던 오미쿠지들보다 해석하기가 조금 어려웠습니다. 호텔에서 자세히 읽어보니 나중에 세상에 이름이 알려져 출세한다는데 정말 그럴 수 있을지 궁금해지네요…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/76.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;금각사를 구경하고 나오는 길에 본 롯데 자판기입니다. 사먹지는 않았지만, 절 내에서 이렇게 현대적인 문명의 이기(?)를 팔고 있는 것도 신기했고, 롯데를 여기서 본 것도 신기했습니다.&lt;/p&gt;

&lt;p&gt;여담으로 금각사에서 교토 역으로 다시 오는 길은 정말 지옥입니다. 대중교통이 버스밖에 없기 때문에 버스를 타고 와야하는데, 금각사를 구경한 관광객이 모두 그 버스를 타기 때문에 어떤 버스를 타던 사람이 가득 찹니다. 앉는 것은 고사하고 사람 틈바구니에 껴서 40분 이상을 가야하는데, 저는 정말 괴로웠습니다.&lt;/p&gt;

&lt;h2 id=&quot;이온몰-쇼핑&quot;&gt;이온몰 쇼핑&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d3268.8730905741045!2d135.75396489572807!3d34.98484345653781!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x0%3A0x469c370f6f1f1b0b!2z66as6rCAIOuhnOyWhCDtmLjthZQg6rWQ7Yag!3m2!1d34.986385299999995!2d135.75269509999998!4m5!1s0x600108a97fae4bf1%3A0x742487efb2e95a14!2z7J207Jio66qwIOq1kO2GoCAxIE5pc2hpa3VqbyBUb3JpaWd1Y2hpY2hvLCBNaW5hbWkgV2FyZCwgS3lvdG8sIDYwMS04NDE3IOydvOuzuA!3m2!1d34.982746999999996!2d135.7545979!5e0!3m2!1sko!2skr!4v1697178920169!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;금각사까지 구경한 다음에는 호텔에서 쉬었습니다. 오늘 저녁에는 뭘 먹을까 고민해보다가, 일본의 쇼핑몰인 이온몰이 그렇게 가성비가 좋다고 한 것이 생각나 이온몰에서 쇼핑을 해보기로 했습니다. 마침 숙소 근처에 걸어서 갈 만한 이온몰이 하나 있기도 했구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/77.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이온몰은 교토역 남쪽에 있었는데, 숙소는 교토역 북쪽에 있어서 철길 아래를 지나가야 이온몰에 갈 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/78.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10분 정도 가니 이온몰이 바로 나왔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/79.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저는 이온몰 전체가 식료품을 파는 가게인줄 알았는데, 알고보니 이온몰 내의 KOHYO라는 곳에서만 식료품을 팔고 있다고 합니다. 나머지는 그냥 이온몰에 입점한 매장이더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/80.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;바로 식료품 코너로 달려가니 초밥과 회를 비롯한 음식이 많이 있었습니다. 저는 저녁거리와 술, 술안주를 이것저것 구매했는데, 계산하고보니 4천엔이 넘게 나왔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/81.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이온몰에서 사온 초밥과 라면으로 저녁을 먹었습니다. 일본 라면은 잘 몰라서 교토라고 적힌 라면을 구매했는데, 맛이 생각보다 너무 별로라서 실망했습니다. 맛도 맛이지만 냄새가 너무 심하더라구요.&lt;/p&gt;

&lt;p&gt;그런데 라면물을 붓고 나니 젓가락이 없다는 것을 깨달았습니다. 호텔 로비에 부탁하니 다행히 일회용 젓가락을 갖다주더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/019/82.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이온몰에서 할인하고 있던 회와 시샤모를 사서 밤에 술안주로 먹었습니다. 시샤모가 단돈 199엔! 시샤모는 특히 한국에 팔지 않는 생선이라, 일본에 갈 때마다 먹으려고 하고 있습니다. 저는 사실 하이볼은 별로 좋아하지 않는데, 제가 주문했던 곳들이 잘 못하는 곳인가 싶어서 한번 완제품 하이볼을 사봤습니다. 그런데 역시나 알고있던 그 맛이 나오더라구요. 다음에는 하이볼을 사지 말아야겠습니다.&lt;/p&gt;

&lt;p&gt;이온몰에서 사먹는 음식이 가성비는 괜찮았지만, 다음에는 그냥 호텔 주변에 있는 이자카야에서 먹는게 낫다는 생각이 들어왔습니다. 혼자 여행왔는데 호텔에 쳐박혀 술을 먹으니 뭔가 쓸쓸하네요.&lt;/p&gt;

&lt;p&gt;이렇게 교토에서 세 번째 날이 끝났습니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="travel" /><category term="kyoto" /><summary type="html"></summary></entry><entry><title type="html">교토 여행기 (2)</title><link href="http://localhost:4000/travel/kyoto-2/" rel="alternate" type="text/html" title="교토 여행기 (2)" /><published>2023-10-11T00:00:00+09:00</published><updated>2023-10-11T00:00:00+09:00</updated><id>http://localhost:4000/travel/kyoto-2</id><content type="html" xml:base="http://localhost:4000/travel/kyoto-2/">&lt;p&gt;교토에서의 첫 아침입니다. 어제는 새벽부터 일어나서 먼 거리를 이동하느라 상당히 지쳤기 때문에 일찍 잠들었습니다. 술도 많이 마셔서 푹 잔 덕분에 오늘부터는 오전부터 바쁘게 돌아다닐 예정입니다.&lt;/p&gt;

&lt;h2 id=&quot;조식&quot;&gt;조식&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/001.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 묵었던 리가 로얄 호텔 교토는 조식 식당이 2개 존재했습니다. 하나는 1층에 있는 부페식 식당이고, 다른 하나는 지하 1층에 있는 일본식 식당이었습니다. 부페식 식당은 다른 호텔과 비슷한 구조일 것 같아서 일본식 식당에 가보기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/002.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;엘리베이터에 타고 느낀건데, 열림과 닫힘 버튼 구조가 굉장히 클래식한(?) 구조라서 신기했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/003.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일본식 식당에 가니 먼저 어떤 식으로 나오는지 설명을 간단하게 해준다음 차를 한잔 주더라구요. 날씨가 더워죽겠는데 따뜻한 차를 주길래 차가운 물을 달라고 요청했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/004.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이것이 일본식 아침식사입니다. 묘하게 양이 많은 것 같으면서도 부실하네요. 반찬의 가짓수는 많은데 하나같이 간이 심심하고 맛이 그저 그랬습니다. 연어구이는 딱딱하고, 김은 한국과 다르게 종이씹는 느낌이 나더라구요. 그나마 어묵과 계란 정도가 먹을만 했는데 이럴거면 그냥 부페식 식당에서 먹는게 낫지 않나라는 생각이 들었습니다.&lt;/p&gt;

&lt;h2 id=&quot;헤이안-신궁&quot;&gt;헤이안 신궁&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d26146.122947915923!2d135.74526359633862!3d35.00006171460832!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e3!4m5!1s0x6001089572eaf6db%3A0x469c370f6f1f1b0b!2z7J2867O4IOq1kO2GoOu2gCDqtZDthqDsi5wg7Iuc66qo6rWQ6rWsIFRhaW1hdHN1Y2jFjSwg66as6rCAIOuhnOyWhCDtmLjthZQg6rWQ7Yag!3m2!1d34.986385299999995!2d135.75269509999998!4m5!1s0x600108e5187cc88d%3A0x75bed992d897454f!2z7Zek7J207JWIIOyLoOq2gSA5NyBPa2F6YWtpIE5pc2hpdGVubm9jaG8sIFNha3lvIFdhcmQsIEt5b3RvLCA2MDYtODM0MSDsnbzrs7g!3m2!1d35.0159823!2d135.7824263!5e0!3m2!1sko!2skr!4v1696991979225!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;둘째 날의 첫 번째 일정은 헤이안 신궁이었습니다. 헤이안 신궁의 장점은 지하철로 갈 수 있다는 것입니다. 저는 가급적이면 버스의 이용을 최소화하고 싶었기 때문에, 헤이안 신궁을 첫 일정으로 잡고, 그 주변의 관광지를 하나씩 방문해보기로 했습니다. 교토역에서 버스로는 40분이 넘게 걸리지만, 지하철로는 20분 정도면 도착합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/005.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/006.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/007.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지하철 역에서 헤이안 신궁까지는 5분 정도 걸어야합니다. 그런데 가는 길이 산책로처럼 잘 정비되어 있어서 오히려 좋았습니다. 길 옆에는 맑은 시냇물이 흐르고, 조그마한 신사도 있었기 때문에 주변 구경만으로도 충분히 즐거웠습니다. 나중에 느낀 거지만 헤이안 신궁 자체보다 가는 길이 더 재밌었던 것 같네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/008.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;헤이안 신궁에 거의 도착하자 거대한 토리이가 보입니다. 구글 지도상에는 &lt;strong&gt;헤이안 신궁 오도리이(平安神宮 大鳥居)&lt;/strong&gt;라고 나와있네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/009.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가는 길에 조그만 하천을 건너게 되는데, 여기서 보는 경치도 꽤 괜찮았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/010.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽에는 교토국립근대미술관이 있습니다. 미술에는 딱히 관심이 없어서 그냥 지나갔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/011.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;헤이안 신궁 입구에 도착했습니다. 여기는 다행히 입장료를 받진 않네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/012.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다만 입구에 들어서니 무슨 행사가 열리는지, 방송용 장비와 의자가 곳곳에 설치되어 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/013.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;헤이안 신궁 내부에는 정원으로 들어가는 입구가 따로 있습니다. 신궁 자체는 입장료를 받진 않았지만, 정원에 들어가려면 입장료를 내야 하더라구요. 정원의 크기는 꽤 크긴 했지만, 여기에 600엔을 쓰기는 뭔가 아까워서 그냥 신궁만 구경하고 돌아가기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/014.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;신궁 내에서 가장 신기했던 것은 바로 이 나무였습니다. 멀리서 봤을 때는 나무에 흰 꽃이 핀 줄 알았는데요, 가까이서 보니 오미쿠지를 꽃 모양으로 예쁘게 달아놓은 것이었습니다. 보통 오미쿠지에서 나쁜 점괘가 나왔을 때 이렇게 묶어두는데, 나뭇가지에 꽃처럼 묶어놓은 것은 처음봐서 신기했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/015.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;헤이안 신궁을 둘러보고 나오는 길에 포스터를 보니 방송용 장비가 있었던 이유를 알 수 있었습니다. 여기서 유명한 가수들의 공연이 열리고 있나 봅니다. Aimer는 저도 알고 있는 가수인데 나머지 분들은 누군지 모르겠네요.&lt;/p&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d1633.849888018722!2d135.77900141193354!3d35.014219800000006!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x600108e592155555%3A0xf11f45ffb597231d!2sStarbucks%20Coffee%20-%20Kyoto%20Okazaki%20Tsutaya%20Books!5e0!3m2!1sko!2skr!4v1696997402300!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/016.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 관광지로 이동하기 전에 좀 쉬고 싶어서 스타벅스에 들어갔습니다. 여긴 특이하게 서점과 같이 운영을 하는 것 같더라구요. 카페 내에 판매용 책이 같이 전시되어 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/017.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 사랑하는 아메리카노를 주문했습니다. 일본에서는 아메리카노를 주문하는 사람이 없던데 대체 뭘 마시는 걸까요? 갑자기 궁금해지네요.&lt;/p&gt;

&lt;h2 id=&quot;난젠지남선사&quot;&gt;난젠지(남선사)&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d3267.729475968648!2d135.78588027640205!3d35.01347646636548!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x600108e5187cc88d%3A0x75bed992d897454f!2z7J2867O4IEt5b3RvLCBLeW90bywgU2FreW8gV2FyZCwgT2themFraSBOaXNoaXRlbm7FjWNoxY0sIDk3IO2XpOydtOyViCDsi6DqtoE!3m2!1d35.0159823!2d135.7824263!4m5!1s0x600109217397fbfd%3A0x38b339a4c7e7004d!2z64Ko7ISg7IKsICjrgpzsoKDsp4ApIDg2IE5hbnplbmppIEZ1a3VjaGljaG8sIFNha3lvIFdhcmQsIEt5b3RvLCA2MDYtODQzNSDsnbzrs7g!3m2!1d35.0114138!2d135.7944841!5e0!3m2!1sko!2skr!4v1696998951381!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;다음 방문하려고 한 곳은 난젠지(남선사)입니다. 지도상으로 약간 거리가 있긴 하지만, 대중교통이 따로 있는 것은 아니라 경치를 감상할 겸 걸어가기로 했습니다. 헤이안 신궁부터 난젠지까지는 도보로 약 20분 정도가 소요됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/018.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/019.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/020.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가는 길에는 난젠지로 가는 방향을 알려주는 표지판이 있습니다. 한국어로도 적혀있기 때문에 찾는데 어렵지는 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/021.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;난젠지의 입구는 생각보다 심플합니다. 여기도 입구에서 입장료를 받지는 않네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/022.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;입구에는 난젠지 내부의 조감도가 나와 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/023.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/024.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;난젠지에 들어가면 두 개의 큰 건물이 바로 눈에 보입니다. 각각 사진을 찍어봤는데, 어제와 달리 하늘이 맑아서 너무 보기 좋네요!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/025.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/026.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/027.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/028.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/029.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/030.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/031.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/032.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/033.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;난젠지도 절 자체의 입장료는 따로 없지만, 내부 정원을 구경하려면 입장료 500엔을 내야 합니다. 여기는 이게 메인이라는 소리를 들어서, 아깝지만 입장료를 내고 들어왔는데, 정원이 굉장히 아름다웠습니다. 다른 절과는 다르게 입장료가 아깝지 않을 정도로 넓고 볼 게 많았어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/034.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/035.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;관람이 끝나고 나오는 길에 불상을 봤는데, 여기도 보자기를 두르고 있네요.&lt;/p&gt;

&lt;h2 id=&quot;히가시야마-고등학교&quot;&gt;히가시야마 고등학교&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d1943.0126161766173!2d135.79203238659758!3d35.013095745621925!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60010921f2437d55%3A0x44d3a35bf27c7d79!2z7Z6I6rCA7Iuc7JW866eI6rOg65Ox7ZWZ6rWQ!5e0!3m2!1sko!2skr!4v1697004118996!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/036.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왜 갑자기 뜬금없이 고등학교를 방문하게 되었냐면, 난젠지 관광을 마치고 철학의 길로 가는 도중에 이 학교 정문을 지나치게 되었습니다. 그런데 마침 학교의 축제날인지, 외부인도 들어올 수 있다며 몇몇 고등학생이 호객(?)을 하더라구요. 평소라면 고등학교는 외부인이 출입할 수 없는데, 이 때가 아니면 언제 들어가보나 싶어 들어가보았습니다. 애니에서만 나오던 일본 고등학교 축제의 모습이 궁금하기도 했구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/037.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 히가시야마 고등학교는 생각보다 학교가 크고, 사람이 굉장히 많아서 발 디딜틈도 없었습니다. 마침 점심시간이라 야키소바를 하나 사먹어볼까 했는데, 기다리는 줄도 너무 길고 현금이 아니라 어디서 쿠폰을 사서 바꿔와야 한다는 말을 듣고 그냥 포기했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/038.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;학교 건물을 돌아다니면 구경하다가 큰 소리가 나길래 창문을 통해 내려다보니 무대에서 뭔가 공연을 하는 것 같았습니다. 학생들이 단체로 반티를 맞춰입고 뭔가 하는걸 보니 재밌네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/039.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일본 고등학교는 다양한 동아리 활동이 있는 걸로 유명한데, 그래서 그런지 축제날 건물에 각각의 동아리 현수막이 걸려있더라구요. 사진에서는 탁구부, 테니스부, 축구부, 검도부 등이 보이네요.&lt;/p&gt;

&lt;h2 id=&quot;cafe-喫茶-はく&quot;&gt;Cafe 喫茶 はく&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d1155.2948395761532!2d135.79341053424773!3d35.01503356626404!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001091f157185f7%3A0xe95c1014ca9370ef!2sCafe!5e0!3m2!1sko!2skr!4v1697004606929!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/040.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;돌아보다가 어느 덧 점심시간이 되어 점심을 먹고 이동하기로 했습니다. 구글 지도를 보니 일본식 경양식당이 있길래 여길 찾아갔는데, 장사를 하는 중이었지만 1인 손님은 받지 않는다고 해서 그냥 나왔습니다. 아니 일본에서 1인 손님을 받지 않는 식당이 다 있네요? 거참…&lt;/p&gt;

&lt;h2 id=&quot;철학의-길&quot;&gt;철학의 길&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3267.4105620016207!2d135.79171987640225!3d35.02145756593403!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x60010908ae94f057%3A0x917af331a75280f4!2z7LKg7ZWZ7J2YIOq4uA!5e0!3m2!1sko!2skr!4v1697005302039!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/041.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가급적이면 철학의 길을 구경하기 전에 점심을 먹고 싶었습니다만, 근처에서 식사를 할 만한 마땅한 식당이 없었습니다. 정확히는 식당이 있긴 했는데, 이상하게 철학의 길 주변 식당은 전부 양식당이더라구요. 뭔가 여기까지 와서 햄버거/샌드위치/소시지 같은 것을 먹고 싶지는 않아서 배고픔을 참고 먼저 구경하기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/042.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/043.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사실 여기 오기 전에 철학의 길은 들어보기만 했지 어떤 곳인지 찾아보질 않았습니다. 그래도 나름 이름 있는 곳이라 뭔가 볼 게 있을 줄 알았는데… 그냥 단순한 산책로더라구요. 벚꽃이 필 시기에 오면 정말 예쁘다고 하는데, 저는 가을에 가서 그런지 그냥 나무로 둘러싸인 길이었습니다. 솔직히 말씀드리면 철학의 길 들어서고 나서도 이게 철학의 길인지 모르고 돌아다니다가 구글 지도를 보고 나서야 내가 철학의 길에 있는 거구나 라고 알 정도였습니다.&lt;/p&gt;

&lt;h2 id=&quot;호넨인법연원&quot;&gt;호넨인(법연원)&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d1633.6910626971023!2d135.79442953893704!3d35.022169139744555!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x60010908ae94f057%3A0x917af331a75280f4!2z7LKg7ZWZ7J2YIOq4uCDlk7Llrabjga7pgZM!3m2!1d35.021453199999996!2d135.7942948!4m5!1s0x6001091ada6f787d%3A0x62ef00e72d5d2003!2z67KV7Jew7JuQICjtmLjrhKjsnbgpIO-8k--8kOeVquWcsCBTaGlzaGlnYXRhbmkgR29zaG9ub2RhbmNobywgU2FreW8gV2FyZCwgS3lvdG8sIDYwNi04NDIyIOydvOuzuA!3m2!1d35.0240638!2d135.79732289999998!5e0!3m2!1sko!2skr!4v1697006094601!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/044.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;철학의 길에서 느꼈던 허무함을 뒤로 하고 바로 다음 장소로 이동했습니다. 철학의 길에서 5분 정도만 걸으면 바로 호넨인이라는 절이 나옵니다. 제발 가는 길에 식당이 있길 하고 기도했지만, 안타깝게도 근처는 주택가라 식당이 전혀 없었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/045.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호넨인을 가리키는 표지판과 멋진 차가 있어서 한번 찍어봤습니다. 뭔가 차가 굉장히 비싸보이는데 어떤 차인지 아시는 분은 댓글 남겨주시기 바랍니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/046.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호넨인 가는 길에 또 조그만 불당을 봤는데, 여기도 천으로 감싸놓았네요. 이쯤 되면 저 천의 의미가 궁금해지기 시작했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/047.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호넨인을 알리는 비석입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/048.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/049.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호넨인 입구에는 대나무로 만든 울타리가 있습니다. 아라시야마만큼은 아니지만, 여기도 대나무가 꽤 많이 있더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/050.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호넨인은 언덕 위에 있어서 길이 약간 경사져있습니다. 그다지 길지 않아서 노인들도 어렵지 않게 올라가더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/051.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/052.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/053.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/054.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/055.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/056.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호넨인은 입장료가 전혀 없었습니다. 헤이안 신궁이나 난젠지의 정원처럼 입장료를 내고 들어가는 곳도 따로 없었습니다. 이 점은 매우 마음에 들었습니다. 절의 크기도 적당하고, 생각보다 관리가 잘 되어 있어서 볼 것도 많았습니다. 그런데 구글 지도에 표시가 되어있을 정도로 꽤 유명한 절인데, 사람이 별로 없더라구요. 교토의 유명한 관광지는 사람이 바글바글해서 문화재보다 사람 구경을 더 많이 하게 되는데, 그런게 싫으신 분들에게는 딱 좋은 곳 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;지쇼지로-가는-길&quot;&gt;지쇼지로 가는 길&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d1633.6289512846095!2d135.79595953893704!3d35.025277439660854!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x6001091ada6f787d%3A0x62ef00e72d5d2003!2z67KV7Jew7JuQICjtmLjrhKjsnbgpIO-8k--8kOeVquWcsCBTaGlzaGlnYXRhbmkgR29zaG9ub2RhbmNobywgU2FreW8gV2FyZCwgS3lvdG8sIDYwNi04NDIyIOydvOuzuA!3m2!1d35.0240638!2d135.79732289999998!4m5!1s0x600109050b426fe1%3A0x258aca1ce888abc9!2z7KeA7Ie87KeAIOadseWxseaFiOeFp-Wvug!3m2!1d35.0270213!2d135.7982058!5e0!3m2!1sko!2skr!4v1697006571095!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/057.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 남은 곳은 지쇼지 뿐입니다. 그런데 벌써 점심시간이 훌쩍 지난 시간이라 배가 너무 고프더라구요. 지쇼지까지 가는 길에 식당이 있길 바랬지만, 어림도 없었습니다. 그래서 지쇼지 주변 식당에서 점심을 먹기로 정했습니다.&lt;/p&gt;

&lt;h2 id=&quot;miyoneshi-fumiya&quot;&gt;Miyoneshi Fumiya&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d343.4203704378425!2d135.79661830367348!3d35.02713692941195!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001090447c8600d%3A0x5dc0eca14ee5c373!2sMiyoneshi%20Fumiya!5e0!3m2!1sko!2skr!4v1697006678505!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/058.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지쇼지 앞에는 역시 상점가가 있었습니다. 대부분 아이스크림이나 케이크 같은 간단한 다과를 파는 곳이었지만, 눈에 들어온 일식당이 하나 있어서 그 곳으로 들어갔습니다. 구글 지도에서 평점도 나름 괜찮았기 때문에 믿고 들어갔는데요…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/059.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사진에서 보고 있는 교토식 점심을 먹었습니다. 이 식판을 받고 만감이 교차하더라구요. 이게 가격이라도 싸면 모르겠는데, 무려 1250엔짜리 식사입니다. 그런데 밥, 국, 매실절임, 장어 3조각, 이상한 샐러드, 날계란(+간장)이 끝입니다. 관광지 부근 식당이라서 어느 정도 바가지쓸 것은 예상하고 있었는데, 예상보다 심각하네요. 심지어 맛도 없었습니다. 관광객 등쳐먹는건 한국이나 일본이나 똑같네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/060.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부실한 식사를 마치고 지쇼지로 가는 길에 라무네를 파는 가게가 있어서 하나 구매해봤습니다. 라무네는 예전부터 한번 꼭 먹어보고 싶었던 건데, 의외로 파는 곳이 없어서 사기가 힘들더라구요. 마치 한국에서 불량식품 가게를 찾는 거랑 비슷한 걸까요? 가격이 200엔으로 싸지는 않았지만, 그래도 이 때가 아니면 언제 먹어볼까 싶어서 사먹었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/061.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;라무네는 뚜껑에 달려 있는 구슬로 유명한데, 저 구슬을 안으로 누르면 구슬이 안으로 들어가면서 탄산이 확 터지는 구조입니다. 맛은 사이다, 밀키스랑 비슷합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/062.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다 마시고 나면 이렇게 병 안에 구슬이 남아 있습니다. 다 마시고 병 안에서 흔들리는 구슬을 보니 꺼내고 싶어지는 마음이 이해가 가네요. 유튜브에 보면 이 구슬을 꺼내기 위핸 많은 시도(?)를 볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;지쇼지은각사&quot;&gt;지쇼지(은각사)&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d686.8414781408744!2d135.79755809729173!3d35.02704918362156!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x600109050b426fe1%3A0x258aca1ce888abc9!2z7KeA7Ie87KeA!5e0!3m2!1sko!2skr!4v1697008026196!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/063.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오늘 마지막으로 볼 관광지는 지쇼지입니다. 원래 이름은 지쇼지이지만, 교토의 다른 유명한 절인 금각사랑 대비하여 은각사(긴가쿠지)로 부르기도 합니다. 교토의 대표 관광지 답게, 입구부터 많은 사람이 보였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/064.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지쇼지는 아쉽게도 입장료가 필요했습니다. 입장료는 일본 관광지 국룰인 500엔입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/065.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지쇼지의 입장권은 특이하게 부적 모양이더라구요. 다른 관광객들도 입장권의 모양이 신기한지 사진을 찍고 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/066.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/067.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/068.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/069.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/070.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지쇼지는 굉장히 넓었지만, 관광 코스가 정해져 있어서 길을 헤멜 걱정은 없었습니다. 다만 중간에 산을 타는 코스가 있는데, 길이 일방통행이라 되돌아갈 수 없으니 이 점만 조심하면 됩니다. 산이라고 해도 그렇게 높지 않기 때문에 어린아이도 충분히 오를만합니다만, 주변에 있던 나이 많은 관광객분들은 조금 힘들어했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/071.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/072.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중간에 소원을 비는 웅덩이가 하나 있었습니다. 1엔짜리 동전이 가득 있더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/073.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/074.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기도 호넨인처럼 대나무가 우거진 곳이 있었습니다. 교토에는 대나무가 많이 자라나보네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/075.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/076.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일본은 관광지마다 물이 맑고 초목이 아름답게 우거져있는게 좋아요. 잡초가 아니라 잘 정돈된 느낌이 들어서요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/077.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전에 말씀드린대로 중간에 조그만 산을 올라가는데, 거기에서 아래를 내려다본 모습입니다. 실제로 보면 경치가 아주 장관입니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/078.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;나무가 재미있는 모양으로 자라있네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/079.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/080.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사진에 나온 건물이 관음전이라고 합니다. 관음전의 크기가 크지 않아서 그런지 내부 구경은 할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/081.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일본 절에는 이렇게 맑은 물이 흐르는 조그만 그릇이 있던데 어떤 의미일까요?&lt;/p&gt;

&lt;h2 id=&quot;교토대학으로-가는-길&quot;&gt;교토대학으로 가는 길&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d6534.481139084603!2d135.78328894691847!3d35.02571112702911!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x600109050b426fe1%3A0x258aca1ce888abc9!2z7KeA7Ie87KeAIOadseWxseaFiOeFp-Wvug!3m2!1d35.0270213!2d135.7982058!4m5!1s0x6001085604662fa3%3A0xfb44d5e11d926fb1!2sKyoto%20University%20Yoshida%20Residence%2C%2069%20Yoshidakonoecho%2C%20Sakyo%20Ward%2C%20Kyoto%2C%20606-8315%20%EC%9D%BC%EB%B3%B8!3m2!1d35.022399799999995!2d135.77945979999998!5e0!3m2!1sko!2skr!4v1697009730263!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;지쇼지까지 다 보니 오늘 관광하기로 한 곳은 전부 둘러봤습니다. 다만 이 때가 아직 오후 3시 정도라 시간이 많이 남은 관계로 한 곳을 더 둘러보기로 결정했습니다. 일반적인 관광지는 아니고, 교토대학의 요시다 기숙사라는 곳을 방문해보기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/082.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;날씨가 덥다보니 가는 길에 아이스크림을 하나 사먹었습니다. 관광지 근처에서는 아이스크림 하나에 400엔에 팔던데, 조금만 밖으로 나오니 200엔에 파는 곳이 나오더라구요. 역시 관광지 앞에서는 뭘 사먹으면 안됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/083.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아이스크림을 먹으면서 한적한 교토 시내를 걷는 것도 재밌네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/084.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지나가다가 본 불당입니다. 이런식으로 전혀 예상치 못한 곳에 있는 조그마한 불당을 보는 재미가 있어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/085.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역시 지나가다가 본 놀이터인데, 뭔가 엄청 위험해보입니다. 마치 공사장 같은 느낌이 나네요…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/086.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가는 길에 요시다 신사라는 곳이 나왔습니다. 하지만 오늘 신사는 볼 만큼 충분히 본 것 같아서 그냥 지나갔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/087.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;교토 대학 근처로 가니 슬슬 멋진 건물들이 하나씩 보였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/088.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기가 교토 대학 입구인 것 같네요.&lt;/p&gt;

&lt;h2 id=&quot;교토-대학-요시다-기숙사&quot;&gt;교토 대학 요시다 기숙사&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d6534.541742620179!2d135.77693609398696!3d35.02495294745182!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001085604662fa3%3A0xfb44d5e11d926fb1!2sKyoto%20University%20Yoshida%20Residence!5e0!3m2!1sko!2skr!4v1697010587213!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;사실 저는 교토 대학을 보러온 것이 아닙니다. 정확히는 교토 대학의 기숙사 중 하나인 요시다 기숙사를 보러 왔습니다. 왜 하필 기숙사인가라는 생각을 하실 수도 있는데, 이 곳은 외국에서도 굉장히 유명한 관광지(?) 중 하나입니다. 그 이유는 요시다 기숙사에 대한 학교측 입장과 학생측 입장이 달라서입니다. 요시다 기숙사는 1914년 지어졌는데, 워낙 오래되었기 때문에 학교에서는 요시다 기숙사를 철거하고 새 기숙사를 짓고 싶어했습니다. 그런데 학생들은 새 기숙사가 세워지면 기숙사비가 인상될 것이기 때문에 이를 반대하고 나섰는데, 지금까지 학생들은 기숙사를 점거하면서 시위하고 있습니다. 기존 월세는 약 1만 2천엔 정도였다는데, 새 기숙사는 5만엔 정도의 월세를 받고 있기 때문입니다. 학생들은 가난한 학생들도 공부를 할 수 있어야한다는 입장입니다.&lt;/p&gt;

&lt;p&gt;원래라면 관광객들도 요시다 기숙사 내부 관람이 가능했으나, 현재는 신청을 통해서만 내부 관광이 가능하다고 합니다. 또한 실제 학생들이 거주하고 있는 공간인 만큼, 내부에서의 사진 촬영은 불가능하다고 합니다. 저는 신청 방법을 몰라 그냥 외부만 구경하고 왔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/089.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;입구부터 시위용 간판이 눈에 들어옵니다. 대충 해석하자면 10월 5일에 요시다 기숙사의 명도 소송이 있기 때문에 전부 결집하자! 라는 의미로 보입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/090.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요시다 기숙사의 간판인데 딱 보기에도 엄청 허름해보입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/091.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/092.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요시다 기숙사를 들어와보고 나니 왜 학교측에서 이 기숙사를 철거하고싶은지 단박에 이해가 갔습니다. 일단 현재 학교측에서 이 기숙사에 대한 지원을 끊었기 때문에 관리가 전혀 되고 있지 않습니다. 무성하게 자란 잡초, 아무데나 널부러진 생활 쓰레기, 그리고 마치 노숙자 쉼터에 온 것 같은 악취가 풍겨왔습니다. 이쯤 되면 내부 관광 신청을 하지 않은게 다행이다 싶을 정도였습니다. 실제로 아직도 사람이 살고 있는 것인지, 제가 관광하는 도중에 건물에서 런닝 차림의 대학생이 나와서 돌아다니더라구요…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/093.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 밤에는 이 기숙사가 클럽(?) 용도로 사용하고 있는지 생맥주를 팔고 있더라구요. 심지어 이렇게 허름한데 1잔에 400엔으로 싸지도 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/094.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문앞에 보이는 곳이 학생회관인지, 몇몇 학생들이 들락거리는 모습이 보였습니다. 외부에서 살짝 보니 안쪽도 상당히 지저분하더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/095.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;건물 뒷편에는 마치 폐가처럼 잡초가 무성하게 자라있었습니다. 예전에는 여기에서 닭도 키웠다는데, 제가 갔을 당시에는 아무것도 없었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/096.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;교토 대학이 학생운동으로 굉장히 유명하다던데, 그래서 그런지 시위용 간판이 캠퍼스 근처에 엄청나게 많이 보였습니다.&lt;/p&gt;

&lt;p&gt;이렇게 이 날 관광을 끝내고 호텔로 돌아가서 휴식을 취했습니다.&lt;/p&gt;

&lt;h2 id=&quot;저녁식사&quot;&gt;저녁식사&lt;/h2&gt;

&lt;p&gt;원래 저녁은 6~7시쯤 이자카야서 천천히 즐길 예정이었습니다만, 점심을 워낙 부실하게 먹어서인지 5시인데도 배고파서 죽을 정도가 되었습니다. 그래서 간단하게라도 식사를 하기 위해 호텔 주변에 음식점이 있나 돌아다녀봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/097.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오후 5시쯤 되니 주변이 어둑어둑해지면서 노을이 졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/098.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;근데… 아무리 돌아다녀도 식당을 찾을 수가 없었습니다! 호텔 주변에 한 개쯤은 있을 법한데… 편의점 3개를 발견하는 동안 식당이 하나도 눈에 들어오질 않더라구요. 한참을 돌아다니다가 드디어 식당을 하나 발견했습니다.&lt;/p&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d817.1728461950513!2d135.74970456194646!3d34.98939424303245!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001061e8192f91f%3A0x7d145ae2933795bc!2sSun%20Beam!5e0!3m2!1sko!2skr!4v1697013013980!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/099.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 찾은 식당은 카레를 전문으로 팔던 식당이었습니다. 전 카레를 별로 좋아하진 않지만, 일본 카레는 한국과 좀 다르기도 하고, 카레 전문점인만큼 평소 알던 카레와 많이 다르지 않을까 싶어 기대했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/100.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메뉴는 여러 가지 종류가 있었습니다만, 식당에서 추천하는 메뉴는 햄버그 카레였습니다. 처음 방문하는 가게이다보니 식당 추천 메뉴를 그대로 주문했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/101.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 식사를 받고 마음 속에서 탄식이 흘러나왔습니다. 마치 개밥과 같은 비주얼 뿐만 아니라, 카레도 레토르트 제품을 데워 나온 듯한 맛에 매우 큰 실망을 했습니다. 제가 교토에서 먹었던 최악의 음식 1위입니다. 2위는 오늘 낮에 먹은 일본식 점심이구요. 오늘은 뭔가 운이 따르지 않는 날인가 봅니다.&lt;/p&gt;

&lt;h2 id=&quot;tachinomi-inaseya&quot;&gt;Tachinomi Inaseya&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3887.2064173594304!2d135.75454733746827!3d34.988228282962375!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x600108a6205cf385%3A0x2f567a622f927bd9!2sTachinomi%20Inaseya!5e0!3m2!1sko!2skr!4v1697013250521!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;불만족스러운 저녁식사 후, 숙소에서 잠시 쉬다가 술을 한잔 하러 밖으로 나왔습니다. 호텔 주변에 평이 좋은 타치노미가 있더라구요. 타치노미는 “서서 마시는 곳”이라는 의미인데, 말 그대로 가게에 의자가 없고 서서 마셔야 합니다. 하루 종일 걸어다녀서 서있는게 조금 힘들긴 하지만, 보통 이런 타치노미는 값이 매우 싸고, 안주가 맛있는 경우가 많기 때문에 한 번쯤은 가볼만한 합니다.&lt;/p&gt;

&lt;p&gt;저녁 9시쯤 방문해보니 이미 가게에는 사람이 거의 가득 차 있었습니다. 그래서 하필 저한테는 구석 자리를 주더라구요. 구석에서 혼자 술마시면 참 처량하기 그지 없는데, 이미 가게에 들어온 이상 다시 나갈 수는 없지요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/102.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/103.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;신기한 것은 제가 한국인이라고 말한 적도 없는데 종업원이 제 말투를 보고 한국인임을 알았는지 한국어 메뉴판을 갖다주더라구요. 신기했습니다. 한국인도 많이 방문하는 가게인가 봅니다. 지금까지 해외에서 저를 한국인으로 보는 사람이 없었는데, 솔직히 조금 감동했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/104.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 먼저 시켜본 안주는 니쿠쟈가입니다. 니쿠쟈가는 고기감자조림인데, 일본 가정식으로 유명합니다. 만화나 애니메이션에서도 가끔 나올 정도로 일본에서는 대중적인 요리인데, 의외로 파는 곳이 많지 않아 지난 도쿄 여행때는 못먹어본 음식입니다. 여긴 마침 팔고 있어서 주문해봤습니다. 맛은 예상하던 바로 그 맛이네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/105.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음에 시켜본것은 계란말이입니다. 주변 테이블을 보니 다들 이 메뉴를 시켜서 먹고 있더라구요. 이 가게에는 계란 요리가 유명한 것 같아서 저도 시켜봤습니다. 역시 맛은 예상되는 그 맛입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/106.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/018/107.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 세잔 정도 마시다가 다리가 너무 아파서 호텔로 복귀했습니다. 그냥 잠들기는 조금 아쉬워서 편의점에서 술과 간단한 안주를 사서 들어왔는데, 저 김 맛 감자칩은 별로더라구요. 하지만 케이크는 매우 맛있었습니다!&lt;/p&gt;

&lt;p&gt;이렇게 교토에서 바빴던 두 번째 날이 끝났습니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="travel" /><category term="kyoto" /><summary type="html">교토에서의 첫 아침입니다. 어제는 새벽부터 일어나서 먼 거리를 이동하느라 상당히 지쳤기 때문에 일찍 잠들었습니다. 술도 많이 마셔서 푹 잔 덕분에 오늘부터는 오전부터 바쁘게 돌아다닐 예정입니다.</summary></entry><entry><title type="html">Support for Object-Oriented Programming</title><link href="http://localhost:4000/pl/support-for-object-oriented-programming/" rel="alternate" type="text/html" title="Support for Object-Oriented Programming" /><published>2023-10-06T00:00:00+09:00</published><updated>2023-10-06T00:00:00+09:00</updated><id>http://localhost:4000/pl/support-for-object-oriented-programming</id><content type="html" xml:base="http://localhost:4000/pl/support-for-object-oriented-programming/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;드디어 프로그래밍 언어론의 마지막 장입니다. 이 장은 객체 지향 프로그래밍에 대해 상세하게 알아보겠습니다. 순서대로, 객체 지향 프로그래밍의 기본 개념, 객체 지향 프로그래밍 언어의 사례 연구로써 몇 가지 예시와 함께 C++의 대한 소개, 그리고 객체 지향 프로그래밍의 장점과 단점에 대해 다루어보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번 장의 순서는 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;서론&lt;/li&gt;
  &lt;li&gt;객체 지향 프로그래밍에 대한 기본 개념들
    &lt;ul&gt;
      &lt;li&gt;추상 데이터 타입&lt;/li&gt;
      &lt;li&gt;객체와 메시지 전송&lt;/li&gt;
      &lt;li&gt;클래스와 인스턴스&lt;/li&gt;
      &lt;li&gt;(다중) 상속&lt;/li&gt;
      &lt;li&gt;동적 바인딩과 다형성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체 지향 프로그래밍 언어
    &lt;ul&gt;
      &lt;li&gt;분류&lt;/li&gt;
      &lt;li&gt;C++ 언어를 통한 사례 연구&lt;/li&gt;
      &lt;li&gt;분석&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정리&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림은 2장 프로그래밍 언어의 발전사에 나왔던 그림입니다. 이 중에서 C++, Java, Ada 95는 객체 지향 프로그래밍을 완벽하게 지원하는 언어이고, 그 외의 언어들은 완벽한 객체 지향 프로그래밍을 지원하지는 않지만 영향을 미친 언어들입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2장에서 배웠던 프로그래밍 언어의 패러다임을 다시 정리하겠습니다. 참고로 시간에 따라 정리된 것이 아닙니다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;블록 구조(절차 지향 프로그래밍) : 프로그램은 블록과 프로시저의 중첩된 집합으로 구성되어 있습니다. 1960년대와 1970년대의 주요 패러다임으로 ALGOL, Pascal, PL/I, Ada, Modula 등의 언어가 이 패러다임의 영향을 받았습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;객체 기반(객체 지향 프로그래밍) : 프로그램은 상호작용하는 객체의 집합으로 구성되어 있습니다. 주로 1970년대와 1980년대 유행하였으며, Simula 67, Smalltalk, C++ 등의 언어가 이 패러다임의 영향을 받았습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동시 수행(분산 프로그래밍 패러다임) : 여러 개의 부프로그램이 동시적으로 수행되는 것을 중시합니다. 프로그램은 다중 스레드, 동히과, 통신 등의 기능을 가지고 있습니다. Fork-join, Ada-CSP, Linda 등의 언어가 이 패러다임의 영향을 받았습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수형 프로그래밍 패러다임 : 프로그램은 함수 정의의 집합으로 구성되어 있습니다. LISP, ML, Miranda, Haskel 등의 언어가 이 패러다임의 영향을 받았습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;논리 프로그래밍 패러다임 :  프로그램은 정리(Theorem)라는 해결 원리의 집합으로 구성되어 있습니다. 명확한 의미 체계와, 많은 암시적인 병렬 처리가 특징입니다. Prolog, Parlog, GHC 등의 언어가 이 패러다임의 영향을 받았습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 객체 지향 프로그래밍을 왜 사용하는 것일까요? 다음과 같은 이유가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현실 세계의 문제를 자연스럽게 모델링할 수 있음 (여러 자치적인 요소, 시뮬레이션 시스템)&lt;/li&gt;
  &lt;li&gt;모듈성 (데이터와 프로시저로 구분됨, 문제를 세부 문제로 나눌 수 있음, 정보 은닉)&lt;/li&gt;
  &lt;li&gt;소프트웨어의 재사용성 증가 (상속, 유용한 클래스 라이브러리)&lt;/li&gt;
  &lt;li&gt;병행 (각 객체를 병렬로 실행 가능)&lt;/li&gt;
  &lt;li&gt;단지 새로운 프로그래밍 패러다임이라서!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍이란 개념은 SIMULA 67에서 처음 시작되었습니다. 그러나 완전한 객체 지향 프로그래밍은 1980년 Smalltalk가 만들어지고 나서야 개발되었습니다. 그 때 정립된 객체 지향 프로그래밍은 프로그램이 객체들의 협동적인 집합으로 구성된 구현 방법으로, 각각의 객체는 어떤 클래스의 인스턴스를 나타내고, 그 클래스는 모두 상속 관계를 통해 결합되는 클래스 계층 구조의 구성원으로 정의됩니다.&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍의 패러다임은,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 클래스를 원하는지 결정하기&lt;/li&gt;
  &lt;li&gt;각각의 클래스에 대해 전체 동작의 집합을 제공하기&lt;/li&gt;
  &lt;li&gt;상속을 사용하여 명시적으로 공통점을 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;추상 데이터 타입(Abstract Data Type)&lt;/span&gt;은 11장에서도 다루었지만, 캡슐화와 정보 은닉을 모두 지원하는 데이터 구조입니다.&lt;/p&gt;

&lt;p&gt;데이터와 이것을 조작하는 코드가 함께 정의되고, 각각의 데이터는 연관된 코드와 분리되거나 별도로 접근할 수 없는 것이 캡슐화입니다. 그리고 데이터는 코드 내에 캡슐화되고, 지역화된 프로시저의 집합만 데이터를 직접 조작할 수 있습니다. 캡슐화는 소프트웨어 구성 요소 간의 상호 의존성을 줄여, 시스템의 신뢰성과 수정 가능성을 보장하기 때문에 중요합니다.&lt;/p&gt;

&lt;p&gt;정보 은닉은 프로그램의 구현 및 내부 표현을 고려하면 안 된다는 원칙입니다. 캡슐화는 결국 &lt;strong&gt;방법(How)&lt;/strong&gt;보다 &lt;strong&gt;무엇(What)&lt;/strong&gt;을 강조하는 것입니다. 캡슐화는 프로시저 추상화(서브루틴)과 데이터 추상화(추상 데이터 타입)으로 구분할 수 있습니다.&lt;/p&gt;

&lt;p&gt;추상화는 결국 사람들이 자신이 뭘 하고 있는지 생각하는 데 도움이 되고, 캡슐화는 제한된 노력으로 프로그램의 변경을 신뢰할 수 있게 만듭니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가령 스택을 C 언어와 같은 일반적인 방법으로 구현한 것과, 추상 데이터 타입으로 구현한 것을 비교해봅시다. 오른쪽 같은 경우에는 프로그래머가 스택을 사용하기 위해서 스택이 정의된 배열인 stack과 가장 위를 나타내는 변수인 top을 파악해야 합니다. 또한, 스택의 연산을 수행하기 위해 push, pop, sub1, sub2… 등의 프로시저를 모두 파악하고 있어야 합니다. 그러나 왼쪽과 같이 추상 데이터 타입으로 스택을 구현한다면, 스택의 인터페이스인 push와 pop에 대해서만 신경을 쓰면 되고, 스택을 구현하는 데이터인 stack, top이나 프로시저에 대해 신경을 쓸 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 객체와 메시지 전송에 대해 알아보겠습니다. &lt;span style=&quot;color:red&quot;&gt;객체(Object)&lt;/span&gt;란, 사적 데이터(Private data)와 메소드를 가진 엔티티(Entity)입니다. 객체는 상태라는 인스턴스 변수와 메소드라는 일련의 작업으로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;데이터는 객체로부터 얻을 수 있는데, 객체에게 메시지를 보냄으로써 간접적으로 프로시저를 호출하여 얻습니다. 객체 또한 정적 바인딩과 동적 바인딩으로 구분할 수 있습니다. 객체 지향 프로그래밍의 모든 행동은 객체 간의 메시지 전송에서 비롯되며, 메시지의 선택기는 작업의 종류를 지정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간단한 C++ 코드를 보면서 지난 슬라이드에서 배운 내용을 확인해보겠습니다. 먼저 Person이라는 클래스가 있고, Student 클래스는 Person 클래스로부터 상속을 받았습니다. 두 클래스 모두 사적 데이터(Private data)는 없고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getData()&lt;/code&gt;라는 메소드 하나씩만 보유하고 있습니다.&lt;/p&gt;

&lt;p&gt;main() 함수를 확인해보면, Student 클래스의 객체인 s는 정적으로 메모리에 바인딩 되었습니다. 또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s.getData()&lt;/code&gt;라는 메시지를 통해 s의 메소드를 호출하고 있습니다. Person 클래스의 객체인 p는 포인터를 이용하여 동적으로 메모리에 바인딩하고 있습니다. 이 때, Person 클래스의 객체에 Student의 객체를 할당하지만, Student가 Person의 서브 클래스이기 때문에 이러한 문법은 허용됩니다. p는 포인터 객체이기 때문에 p에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getData()&lt;/code&gt;를 호출할 때는 -&amp;gt;를 이용하여 호출합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 전통적인 프로그래밍과 객체 지향 프로그래밍을 비교해보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 전통적인 프로그래밍은, 데이터와 독립적인 프로시저에 의해 구성되어 있습니다. 함수의 값은 각각의 호출에 대해 정확한 인수를 가져야만 완전히 결정됩니다. 또한, 일반적으로 프로시저는 특정 타입의 데이터에만 적용됩니다.&lt;/p&gt;

&lt;p&gt;그에 반해 객체 지향 프로그래밍은 데이터와 프로시저의 묶음인 객체로 구성되어 있습니다. 객체에 대한 연산이 반환되는 값은 상태와 인수, 그리고 호출 기록에 따라 달라질 수 있습니다. 실행할 올바른 프로시저를 찾는 것은 언어 지원 시스템에서 처리됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 언어에서의 추상 데이터 타입은 일반적으로 &lt;span style=&quot;color:red&quot;&gt;클래스(Class)&lt;/span&gt;라고 불립니다. 클래스는 new나 create와 같은 명령을 통해 객체를 만들 수 있는 템플릿으로써, 구조(인스턴스 변스), 동작(메소드), 그리고 상속(부모)의 명세와 같은 것들을 포함합니다. 객체는 인스턴스화를 통해 클래스에서 생성되는데, 특정 클래스의 객체를 해당 클래스의 인스턴스라고 합니다.&lt;/p&gt;

&lt;p&gt;클래스는 두 가지 종류의 변수를 갖고 있는데, 클래스의 모든 인스턴스에서 값을 공유하는 클래스 변수와 각각의 객체에 별도로 공간이 할당되는 인스턴스 변수가 있습니다. 또한 클래스가 객체인 경우, 클래스에는 메타 클래스라는 클래스가 있어야 합니다. 대표적으로 Python에서는 클래스 자체가 객체가 될 수 있는데, type이라는 명령어를 이용하여 메타 클래스를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 슬라이드에서는 클래스 구성의 예시를 나타내고 있습니다. point라는 클래스에서 인스턴스 변수와 메소드를 정의합니다. 그 후, 이 클래스를 이용한 객체를 생성하는 것은 p1과 p2 처럼 객체 생성 명령어를 사용하여 point 클래스의 객체를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 클래스가 다른 클래스의 상위 클래스인 클래스 간의 관계를 &lt;span style=&quot;color:red&quot;&gt;상속(Inheritance)&lt;/span&gt;이라고 합니다. 상속은 객체 지향 프로그래밍에서 소프트웨어 재사용을 지원합니다. 기반 클래스에서 상태 구조와 명령을 상속하는 기능을 통해, 프로그래머는 기존 객체의 요소 뿐만이 아니라, 기반 클래스의 구성 요소를 수정하고, 추가하여 새로운 객체를 정의할 수 있습니다. 그로 인해 기반 클래스를 토대로 새로운 문제에 맞게 프로그램 조직화 및 전문화가 가능해집니다.&lt;/p&gt;

&lt;p&gt;상속의 구조를 예시로 들면 슬라이드와 같습니다. 포유류라는 기반 클래스를 상속받아 사람과 코끼리는 하위 클래스를 새로 정의하였습니다. 이 들은 분명 다른 클래스이지만 포유류의 특성을 모두 갖고 있습니다. 또한 사람의 하위 클래스로써 학생과 배우라는 직업을 기준으로 분류가 가능하며, 이를 토대로 철수, 영희와 같은 객체를 생성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;구체적으로 상속의 예시를 들어보겠습니다. 먼저 기반 클래스는 year, mon, day라는 인스턴스 변수를 가지고 있는 Date라는 클래스입니다. 이 클래스의 객체는 1993년 9월 10일과 같이 날짜를 표현할 수 있습니다. Date 클래스를 상속받아 Time과 Holiday라는 서브 클래스가 정의되었습니다. Time 클래스에서는 hour, min, sec라는 인스턴스 변수가 새로 정의되어, 기반 클래스가 가지고 있던 인스턴스 변수를 포함해 총 6개의 인스턴스 변수를 갖게 되었습니다. 이로 인해 날짜와 시간을 함께 표시할 수 있는 클래스로 정의되었습니다.&lt;/p&gt;

&lt;p&gt;Holiday 클래스는 name과 country라는 새로운 인스턴스 변수가 정의되었습니다. 이를 토대로, 기반 클래스에서 상속받은 날짜에 국가와 명절 이름을 같이 표기할 수 있는 클래스가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍과 관련된 개념을 보여주는 데이터 구조입니다. 클래스에서는 인스턴스 변수의 개수, 이름 등과 같은 다양한 내용을 저장하고 있습니다. 이 중 메소드 사전(Method Dictionary)라는 것이 있는데, 만약 현재 클래스에서 정의된 메소드라면 이 메소드 사전을 통해 접근하게 됩니다. 만약 기반 클래스에서 정의된 부분이라면 기반 클래스의 메소드를 참조하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클래스는 기반 클래스로부터 인스턴스 변수와 메소드를 상속받습니다. 상속받은 클래스를 주어진 문제에 전문화하기 위해서는 새로운 인스턴스 변수와 새로운 메소드를 정의하는 방법이 있습니다. 또는, 클래스의 변수나 메소드를 재정의할 수도 있습니다. 만약 여러 단계를 걸쳐 상속을 받았다면, 메소드를 호출할 때 어디서 정의된 메소드를 사용할 것인지를 결정해야 합니다. 일반적으로는 가장 가까이 있는 기반 클래스의 메소드를 사용하지만, 때에 따라 다른 메소드를 사용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;상속 구조는 계측정 상속, 위임(Deligation)에 의한 상속, 그리고 다중 상속이 있습니다. 계층적 상속은 클래스가 단일 기반 클래스에서만 상속받는 것을 말합니다. 가장 널리 사용되는 상속으로써 Smalltalk에서 제안된 방법입니다. 간단하고 효율적이지만, 표현력이 제한적이라는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;위임에 의한 상속은 각각의 객체가 처리할 메시지를 처리할 객체를 직접 선택하는 것입니다. 예를 들어, A 클래스에서 create()라는 메소드를 호출하는데, 이 메소드는 다른 클래스에서 정의된 메소드입니다. 이렇게 보면 일반적인 상속과 무엇이 다른가 싶겠지만, 직접적으로 “is-a” 관계가 아닌 경우(ex. 이전 슬라이드의 포유류 - 사람) 위임을 사용하는 것이 바람직합니다. 즉, 두 클래스 간의 종속성을 확립할 필요가 없거나, 그렇게 하면 문제가 생길 경우 위임을 사용한다고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로 다중 상속은, 클래스가 둘 이상의 기반 클래스로부터 상속을 받는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다중 상속에서는 클래스가 모든 기반 클래스로부터 변수와 메소드를 상속받습니다. 만약 상속받은 변수나 메소드에서 충돌이 있는 경우, 클래스 우선 순위 목록을 이용하여 상속의 우선 순위를 결정합니다. 일반적으로 깊이가 더 깊은 클래스를 우선적으로 상속받습니다. (Depth-first-up-to-join)&lt;/p&gt;

&lt;p&gt;상속의 장점으로는 더 나은 개념을 모델링할 수 있다는 것입니다. 오른쪽 그림과 같이 일상적인 것을 직접 모델링할 수 있고, 계층적 모델링을 통해 프로그램을 더 쉽게 이해할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Factorization이라는 단어는 번역하기 참 애매한 단어인데, 공학에서 사용할 때는 보통 인수분해로 해석합니다. 다만 뒤에 나온 설명하고 뭔가 어울리지 않아서 애매하네요. 일단 여기에서는 한 번만 기술하고 필요할 때 재사용하는 장점으로 설명되어 있습니다.&lt;/p&gt;

&lt;p&gt;다음으로는 디자인의 단계적인 개선을 통해 하향식 설계 및 검증에 유용하다는 장점이 있습니다. 마지막으로, 상속은 객체 지향 프로그래밍에서 다형성을 지원하도록 도와줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다중 상속의 예시는 다음과 같습니다. 학생과 배우라는 클래스는 사람이라는 기반 클래스로부터 파생된 클래스입니다. 그런데 학생 클래스는 일을 해라() 라는 메소드가 공부한다고 구현되어 있고, 배우 클래스의 일을해라() 라는 메소드는 TV에 나온다라고 구현이 되어 있습니다. 학생 배우라는 클래스는 학생과 배우로부터 상속받은 클래스입니다. 이 때, 일을해라()라는 메소드는 학생 클래스와 배우 클래스에 모두 존재하는 메소드입니다. 그렇다면 학생 배우 클래스의 인스턴스 객체인 박은빈에서 일을해라()라는 메소드는 어떤 행동을 해야하는가?라는 문제가 발생합니다. 이러한 문제를 죽음의 다이아몬드(Deadly Diamond)라고 하며, C++는 다중 상속을 지원하기 때문에 이러한 문제가 발생하지만, Java는 다중 상속을 지원하지 않기 때문에 이러한 문제가 발생하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍 언어에서는 메시지를 메소드 정의에 언제 바인딩하는지에 따라 &lt;span style=&quot;color:red&quot;&gt;정적 메시지 바인딩(Static Message Binding)&lt;/span&gt;과 &lt;span style=&quot;color:red&quot;&gt;동적 메시지 바인딩(Dynamic Message Binding)&lt;/span&gt;으로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;정적 메시지 바인딩은 객체의 특정 메소드에 대한 메시지 바인딩이 컴파일 타임에 발생하는 것을 말합니다. 이것은 정적 유형 언어에서 사용하는 바인딩 방식입니다. 반대로 동적 메시지 바인딩은 특정 메소드에 대한 메시지 바인딩이 실행 시간에 발생하는 것을 말합니다. 이것은 다형성을 지원하는 강력한 메카니즘으로, 타입이 지정되지 않는 언어에서 사용됩니다.&lt;/p&gt;

&lt;p&gt;이것이 어떤 차이가 있는지는 슬라이드 아래쪽에 나와있습니다. 동적 메시지 바인딩의 경우에는 draw라는 메시지가 호출되었을 때, 이것이 어느 클래스 객체인지에 따라 어떤 메소드에 바인딩될지가 결정됩니다. 그러나 정적 메시지 바인딩의 경우에는 클래스가 shape 하나만 있고, 그 안에서 type에 따라 어떤 기능을 수행할지 달라지는 형태입니다.&lt;/p&gt;

&lt;p&gt;동적 바인딩이 정작 바인딩보다 우수한 점은, 소프트웨어 시스템이 개발과 유지보수 기간 동안 쉽게 확장될 수 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍에서 &lt;span style=&quot;color:red&quot;&gt;다형성(Polymorphism)&lt;/span&gt;이란 둘 이상의 타입, 또는 클래스에서 명령을 수행하는 능력을 말합니다. 다형성은 &lt;strong&gt;애드 혹 다형성(Ad hoc Polymorphism)&lt;/strong&gt;과 &lt;strong&gt;유니버셜 타형성(Universal Polymorphism)&lt;/strong&gt;으로 나뉩니다. 애드 혹 다형성은 강제 변환(Coercion)과 연산자 오버로딩(Operator Overloading)으로 구현됩니다. 유니버셜 다형성은 매개변수 다형성(Parametric Polymorphism)과 포함 다형성(Inclusion Polymorphism)으로 구현됩니다. 각각의 내용을 정리하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;강제 변환 : 연산자나 문맥을 통해 피연산자의 타입을 변경시키는 것&lt;/li&gt;
  &lt;li&gt;연산자 오버로딩 : 피연산자의 타입에 맞춰 같은 연산 기호가 다양한 의미에 대입되는 것&lt;/li&gt;
  &lt;li&gt;매개변수 다형성 : 클래스의 인스턴스 변수나 메소드의 매개변수 타입을 임의의 타입이 아니라 상황에 따라 다양한 타입으로 선언하는 것&lt;/li&gt;
  &lt;li&gt;포함 다형성 : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행하는 명령이 달라지는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍 언어는 다음과 같이 3가지 분류로 나눌 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체 기반 언어(Object-based Language) : 객체를 지원하는 모든 언어의 클래스&lt;/li&gt;
  &lt;li&gt;클래스 기반 언어(Class-based Language) : 모든 객체가 클래스에 속하도록 요구하는 하위 클래스&lt;/li&gt;
  &lt;li&gt;객체 지향 언어(Object-oriented Language) : 상속을 지원하기 위해 클래스가 필요한 하위 클래스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;객체 지향 프로그래밍 언어 중 기존 언어를 확장해 만든 언어는 C++, Objective C, Object Pascal, Object COBOL, CLOS 등이 있고, 처음부터 순수 객체 지향 언어로 디자인된 언어는 Eiffel, Simula, Smalltalk 등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림은 객체 지향 언어와 관련된 언어의 가계도를 나타낸 것입니다. 객체 지향 언어는 파란색으로 표시되어 있고, 객체 기반 언어는 녹색 문의로 표시가 되어 있습니다. 그 외의 언어는 객체 기반 언어나 객체 지향 언어는 아니지만, 그러한 언어들에게 영향을 준 언어들입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 언어에 대한 사례 연구로써 C++ 언어를 살펴보겠습니다. C++ 언어는 1980년 초, 벨 연구소에서 근무하던 Bjarne Stroustrup의 팀이 개발했습니다. C++ 언어는 C 언어를 기반으로 만들어졌는데, C 언어와 호환이 가능한 상위 언어를 목표로 개발되었기 때문에, C++ 컴파일러로도 C 언어로 개발된 프로그램의 컴파일이 가능합니다. C++ 언어는 객체 지향 개념과 클래스, 상속 등이 포함되어 있으며 제네릭 함수, 참조 타입과 같은 다른 고급 기능으로 C 언어를 확장하였습니다. C++ 언언은 가장 널리 사용되는 객체 지향 프로그래밍 언어 중 하나이며, 효율성과 C 언어와의 호환성을 강조하여 설계되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++에서 클래스와 접근 지정자는 데이터 추상화를 지원하고, 서브타입 다형성과 가상 함수를 통해 동적 바인딩을 지원합니다. 또한 이를 포함하여 다중 상속, 가상 기반 클래스 등으로 상속을 지원합니다. 마지막으로 템플릿 함수, 탬플릿 클래스, 그리고 연산자 오버로딩을 통해 다형성을 지원합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터 추상화의 관점에서 C 언어와 C++ 언어를 비교해보겠습니다. 두 코드 모두 스택을 구현한 프로그램 코드입니다. C 언어의 경우에는 스택 본체를 전역 변수 배열로 선언하고, 스택의 각 기능을 함수로 정의하였습니다. 그에 반해 C++ 언어의 경우에는 스택 클래스를 통해 스택의 각 기능을 구현한 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;눈여겨볼 부분은 스택에서 사용되는 변수의 가시성입니다. C 언어에서는 stack 배열과 top이 전역 변수로 선언되어 있기 때문에 main() 함수를 포함한 모든 함수에서 볼 수 있고, 조작이 가능합니다. 이러한 가능성은 프로그래머의 의도와 다르게 해당 변수의 값이 변동될 수 있으므로 프로그램의 신뢰성을 낮추는 문제점이 있습니다. 그에 반해 C++ 언어에서는 이 변수들이 private로 선언되어 있기 때문에, 클래스 내에서만 접근이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연산자 오버로딩은 동일한 기호나 함수 이름이 다른 의미로 사용될 수 있음을 말합니다. C++ 언어에서는 기존 클래스에서 정의된 연산자를 재정의할 수 있습니다. 예를 들어서, 이 슬라이드의 예제에서는 += 연산자를 재정의하고 있습니다. 재정의한 연산자는 두 개의 문자열을 이어붙이는 역할로 변경되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어는 접근 지정자를 통해 각 멤버의 접근을 제한합니다. private로 선언된 멤버는 선언된 클래스의 멤버 함수에서만 접근할 수 있습니다. protected로 선언된 멤버는 파생 클래스에서 접근할 수 있다는 차이점을 제외하면 private와 같습니다. public으로 선언된다면 모든 함수에서 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 상속에서도 접근 지정자를 도입할 수 있습니다. public으로 상속한 클래스는 일반 기반 클래스와 동일하지만, private로 상속한다면 기반 클래스의 멤버가 파생 클래스에서 모두 private로 처리됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;접근 지정자의 예시를 확인해보겠습니다. 왼쪽의 employee 클래스를 상속받은 manager 클래스가 있습니다. manager 클래스는 public으로 상속받았기 때문에 일반적인 상속이 발생합니다. 그런데, employee의 멤버 변수 중 list는 private로 선언되어 있기 때문에 manager 클래스에서 접근할 수 없습니다. protected와 public으로 선언된 나머지 멤버 변수들은 모두 접근이 가능합니다. 만약 manager에서 이 list 변수에 접근하고 싶다면, employee에서 list와 관련된 멤버 함수를 정의하고, 이 멤버 함수를 상속받아 간접적으로 접근하는 수밖에 없습니다.&lt;/p&gt;

&lt;p&gt;오른쪽의 클래스 A, B, C 예제를 확인해보겠습니다. 클래스 C는 클래스 A와 B를 상속받았습니다. 클래스 A와 B 모두 display라는 가상 함수를 가지고 있지만, 매개변수의 타입이 다르기 때문에 죽음의 다이아몬드 문제가 발생하지 않습니다. 따라서 정상적으로 클래스 C에서 이 둘을 각각 정의하여 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어에는 다양한 내장 라이브러리가 존재합니다. 이중 가장 많이 사용했던 것은 MFC 라이브러리인데, 제가 학부를 다닐 때만 해도 학부 실습 시간에 MFC 프로그래밍을 가르쳤습니다. 최근에는 잘 사용하지 않는다는 이유로 빠져있더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어에 대한 평가를 해보겠습니다. C++ 언어의 장점은 캡슐화 및 데이터 추상화 관점에서 신뢰성을 높이고, 구현에서 절차적 사양과 표현적 사항을 분리하는 것이 가능합니다. 또한 C++ 언어는 정적 바인딩이 사용되는지 동적 바인딩이 사용되는지를 명시할 수 있고, 동적 바인딩을 사용하는 경우에는 유연성을 증가시킬 수 있습니다. 또한 상속으로 인해 소프트웨어의 재사용성이 크게 증가합니다.&lt;/p&gt;

&lt;p&gt;단점에 대해 언급해보자면 우선 높은 실행 시간 비용 문제입니다. 장점에서 언급했던 동적 바인딩은 실행 시간에 발생하고, 메시지 전달이 Smalltalk에 비해 1.7배 정도 느리기 때문입니다. 또한 의도와 코드 사이에서 발생하는 의미상의 차이와 소프트웨어 시뮬레이션의 어려움이 있으며, 클래스 라이브러리가 굉장히 많기 때문에 이것을 모두 배우기 어렵다는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/32.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리하자면, 객체 지향 프로그래밍의 요소는 객체, 클래스, 메소드, 메시지, 상속, 동적 바인딩, 다형성 등의 특징을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;객체 기반 언어에 클래스가 추가된 것이 클래스 기반 언어, 그리고 거기에 상속이 추가된 것이 객체 지향 언어입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/33.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어의 주요 개선사항 중 하나는 병렬 처리입니다. 최근 하드웨어는 다수의 CPU를 가지고 있기 때문에 병렬 처리를 수행할 수 있습니다. Java 언어에서는 Thread 클래스를 통해 병렬 처리를 지원하는데, C++도 마찬가지로 Thread, Async, OpenMP 등의 라이브러리를 통해 병렬처리 프로그래밍을 수행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/34.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;본 강의자료의 참고 문헌 목록입니다. 필요하신 분은 참고해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/35.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 강의자료에 많은 내용들은 An Introduction to Object-Oriented Programming를 많이 참고하였습니다.&lt;/p&gt;

&lt;p&gt;12장의 내용은 여기까지입니다. 지금까지 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">교토 여행기 (1)</title><link href="http://localhost:4000/travel/kyoto-1/" rel="alternate" type="text/html" title="교토 여행기 (1)" /><published>2023-10-06T00:00:00+09:00</published><updated>2023-10-06T00:00:00+09:00</updated><id>http://localhost:4000/travel/kyoto-1</id><content type="html" xml:base="http://localhost:4000/travel/kyoto-1/">&lt;p&gt;대학원생은 생각보다 여행할 시간이 많지 않습니다. 그래서 가급적이면 연휴를 활용해야 하는데, 이번에 마침 추석 연휴와 개천절이 연결되어 6일이라는 황금 연휴가 만들어졌습니다. 물론 연휴는 모두가 해외여행을 떠나고 싶어하는 기간이기 때문에 표값도 비싸고, 관광지에 사람이 바글바글 댈 것이라는 예상은 들었지만, 이 기회를 놓치기 너무 아까워서 여행계획을 세웠습니다. 이번에는 5박 6일이라는 약간 애매한 일정이 만들어졌는데, 교토와 그 근교를 둘러보면 적당한 기간일 것으로 생각되어 교토를 방문하기로 결정했습니다. 이 기간의 비행기값만 70만원 가까이 나왔지만, 눈물을 머금고 예약했습니다.&lt;/p&gt;

&lt;h2 id=&quot;교토까지-이동&quot;&gt;교토까지 이동&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/01.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오전 8시 비행기였기 때문에 새벽부터 집에서 나왔습니다. 이 때 안 사실인데, 의외로 김포공항은 새벽에 리무진 버스가 다니지 않습니다. 그래서 지하철이나 버스 같은 대중교통을 이용해야하는데, 첫 지하철이 5시 45분이었기 때문에 이걸 타고 가면 너무 늦을 것 같았습니다. 그래서 새벽 5시 쯤에 있는 시내버스를 타고 서울역에 간 다음, 서울역에서 공항철도를 타고 김포공항을 가기로 결정했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/02.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;무사히 시내버스를 탔는데, 버스에 타니 최근 오픈한 트릭컬 광고가 보이더라구요. 예전에 한창 광고하다가 다시 섭종한 것으로 아는데, 찾아보니 이 날부터 다시 서비스를 개시했다고 들었습니다. 이렇게 대대적으로 광고할 정도로 이번에는 꽤 큰 마음을 먹은 것 같습니다. 어떻게 될지 궁금하네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/03.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새벽의 서울역은 굉장히 을씨년스러운 분위기였습니다. 서울역 안쪽은 아주 밝아보이는데, 주변에 전부 어두워서 미묘한 분위기가 느껴지네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/04.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;열차 시간에 딱 맞게 도착해서 다행히 김포공항에 일찍 도착했습니다. 지난 번에 도쿄를 갔을 때도 김포공항으로 갔는데, 그 때는 사람이 굉장히 없어서 널널했습니다. 그런데 역시 명절 연휴라 그런지 사람이 아주 바글바글하더라구요. 김포가 이정도면 인천은 얼마나 심할지 상상이 되질 않네요. 체크인까지 시간도 김포치고 굉장히 오래 걸렸습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/05.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;체크인과 수하물을 맡기고 터미널 안으로 들어왔습니다. 어느덧 시간이 흘러 해가 밝아오네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/06.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 타고 갈 비행기입니다. 이번에도 역시 아시아나로 예약했어요. 딱히 아시아나를 좋아하는 것은 아닌데, LCC는 특가를 못잡으면 사실상 아시아나랑 크게 차이가 나지 않아서 그냥 아시아나로 예약하는게 마음이 편하더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/07.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비행기를 타고 이륙한 다음 한 컷을 찍어봤습니다. 제가 탄 자리가 날개 부분이라 그런지 정면에 날개가 눈에 들어오네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/08.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/09.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이륙하고 잠시 뒤에 기내식을 받았는데, 지난번 나고야를 갔을 때와 비교하면 상당히 초라합니다. 그 때는 메인 메뉴 뿐만 아니라 빵과 과일 같은 것도 같이 줬는데, 이번에는 달랑 메인 메뉴 하나네요. 메인 메뉴도 지난번과 비교하면 맛이 상당히 별로였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/10.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 진짜 지옥은 간사이 공항에서 발생했습니다. 공항이 어느 정도 혼잡할 것은 예상하고 있었지만, 생각보다 혼잡도가 정말 엄청났습니다. 간시아 공항에서 입국수속을 하는데만 1시간이 넘게 걸렸습니다. 이 대기시간이 어느 정도냐면, 탑승객들이 직접 수하물을 찾으면 다음 비행기의 수하물과 섞이기 때문에 사진처럼 직원들이 수하물을 전부 따로 빼놓을 정도입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/11.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어찌어찌 간사이 공항에 입국수속을 마쳤습니다만, 아직 지옥은 끝나지 않았습니다. 왜냐하면 여기서 교토로 가려면 특급열차 하루카를 타야하기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/12.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간사이 공항에서 하루카를 타기 위해서는 2층에 있는 간사이 공항역으로 가야합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/13.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 번째 지옥은 바로 여기서 발생합니다. 하루카는 현지에서 구매하는 것보다 한국에서 미리 e-티켓을 구매하는 것이 훨씬 저렴한데, e-티켓을 실제 하루카 티켓과 교환하려면 여기서 직접 교환해야하기 때문입니다. 기계는 꼴랑 4대인데, 여기에 간사이 공항으로 온 수많은 사람들이 티켓을 교환하려고 줄을 서 있습니다. 이걸 기다리는데 또 1시간이 걸립니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/14.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어찌어찌 표를 교환했습니다. 하루카는 기본적으로 자유석인데, 그 자리에서 지정석으로 바로 교환할 수도 있습니다. 자유석은 자리가 없을 수도 있기 때문에 시간만 맞으면 지정석으로 교환하는 것이 좋습니다. (추가요금이 없습니다!) 간사이 공항에서 교토까지는 1시간 30분 정도 걸리기 때문에 서서가면 꽤 고통스럽기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/15.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하루카는 듣던대로 열차가 헬로키티로 도장되어 있기 때문에 굉장히 눈에 띕니다. 지정석은 보통 열차 1~2번째 칸이고, 나머지는 자유석으로 운영됩니다.&lt;/p&gt;

&lt;h2 id=&quot;교토역&quot;&gt;교토역&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/16.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어찌어찌 간신히 교토 역에 도착했습니다. 간사이 공항에 도착한게 오전 10시쯤이었는데, 교토 역에 도착할 때 시간은 어느덧 2시를 향해 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/17.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/18.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;교토 역은 굉장히 많은 열차가 다니기 때문에 매우 혼잡합니다. 제가 탔던 하루카 뿐만이 아니라 대부분의 간사이권 JR선이 교토 역을 지나가기 때문에, 역 안내소에는 항상 사람이 많이 보였습니다. 교토 시에서는 교토 역을 하나의 문화공간으로 만드려고 하는지, 교토 역 안에는 무대를 포함한 여가시설이 상당히 많이 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/19.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 시간까지 기내식만 하나 달랑 먹었었기 때문에 상당히 배가 고픈 상태였습니다. 교토역에는 식당이 굉장히 많은데, 층 별로 다른 컨셉의 식당이 운영되고 있습니다. 교토 역 10층은 라멘 가게만 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;中村商店&quot;&gt;中村商店&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d9245.50718455093!2d135.75855603673068!3d34.98716461669761!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001096bbe7e9941%3A0x19754a58f5c66a71!2sNakamura%20Sh%C5%8Dten!5e0!3m2!1sko!2skr!4v1696574099537!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/20.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저는 그 중 &lt;strong&gt;中村商店(나카무라 쇼텐)&lt;/strong&gt;이라는 라면집에 방문했습니다. 일본 여행 커뮤니티에서 이 가게의 시오라면 스페셜이 굉장히 맛있다는 게시글을 봤거든요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/21.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시오라멘 스페셜은 그림처럼 굉장히 많은 차슈가 올라갑니다. 가격은 1480엔으로 싼 편은 아닙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/22.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;음식을 받아보니 역시 사진처럼 차슈가 풍성했습니다. 사진으로는 양이 그렇게 많아보이지 않은데, 먹고 나니 배가 엄청나게 부르더라구요. 예전에 먹어봤던 일본 라멘은 굉장히 짰었는데, 이 가게는 그렇게까지 짜지 않았기 때문에 괜찮았습니다. 다만 국물까지 다 먹기에는 역시 좀 짜더라구요.&lt;/p&gt;

&lt;h2 id=&quot;리가-로얄-호텔-교토&quot;&gt;리가 로얄 호텔 교토&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d9245.411720626038!2d135.75024130645645!3d34.98800990898098!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001089572eaf6db%3A0x469c370f6f1f1b0b!2z66as6rCAIOuhnOyWhCDtmLjthZQg6rWQ7Yag!5e0!3m2!1sko!2skr!4v1696575392946!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/23.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에 선택한 호텔은 교토 역 근처에 있는 &lt;strong&gt;리가 로얄 호텔 교토&lt;/strong&gt;입니다. 예전 포스트에서도 언급했듯이, 일본의 호텔은 방이 작은 경우가 많습니다. 그래서 일본 호텔을 예약할 때는 방 크기를 가장 먼저 보는데, 마침 이 호텔이 객실의 방 크기도 크고 역에서도 그렇게 멀지 않을 뿐만 아니라 가격도 나름 합리적이었기 때문에 이 곳을 선택했습니다. 나중에 알고보니 이 호텔은 5등분의 신부에서 주인공들이 묵었던 호텔이라고 하더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/24.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;교토 역에서 점심을 먹고 가니 체크인이 가능한 시간이라고 하길래 바로 체크인을 했습니다. 방 번호는 703호를 받았는데, 번호가 낮을수록 안쪽 객실이라 왔다갔다 하는게 불편했습니다. 지난 번 도쿄에서도 안쪽 객실을 줬었는데 운이 좋지 않네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/25.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;방의 크기는 22제곱미터라고 하는데, 들어가보니 역시 작지 않았습니다. 침대도 킹 사이즈라 혼자 뒹굴뒹굴 거리면서 잘 수 있었고, 캐리어를 놓을 곳도 따로 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/26.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;화장실에는 욕조도 있었습니다. 예전에는 욕조 유무를 크게 신경쓰지 않았는데, 한번 욕조의 맛을 알게되니까 그 다음부터는 꼭 욕조가 있는 곳을 찾게 되더라구요. 밤에 뜨거운 물에 피곤한 몸을 담그고 맥주 한잔 하면 그렇게 기분 좋을 수가 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/27.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원래 대부분의 호텔에서는 식수를 2병 제공해줍니다만, 이 호텔은 특이하기 식수 대신 플라스틱 병을 지급합니다. 뭐 일회용 쓰레기를 줄이기 위한 일이라고 하던데… 별로 마음에 들진 않네요. 층 마다 정수기가 있어서 이 플라스틱 병에 직접 물을 받아와야하는데, 저는 귀찮아서 결국 나중에 편의점에서 생수를 사먹었습니다. 게다가 저 물병은 중간에서 물이 새서 사용하기 불편했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/28.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어매니티는 4성급 호텔답게 있을 것은 다 있습니다. 일회용 칫솔/치약, 면도기 같은 것은 다 있고 매일 아침 방 청소 때 다시 보충해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/29.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 호텔의 특이한 점은 관내복으로 유카타를 제공해준다는 것입니다. 대부분의 호텔은 샤워 가운을 제공해주는데, 샤워 가운은 입고 자기 조금 불편했거든요. 유카타는 일반 옷이랑 비슷한 재질이라 입고 자기 편리해보였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/30.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호텔의 경치는 뭐… 크게 기대는 안했습니다. 어차피 도심 한가운데라 일반적인 빌딩뷰입니다.&lt;/p&gt;

&lt;h2 id=&quot;기요미즈데라청수사&quot;&gt;기요미즈데라(청수사)&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d13074.403988183287!2d135.75665747027304!3d34.991657794048834!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e3!4m5!1s0x6001089572eaf6db%3A0x469c370f6f1f1b0b!2z66as6rCAIOuhnOyWhCDtmLjthZQg6rWQ7YagIDHnlarlnLAgVGFpbWF0c3VjaG8sIFNoaW1vZ3lvIFdhcmQsIEt5b3RvLCA2MDAtODIzNyDsnbzrs7g!3m2!1d34.986385299999995!2d135.75269509999998!4m5!1s0x600108d385dcfb07%3A0x62af658650c434ba!2z7J2867O4IOq1kO2GoOu2gCDqtZDthqDsi5wg7Z6I6rCA7Iuc7JW866eI6rWsIOq4sOyalOuvuOymiCAxIOyhsOuplCDquLDsmpTrr7jspojrjbDrnbw!3m2!1d34.9948561!2d135.7850463!5e0!3m2!1sko!2skr!4v1696576661356!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;새벽부터 거의 한 숨도 못자고 긴 거리를 이동하고 나니 굉장히 피곤했습니다. 하지만 짧은 여행 기간 동안 하나라도 더 구경해야하니 호텔에 간단하게 짐을 풀고 바로 나왔습니다. 첫 날에는 간단하게 기요미즈데라(청수사)와 그 주변 관광지를 둘러볼 계획입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/31.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역시 문화재의 도시 답게 호텔에서 버스 정류장으로 가는 길에도 뭔가 유적같은 것이 눈에 들어오네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/32.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이곳이 시내 버스 정류장입니다. 보통 해외 여행할 때 버스보다는 지하철을 선호하는데, 교토는 지하철 노선이 굉장히 부실해서 대부분의 관광지는 버스를 이용해야만 이동할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/33.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 탈 버스는 206번 버스입니다. 버스비는 거리에 상관없이 230엔이고, 한 시간에 4대 정도가 다닙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/34.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;206번 버스를 타고 기요미즈데라로 가기 위해서는 고조자카 역에서 내리면 됩니다. 버스 안내판에 한글로도 나오기 때문에 쉽게 알 수 있습니다. 지도상으로는 기요미즈데라까지 거리가 크게 멀어보이지 않았는데, 교통 체증 때문인지 40분 정도나 걸렸습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/35.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기요미즈데라는 버스 정류장에서도 거리가 꽤 멀기 때문에 15분 정도 추가로 걸어가야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/36.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역시 교토의 대표 관광지 답게 입구에서부터 사람들이 굉장히 많이 보였습니다. 도쿄의 아사쿠사처럼, 여기도 기요미즈데라까지 가는 길에 기념품을 파는 가게가 쭉 늘어져 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/37.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/38.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/39.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 그 긴 길을 따라 올라가도 끝이 아니라 계단을 올라가야 하더라구요. 벌써부터 조금 지치기 시작했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/40.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/41.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/42.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기요미즈데라 입구에도 이것저것 많긴 했는데, 핵심 지역으로 이동하려고 하니 역시 입장료를 받네요. 입장료는 400엔입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/43.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기요미즈데라 안쪽은 지대가 더 높아서, 이렇게 경치를 감상할 수 있게 되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/44.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이곳이 본당인 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/45.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일본 애니에서 보던 곳입니다. 한국의 약수터처럼 생겼는데, 저 물을 마시는게 아니라 저 물을 받아서 입을 씻는 거라고 하더라구요. 국자가 마치 약수터 국자처럼 생겨서 한국인들은 혼동할 수도 있을 것 같습니다. (그래서인지 마시지 말라는 경고문도 붙어있었습니다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/46.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/47.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기요미즈데라에서 가장 유명한 무대입니다. 무대 건너편에 이렇게 무대를 향해 사진을 찍을 수 있게 되어있는데, 이 모습이 참 아름답더라구요. 괜히 유명한게 아니다라는 느낌이 들었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/48.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지나가다보니 이렇게 불상에 천 조각을 두른 모습이 보였습니다. 이 때는 기요미즈데라의 특이한 모습인줄 알았는데, 나중에 보니 교토 전체에서 이런 문화가 있는 것 같더라구요. 무슨 의미가 있는지는 잘 모르겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/49.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;슬슬 다 보고 돌아가려는 찰나 굉장히 재밌는 모습을 봤습니다. 천장에서 떨어지는 물을 받아 마시는 곳 같은데, 생각해보니 내청코 애니메이션에서 봤던 기억이 나네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/50.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이름 모를 탑도 눈에 들어왔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/51.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;안에 조그만 호수도 있었는데, 이 호수 안에 물고기가 살고 있더라구요. 일본에서 봤던 대부분의 호수에서는 다 물고기가 살고 있었는데, 원래 이렇게 물고기가 많이 사는건지 아니면 일부러 관광객을 위해 풀어놓은 건지는 잘 모르겠습니다. 호수라기보다는 물 웅덩이에 가까운 크기라 자연발생하지는 않았을 것 같은데 말이죠.&lt;/p&gt;

&lt;h2 id=&quot;야사카-신사&quot;&gt;야사카 신사&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d6536.593918314576!2d135.7759182469149!3d34.99927077990646!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x600108d385dcfb07%3A0x62af658650c434ba!2z7J2867O4IEt5b3RvLCBLeW90bywgSGlnYXNoaXlhbWEgV2FyZCwgS2l5b21penUsIDEtY2jFjW1l4oiSMjk0IOq4sOyalOuvuOymiOuNsOudvA!3m2!1d34.9948561!2d135.7850463!4m5!1s0x60010879a010eca9%3A0xc77ac89d5a241ae9!2z7JW87IKs7Lm0IOyLoOyCrCA2MjUgR2lvbm1hY2hpIEtpdGFnYXdhLCBIaWdhc2hpeWFtYSBXYXJkLCBLeW90bywgNjA1LTAwNzMg7J2867O4!3m2!1d35.0036559!2d135.7785534!5e0!3m2!1sko!2skr!4v1696579261243!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/52.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기요미즈데라 다음에는 근처에 있는 야사카 신사로 갔습니다. 버스를 타고 가기에는 애매한 거리라 산책할 겸 걷기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/53.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 시간대에 살짝 보슬비가 내렸는데, 그래서 그런지 하늘이 어둑어둑하네요. 사진의 분위기가 영 안좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/54.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가는 길에 너무 목이 말라 자판기에서 음료수를 하나 뽑아먹었습니다. 이로하스 모모가 그렇게 맛있다고 소문이 나서 한 번 마셔봤는데, 진짜 맛있더라구요! 뭔가 물인데 복숭아의 달콤한 맛도 은은히 나서 앞으로 이것만 마셔야겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/55.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자판기 근처에서 본 탑입니다. 이 탑의 이름이 분명 있을진데 구글 지도에도 나오지 않아서 못찾겠네요… 혹시 아시는 분이 있다면 댓글로 알려주시면 감사하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/56.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;야사카 신사의 입구입니다. 듣기로는 저녁부터 신사 내의 등이 켜진다는데, 아직 시간이 애매해서 불이 켜지진 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/57.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이곳이 신사 본당인 것 같습니다. 천장에 3줄로 달린 흰 색이 바로 등입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/58.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;신사 구석에 보니 조그만 물줄기가 흐르는 곳이 보였습니다. 전 이런 미니멀한 감성(?)이 좋더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/59.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다리가 아파서 의자에 앉아 조금 쉬고 있었는데, 날씨가 흐려서 그런지 생각보다 일찍 불이 켜졌습니다. 불이 켜진 김에 한바퀴 둘러보고 다른 곳으로 이동해야겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/60.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여긴 신당 안에 말 조형이 2개 있더라구요. 무슨 의미일까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/61.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;야사카 신사에서 볼 거리는 이게 전부입니다. 생각보다 크지 않아서 금방 둘러볼 수 있더라구요. 신사 뒤쪽에는 공원도 있던데, 거기까지 둘러보기는 다리도 아프고 귀찮아서 그냥 이 정도만 보고 기온 거리로 이동하기로 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;기온-거리&quot;&gt;기온 거리&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d3268.120738331706!2d135.77532427640185!3d35.00368261689486!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x60010879a010eca9%3A0xc77ac89d5a241ae9!2z7J2867O4IOq1kO2GoOu2gCDqtZDthqDsi5wg7Z6I6rCA7Iuc7JW866eI6rWsIOq4sOyYqOuniOy5mCDquLDtg4DqsIDsmYAg7JW87IKs7Lm0IOyLoOyCrA!3m2!1d35.0036559!2d135.7785534!4m5!1s0x600108c3c1c67b67%3A0xdcb04aa1398efb4!2z6riw7Jio!3m2!1d35.003781599999996!2d135.777245!5e0!3m2!1sko!2skr!4v1696580207419!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/62.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;야사카 신사로 바로 나오면 기온 거리가 보입니다. 기온 거리는 교토의 전통 시장이라고 합니다. 다만 전통시장이라고 보기에는 현대식 가게들이 많이 들어와 있어서 그렇게까지 볼만한 곳은 아닌 것 같았습니다. 저렇게 전등 같은 것을 달아놓은 것만 빼면 그냥 상점가인데요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/63.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기온 거리 한쪽에는 이렇게 강이 흐르고 있었습니다. 배도 고프고, 이 날 볼만한 것은 다 본 것 같아서 이자카야나 가기로 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;이자카야-안지&quot;&gt;이자카야 안지&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3268.164431494135!2d135.76307997640163!3d35.002588766953856!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001089671e1cbeb%3A0x500a8bd33f0887ae!2sAnji!5e0!3m2!1sko!2skr!4v1696581645781!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/64.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뭘 먹을까 하다가 첫날에는 회가 먹고 싶어져서 회를 파는 곳을 찾아봤습니다. 주변에 있는 이자카야 중에 이 곳이 가장 평점이 높길래 찾아가봤어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/65.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메뉴판이 밖에 이렇게 나와있긴 한데, 필기체라 알아보기도 힘들고 알아보더라도 생선 이름인 것 같아서 의미를 잘 모르겠더라구요. 뭐 그래도 교토니까 영어 메뉴판 정도는 있지 않을까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/66.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다행히 영어 메뉴판도 있었고, 주문 방식은 QR 코드를 통해 스마트폰으로 주문하는 방식이라 그렇게 어렵지 않았습니다. 먼저 생맥주 大자를 시켜봤습니다. 가격이 만원 좀 넘긴 했는데, 이거 한 잔만 마셔도 될 정도로 엄청 크더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/67.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 먼저 시킨건 사시미 메뉴입니다. 5종의 생선이 2점씩 나오는 메뉴인데, 가격이 만 오천원 정도더라구요. 플레이팅을 감안해도 가격이 상당히 비쌌습니다. 서울에서 회 한접시에 2~3만원 정도 하지 않나요? 맛있긴 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/68.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 시켜본 메뉴는 고등어 초밥입니다. 예전부터 고등어 초밥을 먹어보고 싶었는데, 한국에서 고등어 초밥을 파는 곳이 흔하지 않다보니 지금까지 못먹어봤거든요. 나중에 알고보니 고등어 초밥이 교토의 특산물 중 하나라고 합니다.&lt;/p&gt;

&lt;p&gt;고등어 초밥은 생고등어를 올려서 먹는게 아니라, 고등어를 올린 다음 불로 살짝 구워서 주더라구요. 맛은 짭짤한 고등어 구이 맛이 났습니다. 가격이 만원 정도였는데, 4피스에 만원이면 조금 비싼 감이 있긴 합니다.&lt;/p&gt;

&lt;h2 id=&quot;호텔로-복귀&quot;&gt;호텔로 복귀&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/69.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이자카야 안지에서 약 4천엔 정도 나왔습니다. 귀가할 때는 지하철 가라스마선을 타고 교토역으로 돌아왔습니다. 교토역에서 호텔로 가는 길에 관광객들이 뭘 찍고 있길래 뭔가 보니 교토 타워가 보이더라구요. 모습이 이쁘길래 저도 한 번 찍어봤습니다. 생각해보니 일본은 도시마다 저런 타워가 하나씩 있는 것 같네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/70.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;맥주를 많이 마시긴 했는데 술 한잔으로는 부족해서 편의점에서 술과 안주를 사서 들어갔습니다. 사진에는 잘 안보이는데, 편의점에서 파는 푸딩과 조각 케익이 엄청 맛있었습니다.&lt;/p&gt;

&lt;p&gt;이렇게 교토에서 첫 날이 끝났습니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="travel" /><category term="kyoto" /><summary type="html">대학원생은 생각보다 여행할 시간이 많지 않습니다. 그래서 가급적이면 연휴를 활용해야 하는데, 이번에 마침 추석 연휴와 개천절이 연결되어 6일이라는 황금 연휴가 만들어졌습니다. 물론 연휴는 모두가 해외여행을 떠나고 싶어하는 기간이기 때문에 표값도 비싸고, 관광지에 사람이 바글바글 댈 것이라는 예상은 들었지만, 이 기회를 놓치기 너무 아까워서 여행계획을 세웠습니다. 이번에는 5박 6일이라는 약간 애매한 일정이 만들어졌는데, 교토와 그 근교를 둘러보면 적당한 기간일 것으로 생각되어 교토를 방문하기로 결정했습니다. 이 기간의 비행기값만 70만원 가까이 나왔지만, 눈물을 머금고 예약했습니다.</summary></entry><entry><title type="html">Abstract Data Types and Encapsulation Constructs</title><link href="http://localhost:4000/pl/abstract-data-types-and-encapsulation-constructs/" rel="alternate" type="text/html" title="Abstract Data Types and Encapsulation Constructs" /><published>2023-09-22T00:00:00+09:00</published><updated>2023-09-22T00:00:00+09:00</updated><id>http://localhost:4000/pl/abstract-data-types-and-encapsulation-constructs</id><content type="html" xml:base="http://localhost:4000/pl/abstract-data-types-and-encapsulation-constructs/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;11장의 주제는 추상 데이터 타입과 캡슐화 구조입니다. 프로그래밍을 어렵게 만드는 것은 데이터의 컴퓨터 표현이 부자연스럽기 때문입니다. 추상화는 프로그래밍의 복잡성에 맞서는 무기로, 추상화의 목적은 프로그래밍 프로세스를 단순화하는 것입니다. 프로그래머가 필수 속성에 집중하고, 하위 속성을 무시할 수 있도록 하기 때문에 효과적인 무기입니다.&lt;/p&gt;

&lt;p&gt;데이터 추상화의 두 가지 주요 기능은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;관련 작업으로 데이터 객체를 캡슐화하기&lt;/li&gt;
  &lt;li&gt;(중요한) 정보를 숨기기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 &lt;span style=&quot;color:red&quot;&gt;추상화(Abstraction)&lt;/span&gt;의 개념은 프로세스나 객체의 일부 범주가 해당 속성의 부분집합으로만 표현될 수 있다는 것입니다. 이것은 다른 모든 속성이 추상화되거나 숨겨져 있다는 카테고리의 필수 속성입니다. 쉽게 말하면, 추상화는 중요한 속성만을 포함하는 객체의 표현이라고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;추상화는 프로그래밍의 복잡성에 맞서는 무기입니다. 추상화의 목적은 프로그래밍 과정을 단순화하는 것으로, 프로그래머가 필수적인 속성에만 집중하고, 나머지 속성은 무시할 수 있도록 하기 때문입니다.&lt;/p&gt;

&lt;p&gt;추상화의 개념 자체는 간단하지만, 프로그래밍 언어가 이것을 지원하도록 설계되기 전까지는 추상화를 사용하는 것이 편리하지 않았습니다. 언어에서 추상화를 위해 지원하는 것 중 대표적인 것은 &lt;strong&gt;추상 데이터 타입(Abstract Data Type)&lt;/strong&gt;이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현대 프로그래밍 언어에서 제공하는 추상화는 &lt;strong&gt;프로세스 추상화(Process Abstraction)&lt;/strong&gt;와 &lt;strong&gt;데이터 추상화(Data Abstraction)&lt;/strong&gt;가 있습니다. 먼저 프로세스 추상화는, 수행 방법을 명시하지 않고 일부 프로세스가 수행되도록 프로그램이 실행될 수 있도록 하는 방법입니다. 이 개념은 프로그래밍 언어 설계에서 가장 오래된 개념 중 하나입니다. (약 1940년대부터 대중화가 시작) 예를 들어, 9장에서 배운 부프로그램은 호출하는 프로그램에서 프로세스가 어떻게 동작하는지에 관해서 상세하게 지정할 필요가 없습니다. 따라서 모든 부프로그램은 프로세스 추상화입니다. 예를 들어, 프로그램이 어떤 데이터를 정렬하려고 할 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SORT_INT(LIST, LENGTH)&lt;/code&gt;와 같이 호출할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 이러한 호출은 SORT_LIST의 알고리즘이 명시되지 않은 정렬 프로세스의 추상화입니다. 따라서 이 부프로그램의 호출은 호출된 부프로그램에서 구현된 알고리즘과 독립적입니다. 이 부프로그램의 필수 속성은 정렬할 배열의 이름, 원소의 타입, 그리고 배열의 길이입니다. SORT_INT의 알고리즘이 버블 정렬인지, 퀵 정렬인지는 상관이 없습니다.&lt;/p&gt;

&lt;p&gt;데이터 추상화는 표현 및 구현 세부사항을 프로그래메에 의해 숨기는 것을 말합니다. 이렇게 설명하면 프로세스 추상화와 매우 비슷하게 들리겠지만, 실제로 데이터 추상화와 프로세스 추상화는 매우 연관되어 있습니다. 왜냐하면 프로세스 추상화의 광범위한 사용은 결국 데이터 추상화를 이끌어내기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 장에서는 데이터 추상화에 대해서만 더 집중적으로 논의해보겠습니다. 데이터 추상화는 프로그래밍 방법론의 개념 중 하나인데, 프로세스 추상화보다 훨씬 늦게 발견되었습니다. 이것은 COBOL과 함께 Data-oriented Programming이 화두가 되었던 1960년대에 시작되었습니다. 데이터 추상화를 위한 동기는 프로세스 추상화가 만들어진 동기와 비슷합니다. 즉, 크고 복잡한 프로그램을 더 잘 다룰 수 있도록 복잡성에 대항하기 위한 방법 중 하나입니다.&lt;/p&gt;

&lt;p&gt;대표적인 데이터 추상화의 구현으로써 &lt;span style=&quot;color:red&quot;&gt;추상 데이터 타입(Abstract Data Type)&lt;/span&gt;이 있습니다. 추상 데이터 타입은 레코드 타입의 데이터 구조이지만, 데이터를 다루는 부프로그램을 포함하고 있습니다. 구문적으로 따졌을 때, 추상 데이터 타입은 한 개의 특별한 데이터 타입과, 그 데이터의 표현 및 연산을 제공하는 부프로그램을 포함합니다. 접근 제어를 이용하여 불필요한 세부 사항들은 외부로부터 숨길 수 있습니다. 추상 데이터 타입을 사용하는 프로그램 단위는, 그 타입의 변수를 선언할 수 있지만 어떻게 구현되었는지는 숨겨집니다. 추상 데이터 타입의 인스턴스(Instance)를 &lt;strong&gt;객체(Object)&lt;/strong&gt;라고 부릅니다.&lt;/p&gt;

&lt;p&gt;먼저, 추상 데이터 타입으로써 부동 소수점을 알아보겠습니다. 프로그램에 내장된 데이터 타입은 전부 추상 데이터 타입입니다. 예를 들어, 대부분의 언어는 한 가지 이상의 부동 소수점 데이터 타입을 가지고 있습니다. 부동 소수점 데이터 타입은 일반적으로 실수의 값을 저장하는데 사용됩니다. 실제로 부동 소수점 데이터 타입은 부동 소수점 데이터에 대한 변수를 생성하는 수단을 제공합니다. 그리고, 그 유형의 객체를 조작하기 위한 산술 연산(+, *, -, /)을 제공합니다.&lt;/p&gt;

&lt;p&gt;그러나, 6장에서 데이터 타입에 대해 구체적으로 배우기 전까지는 이러한 데이터 타입이 어떻게 구성되어 있는지 모르거나 관심이 없었을 겁니다. 즉, 메모리 셀에서 부동 소수점 데이터가 실제로 어떻게 저장되어 있는지는 사용자로부터 숨겨지고, 사용자가 부동 소수점 객체의 표현을 직접 수정할 수 없습니다. 따라서 이것은 데이터 추상화의 중요한 개념인 &lt;strong&gt;정보 은폐(Information Hiding)&lt;/strong&gt;라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부동 소수점 타입에서는 정보 은폐로 인해, 사용자가 사용 가능한 유일한 작업은 시스템 내에서 제공하는 작업들 뿐입니다. 게다가, 부동 소수점 데이터 타입에 대한 새 작업을 생성할 수 없습니다. 이것으로 인해, 부동 소수점 데이터 타입은 특정 형식으로 고정되지 않고, 어느 정도 자유로운 데이터 표현 방법을 가질 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 표현의 장점은, 기계마다 다른 방법으로 부동 소수점 타입을 표현하더라도 쉽게 프로그램을 이식할 수 있다는 것입니다. 예를 들어, IEEE 704 표준 부동 소수점 표현이 1980년대에 정립되었는데, 그 전에는 컴퓨터 구조마다 부동 소수점 타입을 조금씩 다르게 표현했습니다. 그러나 부동 소수점 타입을 사용하는 프로그램이 여러 컴퓨터 구조에 이식되는 것에 문제가 없었습니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;사용자 정의 추상 데이터 타입(User-defined Asbtract Data Type)&lt;/span&gt;은 일반적인 추상 데이터 타입으로써 다음 두 가지 조건을 만족하는 데이터 타입을 말합니다.&lt;/p&gt;

&lt;p&gt;첫 번째 조건은 타입의 선언과 타입의 객체에 수행되는 작업이 단일 구문 단위(그룹, 컴파일 유닛)로 포함된다는 것입니다. &lt;strong&gt;(캡슐화)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 번째 조건은 타입 객체의 표현은 그 타입을 사용하는 프로그램 단위로부터 숨겨지고, 이러한 객체에 직접적으로 수행 가능한 연산은 타입의 정의에서 제공하는 연산 뿐이라는 것입니다. &lt;strong&gt;(정보 숨김)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이렇게 표현과 연산을 단일 구문 단위로 패키징하면 다음과 같은 장점이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;캡슐화에 의한 지역적 수정 : 이러한 타입을 사용하는 프로그램 단위는 표현의 세부사항을 볼 수 없으므로, 표현의 방법에 의존하지 않습니다. 게다가 표현 방법은 해당 타입을 사용하는 프로그램 단위에 영향을 주지 않고, 언제든지 변경할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정보 은폐로 인한 신뢰성 향상 : 프로그램 단위는 의도적으로, 또는 우연히 표현의 일부를 직접 변경할 수 없으므로, 해당 객체의 &lt;strong&gt;무결성(Integrity)&lt;/strong&gt;이 향상됩니다. 객체는 오로지 제공하는 연산을 통해서만 변경할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;무결성으로 인한 정보 은폐의 대표적인 장점 중 하나는 신뢰성이 증가한다는 것입니다. 또 다른 장점은 프로그래머가 프로그램을 작성하거 읽을 때 유의해야할 코드의 범위와 개수가 줄어든다는 것입니다. 특히, 추상 데이터 타입 내에서 정의된 변수의 값은 제한된 영역에서만 변화될 수 있기 때문에 코드를 이해하기 쉽고, 의도치 않게 그 값이 변경되는 사태를 막을 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 추상 데이터 타입에 있는 데이터를 Public과 같은 공용으로 명세하고, 그 데이터 대한 접근 방법을 제공하는 것은 추상 데이터 타입의 원리를 위반하는 것이므로 주의하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어서, 스택(Stack)에 대한 추상 데이터 타입을 살펴보겠습니다. 스택에서 허용된 연산은 다음과 같이 정의되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;create(stack) : 스택 객체를 생성한다.&lt;/li&gt;
  &lt;li&gt;destroy(stack) : 스택을 위한 기억공간을 해제한다.&lt;/li&gt;
  &lt;li&gt;empty(stack) : 스택이 비어있으면 true, 그렇지 않으면 false를 반환한다.&lt;/li&gt;
  &lt;li&gt;push(stack, element) : 스택에 element 원소를 추가한다.&lt;/li&gt;
  &lt;li&gt;pop(stack) : 스택 가장 위의 있는 원소를 제거한다.&lt;/li&gt;
  &lt;li&gt;top(stack) : 스택 가장 위의 있는 원소를 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 이러한 기능들만 만족하면, 내부 구현이 배열로 구성되었던 연결 리스트로 구성되었던 전혀 신경쓸 필요가 없습니다. 이렇게 데이터 추상화의 목표는 데이터 객체를 하나하나 표현하는 것이 아니라, 추상적인 속성에만 의존하여 프로그램을 작성할 수 있는 기능을 제공하는 것입니다. 게다가, 나중에 스택의 구현 내용을 수정하더라도, 각각의 기능의 프로토타입이 변경되지 않는다면 스택 객체를 사용한 코드를 변경할 필요가 없다는 것도 장점입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 추상 데이터 타입을 설계할 때 무엇을 고려해야 할까요? 언어에서 추상 데이터 타입을 정의하기 위해서는 타입 선언과 그 타입의 객체에서 가능한 연산을 구현하는 부프로그램을 같이 설계해야 합니다. 또한 추상화를 사용하는 다른 프로그램 단위가 타입 이름과 부프로그램 헤더(프로토타입)를 볼 수 있어야 합니다. 물론 타입의 표현은 은폐되어야 합니다.&lt;/p&gt;

&lt;p&gt;타입에 대한 정의와 함께 주어지는 연산 외에도, 일반적인 연산들이 추상 데이터 타입 객체에 제공되어야 합니다. 이러한 연산은 대표적으로 &lt;strong&gt;배정(Assignment)&lt;/strong&gt;, &lt;strong&gt;동치(Equality)&lt;/strong&gt; 비교가 있습니다. 만약 객체 내의 변수가 있다면, 그 변수를 외부에서 직접 수정하는 것은 최대한 지양되어야 합니다. 대신, 객체 내의 연산을 통해 간접적으로 객체 내의 변수를 조절할 수 있어야 합니다. 동치 비교 또한 두 개의 객체가 같은지, 다른지는 ==와 같은 일반적인 연산 대신 객체 내에 정의된 연산으로 비교가 가능해야 합니다.&lt;/p&gt;

&lt;p&gt;또한 추상 데이터 타입의 캡슐화 요구 사항은 두 가지 방법으로 충족할 수 있습니다. 첫 번째 방법은 단일 데이터 타입과 그 연산을 사용자가 직접 정의할 수 있도록 제공하는 것입니다. Pascal과 Smalltalk, C++이 이러한 방법을 사용합니다. 두 번째 방법은 많은 객체를 정의할 수 잇는 일반화된 캡슐화 구조를 제공하는 것입니다. 이러한 각각의 객체는 외부에 선택적으로 보일 수 있도록 지정할 수 있습니다. Modula-2와 Ada 같은 언어가 이러한 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;추상 데이터 타입을 설계할 때 고려해야 할 것들을 정리하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;추상적일 수 있는 타입의 종류를 어떻게 제한할 것인가?&lt;/li&gt;
  &lt;li&gt;추상 데이터 타입이 제네릭, 또는 매개변수화 될 수 있는가?&lt;/li&gt;
  &lt;li&gt;지역 이름과 비지역 이름 간의 충돌을 방지하기 위해 가져온 타입을 어떻게 한정할 것인가? (접근 제어)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면 각각의 언어에서 추상 데이터 타입을 어떻게 정의하고 있는지 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;가장 먼저 살펴볼 언어는 SIMULA 67입니다. SIMULA 67 언어는 완전한 추상 데이터 타입을 위한 지원은 없지만, 데이터 추상화의 개념이 처음 시작된 언어입니다. 캡슐화의 관점에서 SIMULA 67의 클래스 정의는 타입에 대한 템플릿(Template)입니다. 클래스의 인스턴스는 사용자 프로그램의 요청에 따라 동적으로 생성되며, 포인터 변수로만 참조가 가능합니다.&lt;/p&gt;

&lt;p&gt;클래스 정의의 구문 형식은 인스턴스 생성 시, 클래스 변수 초기화를 위해 클래스 인스턴스 코드 부분이 한 번만 실행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SIMULA 67이 데이터 추상화를 위해 기여한 점은 클래스 구조를 통해 데이터를 선언하는 것과 이를 다루는 프로시저를 구문적으로 캡슐화 했다는 것입니다. 즉, 슬라이드에 나온 것처럼 슬라이드의 정의에서 변수와 부프로그램을 클래스 내에 선언하는 것입니다.&lt;/p&gt;

&lt;p&gt;정보 은폐 관점에서 보자면, SIMULA 67의 클래스에서 선언된 변수는 클래스 객체를 할당하는 다른 프로그램 단위에서 숨겨지지 않습니다. 즉, 클래스의 부프로그램에서 접근하거나, 아니면 이름을 통해 직접 접근할 수 있습니다. 따라서 정보 은폐가 완벽하게 제공되지 않는다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 Modula-2 언어에서의 추상 데이터 타입에 대해 알아보겠습니다. Modula-2는 추상 데이터 타입의 표현을 숨기는 기능을 포함한 데이터 추상화를 지원합니다.&lt;/p&gt;

&lt;p&gt;Modula-2 언어에서 데이터 추상화 기능을 제공하는 프로그램 단위는 &lt;strong&gt;모듈(Module)&lt;/strong&gt;입니다. 모듈은 다른 프로그램 단위에서 접근할 수 있는 타입, 객체 및 부프로그램의 정의를 모두 포함할 수 있습니다.&lt;/p&gt;

&lt;p&gt;모듈의 정의에서는, 클라이언트 장치에서 부프로그램의 헤더뿐만 아니라 타입 및 객체의 최소한의 부분 사양을 볼 수 있습니다. 또한, 모듈의 인터페이스를 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;모듈의 구현에서는, 해당 정의 모듈에서 부분적으로만 정의된 모든 타입의 완전한 정의가 이루어집니다. 또한 해당 정의 모듈에 헤더가 나타나는 부프로그램의 전체적인 정의도 포함해야 합니다. 이러한 모듈은 별도로 컴파일이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 모듈의 정의에서 표현이 포함되어 있다면, 그 타입은 &lt;strong&gt;투명(Transparent)&lt;/strong&gt;하다고 하며, 그 표현을 가져오는 모듈에서는 숨겨지지 않습니다.&lt;/p&gt;

&lt;p&gt;그러나 모듈의 정의에서 표현이 포함되어 있지 않고, 구현 모듈에 표현이 포함된다면 그 유형은 &lt;strong&gt;불투명(Opaque)&lt;/strong&gt;하다고 합니다. 추상 데이터 타입은 당연히 불투명해야하지만, Modula-2 언어에서는 포인터 타입만 불투명할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제 Modula-2의 코드를 보고 이것이 무슨 의미인지 알아보겠습니다. 이것은 Modula-2 언어로 스택을 구현한 프로그램입니다. 스택 모듈의 이름은 stackmod로 정의되어 있습니다. 모듈은 정의 모듈(Definition Module)과 구현 모듈(Implementation Module)로 나뉘어 있는데, 정의 모듈에는 타입과 프로시저의 헤더가 선언되어 있고, 구현 모듈에 상세한 구현 내용이 작성되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 다른 모듈에서 이전 슬라이드에서 정의한 stackmod 모듈을 사용하고 싶다면, FROM ~ IMPORT 명령어를 이용하여 stackmod 모듈의 프로시저를 하나하나 호출해줘야 합니다.&lt;/p&gt;

&lt;p&gt;클라이언트에서 모듈의 프로시저를 호출할 때는 2가지 방법이 있습니다. 명시적으로 어떤 모듈의 프로시저인지 나타내는 방법과, 그냥 프로시저의 이름만을 호출하는 경우입니다. 만약 프로시저 이름의 중복이 없다면 그냥 프로시저의 이름만 호출해도 사용이 가능하지만, 만약 다른 모듈에서 같은 이름의 프로시저가 있다면 모듈의 이름을 반드시 명시해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 살펴볼 언어는 Ada입니다. Ada는 추상 데이터 타입을 완벽하게 지원하는 최초의 언어입니다.&lt;/p&gt;

&lt;p&gt;Ada 언어의 캡슐화 구성 요소나 모듈은 &lt;strong&gt;패키지(Package)&lt;/strong&gt;라고 부릅니다. 패키지는 &lt;strong&gt;명세 패키지(Specification Package)&lt;/strong&gt;와 &lt;strong&gt;몸체 패키지(Body Package)&lt;/strong&gt; 두 부분으로 구성되는데, 각각을 그냥 패키지라고 부르기도 합니다. 모든 패키지가 몸체 패키지를 갖고 있는 것은 아니고, 만약 패키지 앞에 body 로 시작하는 명령어를 입력하면 컴파일러는 이 패키지를 몸체 패키지로 인식합니다. 명세 패키지와 몸체 패키지는 서로 별도로 컴파일이 가능한데, 이 때는 반드시 명세 패키지를 먼저 컴파일해야 합니다. 또한 명세 패키지만 컴파일 된다면, 몸체 패키지를 컴파일하지 않아도 클라이언트 코드를 컴파일할 수 있습니다.&lt;/p&gt;

&lt;p&gt;명세 패키지에는 두 개의 섹션이 있습니다. 한 섹션은 외부에서 볼 수 있게 완전히 공개되고, private로 정의된 섹션은 외부에서 볼 수 없기 감춰집니다. 이 때, private는 반드시 명세 패키지의 마지막 부분에 작성해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Modula-2에서 보여드렸던 스택 코드를 Ada 언어로 구현한 코드입니다. 이전과 어떠한 차이가 있는지 같이 알아보겠습니다. 먼저, Modula-2 언어에서는 보이는 부분과 보이지 않는 부분을 별도의 모듈을 사용해서 구현했으나, Ada 언어는 하나의 패키지에서 보이는 부분과 보이지 않는 부분이 모두 나타나 있습니다. 대신, 그 구분을 private를 이용하여 나타냈습니다.&lt;/p&gt;

&lt;p&gt;패키지 첫 줄에는 limited private가 있습니다. 이것은 STACKTYPE 패키지가 &lt;strong&gt;제한된 전용 타입(Limited Private Type)&lt;/strong&gt;이라는 의미로, 이러한 타입의 객체에서 내장된 연산이 없다는 의미입니다. 예를 들어서, 생성자와 같이 미리 정의되는 배정 연산이나 비교 연산 같은 것이 없다는 것입니다. 스택에서 이러한 연산은 거의 사용되지 않기 때문에 여기에서는 limited private가 사용되었습니다.&lt;/p&gt;

&lt;p&gt;몸체 패키지에서는 스택의 각 함수와 프로시저가 구현되어 있습니다. 첫 줄에서 with / use 명령어가 사용되는데, with TEXT_IO은 텍스트 입출력을 위한 함수를 제공하는 외부 패키지를 볼 수 있게 만드는 것이고, use는 TEXT_IO를 참조할 때 명시적으로 참조하지 않게 만드는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제로 이 패키지를 사용하는 클라이언트에서는 마찬가지로 with / use 명령어를 이용하여 STACKPACK과 TEXT_IO를 가져옵니다. 나머지 코드의 부분은 직접 스택 패키지를 사용하는 예제를 나타낸 것이므로 별도의 설명이 필요하지 않을 것 같습니다.&lt;/p&gt;

&lt;p&gt;데이터 추상화의 관점에서 Modula-2와 Ada 언어를 비교해보겠습니다. Modula-2 언어는 포인터로만 불투명 내보내기를 제한하였지만, Ada의 추상 데이터 타입은 그렇지 않기 때문에 더 유연하다는 장점이 있습니다. 그러나, Modula-2의 설계는 모듈의 요소를 선택적으로 가져올 수 있기 때문에 패키지의 일부만 필요한 경우에는 Ada 언어보다 낫다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 유명한 언어 중 하나인 C++ 언어의 추상 데이터 타입에 대해 알아보겠습니다. C++은 C 언어에서 객체 지향 프로그래밍을 지원하는 기능이 추가된 언어이며, 그렇기 때문에 당연히 데이터 추상화도 지원합니다.&lt;/p&gt;

&lt;p&gt;C++의 클래스는 데이터 타입에 대한 템플릿이기 때문에, 여러 번 인스턴스화할 수 있습니다. 클래스에서 정의된 데이터는 데이터 멤버(또는 인스턴스 변수)라고 부르고, 클래스에서 정의된 함수는 멤버 함수(또는 메소드)라고 부릅니다. 데이터 멤버와 멤버 함수는 클래스와 인스턴스에 나타나는데, 클래스의 멤버는 클래스와 관련이 있고, 인스턴스 멤버는 클래스 인스턴스와 관련이 있습니다. 여기서는 클래스의 인스턴스 멤버만 고려하겠습니다.&lt;/p&gt;

&lt;p&gt;클래스의 모든 인스턴스는 멤버 함수를 공유하지만, 각각의 인스턴스는 자신의 데이터 멤버를 갖습니다. 클래스 인스턴스는 객체라고도 불립니다.&lt;/p&gt;

&lt;p&gt;클래스 인스턴스는 정적, 스택 동적, 힙 동적일 수 있습니다. 클래스 인스턴스가 만약 정적이나 스택 동적이라면 직접 참조할 수 있지만, 힙 동적이라면 포인터를 통해 참조됩니다. 정적이나 스택 동적인 경우는 객체 선언을 통해 생성되는 경우를 말하며, 힙 동적인 경우에는 new 연산자에 의해 생성되는 경우를 말합니다. 만약 클래스 인스턴스가 스택 동적일지라도, 클래스는 힙 동적 테이터를 참조하는 멤버 데이터를 포함할 수 있습니다.&lt;/p&gt;

&lt;p&gt;클래스 멤버 함수는 두 가지 방법으로 정의될 수 있습니다. 클래스 정의에서 헤더만 작성하고 클래스 외부에서 몸체 부분을 정의할 수도 있고, 또는 헤더에서 완전히 모든 것을 구현하는 인라인 함수(Inlined Function)가 있습니다. 인라인 함수의 장점은 일반적인 부프로그램에서의 호출과 복귀 과정을 거치지 않는다는 장점이 있습니다. 대신 클래스 정의 인터페이스가 복잡해지기 때문에, 인라인 함수는 일반적으로 실행 시간 효율성이 매우 중요한 상황에서만 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 클래스는 보이는 요소와 숨겨진 요소를 모두 포함할 수 있습니다. 이것은 접근 지정자를 표시하는 것으로 구별합니다. private 접근 지정자는 외부로부터 은폐되는 요소를 의미하며, public은 외부로부터 볼 수 있는 요소를 의미합니다. protected는 외부로부터는 은폐되지만, 상속받은 서브 클래스에는 보이는 요소를 의미합니다.&lt;/p&gt;

&lt;p&gt;또한 C++ 언어에는 &lt;strong&gt;생성자(Constructor)&lt;/strong&gt;와 &lt;strong&gt;소멸자(Destructor)&lt;/strong&gt;가 존재합니다. 생성자는 객체 생성 프로세스에서 매개변수를 초기화하고 제공하는데 사용합니다. 생성자는 클래스 타입의 인스턴스가 생성될 때 묵시적으로 호출되며, 클래스와 동일한 이름을 갖습니다. 생성자는 중복으로 만들 수 있지만, 각각의 생성자는 매개변수가 달라야 합니다. 소멸자는 생성자와 마찬가지로 클래스 타입 인스턴스의 수명이 끝날 때 묵시적으로 호출됩니다. 생성자와 소멸자는 모두 반환 타입을 갖지 않고, return 명령어를 사용하지도 않습니다. 또한, 프로그래머가 명시적으로 생성자와 소멸자를 호출하는 것도 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전에 나왔던 스택 예제를 C++의 클래스로 구현한 모습입니다. 먼저 Stack 클래스의 객체는 스택 동적이지만, 힙 동적 데이터를 참조하는 포인터 변수인 *stack_ptr을 포함합니다. Stack 클래스의 데이터 멤버 3개는 모두 private로 선언되어서 외부로부터 숨겨져 있습니다. 또한 Stack 클래스는 생성자, 소멸자, 그리고 4개의 멤버 함수를 가지고 있습니다. 이 예제에서는 모든 선언에 구현이 포함되어있기 때문에, 인라인 함수로써 취급됩니다. 현재 Stack 클래스는 생성자에서 항상 100개의 크기를 가지는 배열을 생성하지만, 동적인 크기를 갖는 배열로 변경하려면 생성자에 매개변수를 추가하여 그 크기만큼 배열을 생성하는 생성자로 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 Java 언어에서의 추상 데이터 타입을 살펴보겠습니다. Jva에서의 추상 데이터 타입 지원은 C++ 언어와 매우 유사합니다. 그러나 C++ 언어와는 다음과 같은 여러 가지 차이점이 있습니다.&lt;/p&gt;

&lt;p&gt;첫째로, Java의 모든 사용자 정의 데이터 타입은 클래스입니다. C++ 언어는 C 언어의 상위호환이기 때문에, 클래스가 아니라 함수와 같은 프로시저도 선언이 가능한 것과 대조적입니다. 또한, Java는 구조체(Structure)를 지원하지 않습니다. Java에서 모든 객체는 힙에서 할당되고, 참조 변수를 통해 접근할 수 있습니다. 게다가, Java 언어의 메소드 몸체는 반드시 헤더와 함께 나타나야 합니다. 따라서 Java의 추상 데이터 타입은 단일 구문 단위로 선언되고 정의됩니다.&lt;/p&gt;

&lt;p&gt;또한 Java 언어에서는 &lt;strong&gt;쓰레기 수집기(Garbage Collector)&lt;/strong&gt;가 있기 때문에 C++ 언어와 달리 소멸자가 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 추상 데이터 타입을 매개변수화하는 것에 대해 알아보겠습니다. 이것은 때때로 매우 편리한데, 이전의 예제인 스택을 여러 개의 스칼라 데이터 타입에 사용할 필요가 있는 경우, 각각의 데이터 타입에 대해 별도의 스택 추상화를 작성할 필요가 없기 때문입니다. 만약 임의의 스칼라 타입 원소를 저장할 수 있는 하나의 스택 추상 데이터 타입을 설계할 수 있다면, 프로그램의 재사용을 통해 전체 코드의 길이를 압축할 수 있습니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 나온 코드는 Ada 언어에서의 &lt;strong&gt;제네릭 패키지(Generic Package)&lt;/strong&gt;입니다. 이전에 나왔던 스택 코드를 다양한 스칼라 데이터 타입에 대해 사용할 수 있게 수정한 버전입니다. 주요한 점은 MAX_SIZE를 통해 스택의 크기를 조절할 수 있고, 데이터 타입이 ELEMENT_TYPE 으로 바뀌었다는 것입니다. 스택 객체를 생성하는 부분을 보면, 앞의 숫자를 통해 스택의 크기를 정의하고 뒷쪽의 자료형을 통해 원하는 자료형으로 생성하는 모습을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 추상 데이터 타입 매개변수화는 정적 타입 언어만의 고려사항입니다. 왜냐하면 Ruby나 Python과 같은 동적 타입 언어에서는 이러한 매개변수화를 사용하지 않고도 임의의 스칼라 데이터를 저장할 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;11장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Implementing Subprograms</title><link href="http://localhost:4000/pl/implementing-subprograms/" rel="alternate" type="text/html" title="Implementing Subprograms" /><published>2023-09-18T00:00:00+09:00</published><updated>2023-09-18T00:00:00+09:00</updated><id>http://localhost:4000/pl/implementing-subprograms</id><content type="html" xml:base="http://localhost:4000/pl/implementing-subprograms/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10장의 주제는 부프로그램의 구현입니다. 이번 장을 한 문단으로 요약하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“이 장의 목적은 주요 명령형 언어에서 부프로그램을 구현하는 방법을 알아보는 것입니다. 토론은 독자에게 그러한 언어가 어떻게 “작동”하는지에 대한 통찰력을 제공합니다. 부프로그램 구현의 어려움이 증가하는 이유는 재귀에 대한 지원과 비지역 변수 접근에 대한 지원을 포함해야 하기 때문입니다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램의 호출과 반환 연산을 합쳐서 &lt;span style=&quot;color:red&quot;&gt;부프로그램 연결(Subprogram Linkage)&lt;/span&gt;이라고 합니다. 부프로그램의 구현 방법은 부프로그램 연결의 의미를 기반으로 해야 합니다.&lt;/p&gt;

&lt;p&gt;대부분의 언어에서 부프로그램 호출에는 많은 동작이 수행됩니다. 특히 중요한 부분은 바로 지난 장에서 다루었던 매개변수 전달 방법입니다. 만약 지역 변수가 정적 변수가 아니라면, 부프로그램을 호출할 때 부프로그램에서 선언된 지역 변수를 위한 기억 공간을 할당해야 하고, 그 기억 공간에 지역 변수를 바인딩 하고, 호출된 부프로그램의 실행 상태를 저장해야 합니다.&lt;/p&gt;

&lt;p&gt;또한 부프로그램을 호출하는 과정에서 프로그램의 제어권을 부프로그램으로 전달해야 하고, 부프로그램의 수행이 종료되면 그 제어권을 다시 적당한 장소로 제어권을 반환하는 과정도 마련해야 합니다. 만약 해당 프로그래밍 언어가 중첩된 부프로그램을 지원한다면, 호출된 부프로그램에 비지역 변수에 접근할 수 있는 방안도 마련해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램 반환에 필요한 과정은 호출에 요구되는 과정보다는 덜 복잡합니다. 부프로그램이 out mode이거나 inout mode이고 Pass by Copy로 구현되는 매개변수를 가진다면, 반환 과정의 첫 번째는 관련된 형식 매개변수의 지역 값을 실 매개변수로 옮겨주는 것입니다. 다음으로는 부프로그램의 지역 변수에 사용된 기억 공간을 해제하고, 비지역 참조에 사용되는 메커니즘을 해제합니다. 마지막으로, 제어권을 호출한 프로그램에게 다시 반환합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 매우 &lt;strong&gt;간단한&lt;/strong&gt; 부프로그램을 구현해봅시다. 여기서 간단하다는 뜻은 중첩 부프로그램이 없고, 모든 지역 변수가 정적이라는 것을 의미합니다. 초기 Fortran 버전이 바로 이런 부프로그램을 갖는 언어입니다. 초기 Fortran 언어에서는 부프로그램이 재귀적으로 사용될 수 없었고, Fortran 77에서 비지역 변수에 대한 모든 참조는 COMMON을 통해 이루어졌습니다. 또한 부프로그램에 선언된 변수는 정적으로 할당되었습니다.&lt;/p&gt;

&lt;p&gt;Fortran 77에서 부프로그램 호출은 이러한 과정을 갖고 있었습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;현재 프로그램 단위의 실행 상태를 저장&lt;/li&gt;
  &lt;li&gt;매개변수 전달 과정을 수행&lt;/li&gt;
  &lt;li&gt;반환 주소를 호출된 프로그램에게 전달&lt;/li&gt;
  &lt;li&gt;제어권을 호출된 프로그램에 전달&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 77에서 부프로그램 반환은 이러한 과정을 갖고 있었습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pass by Value Result 매개변수나 out mode 매개변수가 사용된다면, 해당 매개변수의 현재 값을 실 매개변수로 전달&lt;/li&gt;
  &lt;li&gt;부프로그램이 함수인 경우, 함수 (반환)값을 호출자가 접근할 수 있는 위치로 이동&lt;/li&gt;
  &lt;li&gt;호출자의 실행 상태를 복구&lt;/li&gt;
  &lt;li&gt;제어권을 호출자에게 전달&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 호출 및 반환 과정에는 다음에 대한 저장 공간이 필요합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;호출자의 상태 정보&lt;/li&gt;
  &lt;li&gt;매개변수&lt;/li&gt;
  &lt;li&gt;반환 주소&lt;/li&gt;
  &lt;li&gt;함수의 반환값&lt;/li&gt;
  &lt;li&gt;(필요한 경우) 부프로그램에서 사용되는 임시 기억 장소&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그런데 호출 과정과 반환 과정을 호출자와 호출된 부프로그램에게 분배하는 것이 문제입니다. 다행히 간단한 부프로그램의 경우, 이것을 분배하는 것이 쉬운 편입니다. 호출에서의 과정은 1을 제외하고 호출자에서 수행되어야 합니다. 실행 상태를 저장하는 것은 호출자에서 저장할 수도 있고, 호출된 부프로그램에서 저장할 수도 있습니다. 반환에서는 두 번째 과정을 제외하고는 호출된 부프로그램에서 수행해야 합니다. 두 번째 과정은 마찬가지로 호출자에서 수행할 수도 있고, 호출된 부프로그램에서 수행할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 77과 같은 간단한 부프로그램은 각각 고정된 크기의 두 부분으로 구성됩니다. 하나는 부프로그램을 위한 정적인 실제 코드이고 나머지 하나는 지역 변수와 호출/반환 작업을 하기 위핸 데이터 영역입니다. 간단한 부프로그램의 경우 둘 다 고정된 크기를 갖습니다.&lt;/p&gt;

&lt;p&gt;부프로그램에서 코드가 아닌 부분은 부프로그램의 활성화(즉, 실행)에 관련된 부분이기 때문에 활성화 레코드(Activation Record)라고 합니다. Fortran 77의 경우에는 재귀를 지원하지 않기 때문에, 한번에 하나의 활성 부프로그램만 있을 수 있습니다. 따라서 부프로그램의 활성화 레코드는 단지 하나만 존재합니다. 게다가 간단한 부프로그램에서 활성화 레코드는 고정 크기이기 때문에, 정적으로 할당할 수 있습니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 나온 그림은 주프로그램(Main)과 두 개의 부프로그램 A, B로 이루어진 프로그램을 나타냅니다. 이러한 프로그램 구성은 컴파일러에 의해 전부 만들어지는 것은 아닙니다. 만약 독립적으로 컴파일이 수행되었다면 3개의 프로그램 단위는 각각 다른 날에 컴파일 되었을 수도 있습니다. 각각의 프로그램 단위가 컴파일 될 때, 외부 부프로그램의 참조 리스트와 더불어 기계어 코드가 파일에 작성됩니다. 따라서 슬라이드에 나온 그림은 운영체제의 일부인 &lt;strong&gt;링커(Linker)&lt;/strong&gt;에 의해 통합됩니다. 링커가 주프로그램을 위해 호출되었을 때, 링커는 주프로그램에 참조된 부프로그램을 포함한 파일을 찾고, 그 파일들을 메모리에 적재합니다. 그 후, 링커는 주프로그램에 있는 부프로그램 호출의 목적지 주소를 부프로그램의 진입 주소로 설정합니다. 이러한 과정을 모든 부프로그램에 대해서 동일한 작업을 실시합니다.&lt;/p&gt;

&lt;p&gt;이 과정을 슬라이드에 나온 구조에 빗대서 설명하면, 링커는 Main을 위해 호출된 후 부프로그램 A, B의 기계어 코드 프로그램과 활성화 레코드를 찾아 Main의 코드와 함께 메모리에 적재합니다. 그런 다음 A, B에 대한 호출과 A, B, Main에서 라이브러리 부프로그램에 대한 호출의 목적지 주소를 &lt;strong&gt;패치(Patch)&lt;/strong&gt;합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 스택 동적 지역 변수를 갖는 언어의 부프로그램을 구현하는 방법을 알아보겠습니다. 스택 동적 지역 변수의 가장 중요한 장점 중 하나는 재귀적 부프로그램을 지원한다는 것입니다. ALGOL과 그로부터 영향을 받은 언어들에서의 부프로그램 연결은 다음과 같은 이유로 간단한 부프로그램의 연결보다 훨씬 복잡합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;매개변수를 전달하는 방법이 두 가지 이상입니다. 예를 들어, Modula-2에서는 Pass by Value와 Pass by Reference를 지원합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부프로그램에 선언된 변수가 동적으로 할당되는 경우가 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;재귀는 여러 개의 부프로그램이 동시에 활성화될 수 있는 가능성을 추가합니다. 그렇기 때문에 활성화 레코드에는 여러 개의 인스턴스가 필요합니다. 각각의 활성화에는 반환 주소와 함께 형식 매개변수와 동적으로 할당된 지역 변수의 복사본이 필요합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ALGOL과 그와 유사한 언어들에서는 정적 범위를 사용하여 비지역 변수에 대한 접근을 제공합니다. 이러한 비지역 변수에 대한 지원은 연결 과정의 일부로 들어가야만 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로시저를 활성화하기 위해서는 프로시저에 대한 활성화 레코드 인스턴스를 동적으로 생성해야 합니다. 호출 및 반환 체계에서 마지막으로 호출된 부프로그램이 첫 번째로 종료되기 때문에 활성화 레코드 인스턴스는 스택으로 구현하는 것이 합리적입니다. 이 스택은 실행 시간(Run-time) 시스템의 일부이기 때문에 &lt;strong&gt;실행 시간 스택(Run-time Stack)&lt;/strong&gt;이라고 부릅니다. 부프로그램이 재귀적이든, 그렇지 않든 모든 프로시저의 활성화는 스택에 활성화 레코드 인스턴스를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다행히 대부분의 언어에서 주어진 부프로그램의 활성화 레코드 형식은 컴파일 시간에 알려집니다. 게다가, 대부분의 지역 데이터는 고정 크기이므로 활성화 레코드의 크기 또한 컴파일 시간에 알 수 있습니다. 그러나, Ada와 같이 지역 배역의 크기가 실 매개변수의 값에 영향을 받는 언어는 크기가 동적으로 정해질 수 있습니다. 그렇기 때문에 스택 동적 변수를 갖는 언어에서는 활성화 레코드가 동적으로 생성됩니다. 활성화 레코드의 형식은 활성화 레코드 인스턴스의 템플릿입니다. (지역 변수, 매개변수, 동적 링크, 반환 주소)&lt;/p&gt;

&lt;p&gt;지역 변수는 활성화 레코드 내의 저장소로 바인딩됩니다. 정적 링크(=정적 범위 포인터)는 비지역 변수에 대한 접근에 사용되는 링크로써, 정적으로 상위에 있는 활성화 레코드 인스턴스를 가리킵니다. 동적 링크는 당연히 동적으로 상위에 있는 활성화 레코드 인스턴스를 가리킵니다. 그렇다면 동적 링크는 정적 영역을 갖는 언어에서 필요하지 않나 싶겠지만, 정적 영역을 갖는 경우 이 링크는 프로시저의 실행이 완료될 때 현재 활성화 레코드 인스턴스를 제거하는데 사용되고, 또 실행 시간 오류가 발생할 때 추적(Traceback) 정보를 제공하기 위해 사용됩니다. 동적 영역 언어라면 당연히 동적으로 비지역 변수에 접근하기 위해 사용됩니다.&lt;/p&gt;

&lt;p&gt;반환 주소는 코드 세그먼트와 오프셋으로 이루어져 있으며, 실 매개변수는 호출자가 제공하는 값이나 주소를 통해 접근합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 예제를 통해 스택 동적 변수를 갖는 부프로그램이 어떤 활성화 레코드를 갖는지 알아보겠습니다. 왼쪽의 코드는 Pascal 언어로 만들어진 프로시저입니다. 가장 먼저 프로시저의 매개변수를 확인해 보면, total은 var로 선언되었기 때문에 Pass by Reference 매개변수이고, part라는 변수는 그렇지 않기 때문에 Pass by Value 입니다. 따라서 두 개의 매개변수가 스택에 쌓일 때, part는 그 값이, total은 그 주소가 저장된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그 이후에는 프로시저 내에서 발생하는 지역 변수가 스택에 쌓입니다. 교재와는 순서가 좀 다른데, 교재에서는 list[1]부터 list[5]까지 쌓인 후 sum의 변수가 스택에 저장되었지만, 여기서는 그 반대로 저장이 되었습니다. 다만 그 순서는 크게 중요하지 않은 것 같습니다. 다음으로 반환 주소와 정적 링크, 동적 링크가 차례로 저장되는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;지난 장에서, 부프로그램이 호출될 때부터 실행이 끝날 때 활성 상태라는 것을 배웠습니다. 따라서 부프로그램의 실행이 끝난 이후에는 활성화 레코드가 더 이상 의미가 없습니다. 따라서 그 이후에는 활성화 레코드가 해제됩니다.&lt;/p&gt;

&lt;p&gt;또한 예제와 같이 매개변수 항상 스택에 전달되는 것은 아닙니다. RISC에서 동작하는 컴파일러 중 일부분은 매개변수를 레지스터에 전달하기도 합니다. 왜냐하면 RISC는 CISC보다 더 많은 레지스터를 갖고 있기 때문입니다. 그러나 여기에서 그것까지는 고려하지 않고, 매개변수는 항상 스택에 저장된다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 본격적으로 재귀가 없고, 비지역 변수에 대한 참조가 없는 예제에서 활성화 레코드를 만들어보겠습니다.&lt;/p&gt;

&lt;p&gt;역시 코드는 왼쪽과 같이 주어졌습니다. 간단하게 보시면, MAIN_1 주프로그램에서 부프로그램 B를 호출하고, 부프로그램 B에서는 부프로그램 A를 호출합니다. 그리고 부프로그램 A에서는 C를 호출합니다. 구조상으로 부프로그램 C는 부프로그램 A 안에 있네요. 이 상황에서, 슬라이드와 같이 지점 1, 2, 3에서 각각 활성화 레코드를 그려보겠습니다.&lt;/p&gt;

&lt;p&gt;지점 1에서는 프로시저 MAIN_1과 B가 활성화되어있는 상태입니다. 따라서 활성화 레코드에는 MAIN_1과 B만 있어야 합니다. 따라서 가장 아래에는 MAIN_1에서 선언된 지역 변수인 P가 스택 가장 아래에 위치합니다. 그 다음에 스택에 쌓이는 것은 프로시저 B의 매개변수 R입니다. 다음으로는 프로시저 B의 지역 변수인 S, T가 스택에 쌓입니다. 그 후, 반환 주소, 정적 링크, 동적 링크가 차례대로 스택에 쌓이게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 지점 2에서의 스택 상황을 확인해보겠습니다. 지점 2에서는 프로시저 B가 프로시저 A를 호출한 상황입니다. 이 때 활성화된 프로시저는 MAIN_1, B, A 입니다. 따라서, 활성화 레코드에는 이전에 쌓였던 MAIN_1와 B의 데이터가 그대로 남아있습니다. 여기에 프로시저 A의 활성화 레코드가 그 위에 쌓이게 됩니다. 가장 먼저 프로시저 A의 매개변수인 X가 쌓이고, 그 위로 프로시저 A의 지역 변수인 Y, 그 위에는 반환 주소와 정적 링크, 동적 링크 순서대로 스택에 쌓이게 됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로 지점 3에서의 스택 상황을 확인하겠습니다. 이 때 활성화된 프로시저는 MAIN_1, B, A, C입니다. 따라서 활성화 레코드에는 이전에 쌓였던 MAIN_1, B, A의 데이터가 그대로 남아있습니다. 여기에 프로시저 C의 활성화 레코드가 그 위에 쌓이게 됩니다. 가장 먼저 프로시저 C의 매개변수인 Q가 쌓입니다. 그러나 프로시저 C의 지역 변수는 없기 때문에 그 다음에는 바로 반환 주소와 정적 링크, 동적 링크 순서대로 스택에 쌓이게 됩니다.&lt;/p&gt;

&lt;p&gt;이 예제에서 지점 1 -&amp;gt; 2 -&amp;gt; 3의 스택이 계속 쌓이기만 하는 것을 보고 “활성화 레코드는 스택에 계속 쌓이기만 하는구나”라고 착각을 하실 수도 있는데, 이것은 그러한 이유 때문이 아닙니다. 이 예제에서 지점 3에 도달할 때까지 비활성화되는 프로시저가 없기 때문에 스택에 계속 쌓이기만 하는 것입니다. 만약 지점 2에서 3으로 갈 때 프로시저 A가 비활성화된다면, 지점 3에서 A의 활성화 레코드는 스택에서 해제되고, 그 자리에 프로시저 C의 활성화 레코드가 위치하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 활성화 레코드에서 특정 시간에 스택에 존재하는 동적 링크의 모음을 &lt;span style=&quot;color:red&quot;&gt;동적 체인(Dynamic Chain)&lt;/span&gt;, 또는 호출 체인(Call Chain)이라고 합니다. 동적 체인은 실행이 현재 위치(활성화 레코드 스택의 꼭대기에 있는 부프로그램의 위치)에 어떻게 도달했는지에 대한 동적 기록을 나타냅니다.&lt;/p&gt;

&lt;p&gt;지역 변수에 대한 참조는 코드에서 활성화 레코드의 시작 지점으로부터 오프셋으로 나타내는데, 이것을 &lt;span style=&quot;color:red&quot;&gt;지역 오프셋(Local Offset)&lt;/span&gt;이라고 합니다. 활성화 레코드에 있는 변수의 지역 오프셋은 활성화 레코드와 관련된 부프로그램에서 선언된 변수의 순서, 타입, 크기를 사용하여 컴파일 시간에 결정됩니다.&lt;/p&gt;

&lt;p&gt;다음은 재귀를 사용하여 팩토리얼(Factorial)을 계산하는 프로그램에 대해 활성화 레코드 스택을 구해보겠습니다. 먼저, 코드의 구조를 살펴보면 TEST라는 주프로그램에서 FACTORIAL 이라는 함수를 호출합니다. FACTORIAL 함수에서는 특정 조건에 다다를 때까지 계속 자기 자신을 호출하는 구조입니다. 이 예제는 이전과 달리 하나의 함수를 계속 호출하는 구조이기 때문에 활성화 레코드의 포멧은 동일합니다. (슬라이드의 오른쪽 그림) FACTORIAL 함수는 지역 변수가 없지만, 반환 값이 있기 때문에 함수 값이 활성화 레코드에 추가됩니다. 이러한 구조에서, 지점 1, 2, 3에서의 활성화 레코드 스택이 어떻게 나오는지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 이 그림들은 각각 첫 번째, 두 번째, 세 번째 호출이 되었을 때 지점 1에서의 활성화 레코드 스택을 나타낸 이미지입니다. 왜 동일한 지점의 활성화 레코드 스택이 3개 나오냐면, 주프로그램 TEST에서 FACTORIAL(3)으로 호출했기 때문에 이 함수가 3번 호출되기 때문입니다. 따라서 FACTORIAL 함수가 3번 호출될 동안 스택에서는 아무것도 해제되지 않고 계속 쌓이기만 합니다.&lt;/p&gt;

&lt;p&gt;스택 맨 아래에는 당연히 주프로그램 TEST의 지역 변수인 VALUE가 저장되어 있고, 그 위에는 FACTORIAL 함수의 활성화 레코드가 쌓입니다. 이 때, 반환 주소는 첫 번째, 두 번째, 세 번째가 모두 달라집니다. 첫 번째 FACTORIAL 함수의 반환 주소는 주프로그램인 TEST가 되지만, 두 번째 FACTORIAL 함수의 반환 주소는 첫 번째 호출한 FACTORIAL 함수가 됩니다. 마찬가지로 세 번째 FACTORIAL 함수의 반환 주소는 두 번째 FACTORIAL 함수가 됩니다. 이미지 상으로 두 번째와 세 번째의 반환 주소가 동일해보이지만, 의미상으로는 다르다는 것을 주의해주세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림의 4~6은 첫 번째, 두 번째, 세 번째 호출이 되었을 때 지점 2에서의 활성화 레코드 스택을 나타낸 이미지입니다. 지점 2는 특이하게 마지막에 호출된 FACTORIAL 함수에서 가장 먼저 도달합니다. 그렇기 때문에 첫 번째로 지점 2에 도착할 때 활성화 레코드 스택은 3개의 FACTORIAL 함수의 활성화 레코드가 쌓인 상태입니다. 지점 1에서는 세 번째 호출까지 함수 값을 알 수 없었지만, 지점 2는 END 시점이기 때문에 이 지점에서 함수 값 또한 1로 계산이 끝난 상황입니다.&lt;/p&gt;

&lt;p&gt;두 번째 도착하는 지점 2에서는 세 번째 호출된 FACTORIAL이 종료된 상황이기 때문에 활성화 레코드 스택에서 제거되었습니다. 이 때도 FACTORIAL의 함수 값이 계산된 상황이므로 함수 값에 2가 저장됩니다. 마찬가지로 세 번째 도착하는 지점 2에서는 두 번째 호출된 FACTORIAL이 종료된 상황이기 때문에 활성화 레코드 스택에서 제거되었습니다. 물론 FACTORIAL의 함수 값이 계산 가능한 지점이므로 함수 값에 6이 저장됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로 VALUE의 값을 출력하는 지점 3에서는 모든 FACTORIAL 함수가 종료된 시점이므로 TEST의 지역 변수인 VALUE만 남아있게 되는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C 언어 기반이 아닌 정적 영역 언어는 스택 동적 지역 변수를 사용할 때 부프로그램이 중첩되는 것을 허용하기도 합니다. 이러한 언어의 대표적인 예시는 Ada, Python, JavaScript 등이 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 이전 슬라이드에서 보았듯이, 비지역으로 접근할 수 있는 모든 변수는 활성화 레코드 스택에 존재합니다. 여기서 중첩된 부프로그램을 갖는 정적 영역 언어에서 비지역 변수를 참조하기 위해서는 두 단계의 과정이 필요합니다. 첫 번째 단계는 스택에서 그 변수가 할당된 활성화 레코드를 찾는 것입니다. 두 번째 단계는 변수의 지역 오프셋을 사용하여 변수에 접근하는 것입니다.&lt;/p&gt;

&lt;p&gt;하지만 원하는 변수를 갖고 있는 정확한 활성화 레코드를 찾는 것은 어렵습니다. 지정된 부프로그램에서는 정적으로 상위 범위에 선언된 변수만 비지역으로 접근할 수 있습니다. 그런데 모든 정적 상위에 있는 활성화 레코드는 중첩된 프로시저에 의해 해당 인스턴스의 변수가 참조될 때 스택에 항상 존재합니다. 즉, 모든 정적 상위 부프로그램이 활성화일 때만 프로시저를 호출할 수 있습니다. 만약 어떤 특정한 정적 상위 프로그램이 활성화 상태가 아니라면, 그 지역 변수는 기억 공간에 바인딩되지 않았을 것이기 때문에 접근을 허용하는 것의 무의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비지역 참조에서 올바른 선언은 영역을 살펴볼 때 가장 먼저 발견되는 것입니다. (즉, 가장 가깝게 중첩된 첫 번째 선언) 따라서 비지역 참조를 지원하기 위해서는 스택에서 해당 정적 상위에 해당하는 모든 활성화 레코드를 찾을 수 있어야 합니다. 이것을 구현하는 방법은 &lt;span style=&quot;color:red&quot;&gt;정적 체인(Static Chain)&lt;/span&gt;과 &lt;span style=&quot;color:red&quot;&gt;디스플레이(Display)&lt;/span&gt;라는 것이 있습니다. 이제부터 이 두 가지 방법에 대해 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;중첩 부프로그램이 가능한 언어에서 정적 영역을 구현하는 가장 일반적인 방법은 정적 체인입니다. 이 방법에서는 정적 링크라고 불리는 새로운 포인터가 활성화 레코드에 추가됩니다. 정적 링크는 비지역 변수에 접근하기 위해 사용되며, 정적 체인은 활성화 레코드를 연결하는 정적 링크의 체인입니다. 예를 들어, 어떤 프로시저 P가 실행되는 중에, P로 인해 생성된 활성화 레코드의 정적 링크는 P의 정적 상위 프로그램의 활성화 레코드를 가리킵니다. 따라서 정적 체인은 정적인 부모 프로그램을 시작으로, 실행 중인 부프로그램의 모든 정적 상위 프로그램을 연결합니다.&lt;/p&gt;

&lt;p&gt;만약 비지역 변수에 대한 참조가 발생한다면, 그 변수를 포함하는 정적 상위 프로그램의 활성화 레코드를 찾을 때까지 정적 체인을 탐색함으로써 찾을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 이렇게 영역이 중첩되는 것은 컴파일 시간에 알려지기 때문에 컴파일러는 이러한 참조가 지역이 아니라는 것 뿐만 아니라, 실제로 비지역 개체를 포함하는 활성화 레코드에 도달하는 데 필요한 정적 체인의 길이도 알 수 있습니다. 그러한 길이를 &lt;strong&gt;정적 깊이(Static Depth)&lt;/strong&gt;라고 합니다. 정적 깊이는 정적 영역이 가장 바깥쪽 영역으로부터 얼마나 깊게 중첩되어 있는지를 나타내는 정수값입니다.&lt;/p&gt;

&lt;p&gt;변수 X의 비지역 참조를 위한 정확한 활성화 레코드에 도착하는데 필요한 체인의 길이를 &lt;strong&gt;중첩 깊이(Nesting Depth)&lt;/strong&gt;라고 합니다. 중첩 깊이는 X를 참조하는 부프로그램의 정적 깊이와 X가 선언된 부프로그램의 정적 깊이의 차이입니다. 중첩 깊이를 &lt;strong&gt;체인 오프셋(Chain Offset)&lt;/strong&gt;이라고도 부릅니다. 실제로 참조할 때는 정수 순서쌍 (체인 오프셋, 지역 오프셋)으로 표시됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 슬라이드에 나온 코드에서는 A - B - C 순서로 중첩이 되어 있습니다. 먼저 각 프로시저의 정적 깊이를 계산해보면, 가장 바깥에 있는 A는 0, B는 1, C는 2로 계산할 수 있습니다. 만약 프로시저 C에서 프로시저 A에 있는 비지역 변수를 참조하고 싶다면 중첩 깊이를 계산해야 하는데, 이 때의 중첩 깊이는 C의 정적 깊이(2) - A의 정적 깊이(0) = 2가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 좀더 복잡한 프로그램을 가지고 참조를 위한 깊이를 계산해 보겠습니다. 이 프로그램은 MAIN_2라는 주프로그램에서 부프로그램 BIGSUB를 호출하고, BIGSUB는 SUB2 부프로그램을 호출합니다. SUB2는 SUB3 부프로그램을 호출하고, SUB3은 SUB1 부프로그램을 호출합니다. 그러나 프로그램의 구조는 호출과 일치하지 않음을 주의해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;먼저 SUB1의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A := B + C;&lt;/code&gt; 지점에서 A, B, C를 접근하기 위한 중첩 깊이를 계산해보겠습니다. A는 SUB1 내에서 정의되어 있기 때문에 당연히 0이 됩니다. B와 C는 바로 위의 BIGSUB에서 정의되어 있기 때문에 1이 됨을 쉽게 계산할 수 있습니다. 그리고 이들의 지역 오프셋을 계산하기 위해서는 활성화 레코드를 먼저 계산해야 합니다. 활성화 레코드를 계산하는 방법은 이전에 설명했기 때문에 생략하겠습니다. 활성화 레코드의 0, 1, 2는 각각 동적 링크, 정적 링크, 반환 주소를 저장하기 때문에 지역 변수는 그 다음부터 저장됩니다. BIGSUB는 A, B, C 순서대로 저장되었기 때문에 각각 3, 4, 5에 저장됨을 알 수 있습니다. 따라서 A의 참조쌍은 (0, 3), B의 참조쌍은 (1, 4), C의 참조쌍은 (1, 5)가 됨을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;마찬가지로 SUB3의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E := B + A;&lt;/code&gt; 지점에서 E, B, A의 참조쌍을 계산해보겠습니다. E는 SUB3의 지역 변수이기 때문에 중첩 깊이가 0이 됩니다. B는 SUB2의 B를 참조하기 때문에 중첩 깊이가 1이 됩니다. A는 BIGSUB의 A를 참조하기 때문에 중첩 깊이가 2가 됩니다. 이제 지역 오프셋을 계산해보면, SUB3은 지역 변수로 C, E를 갖고 있습니다. 따라서 C의 지역 오프셋이 3, E의 지역 오프셋이 4가 됩니다. SUB2는 지역 변수로 B, E를 가지고 있으므로 B의 지역 오프셋은 3, BIGSUB는 지역 변수로 A, B, C를 가지고 있기 때문에 지역 오프셋은 3이 됩니다. 따라서 E의 참조쌍은 (0, 4), B는 (1, 3), A는 (2, 3)이 됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로 SUB2의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A := D + E;&lt;/code&gt; 지점에서 A, D, E의 참조쌍을 계산해보겠습니다. A는 BIGSUB의 A를 참조하므로 참조쌍이 (1, 3)이 됩니다. 그런데 D는 SUB2의 상위 프로시저인 BIGSUB에 선언되어 있지 않고, 그보다 상위 프로시저인 MAIN_2에도 선언되어 있지 않습니다. 따라서 D는 선언되어 있지 않은 변수이므로 Error가 발생합니다. E는 SUB2의 지역 변수이므로 (0, 4)가 됨을 쉽게 계산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전 슬라이드에 제시된 프로그램의 구조를 토대로 활성화 레코드를 나타낸 모습입니다. 이 그림의 핵심은 정적 링크과 동적 링크가 어떻게 연결되어 있는지 입니다. 정적 링크는 프로그램 구조상으로 자신의 상위 프로시저를 가리킵니다. 예를 들어, BIGSUB의 정적 링크는 MAIN_2를 가리키고, SUB2의 정적 링크는 BIGSUB를 가리키는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;동적 링크는 자신을 호출한 프로시저를 가리킵니다. 예를 들어, SUB1의 동적 링크는 SUB3을 가리키고, SUB3의 동적 링크는 SUB2를 가리킵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면, 프로그램 실행 중에 정적 체인이 어떻게 유지되는 것일까요? 정적 체인은 부프로그램이 호출되거나 반환될 때마다 변경되므로, 그 때마다 수정되어야 합니다. 부프로그램이 종료될 때는 해당 부프로그램의 활성화 레코드가 스택에서 제거되는데, 그 활성화 레코드가 가리키는 포인터는, 활성화 레코드가 제거될 때 같이 해제되므로 신경을 쓸 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;그러나 새로운 부프로그램이 호출될 때는 문제가 복잡해집니다. 정확한 자신의 상위 프로시저를 컴파일 시간에 알 수 있다고 하더라도, 호출 시에는 그 상위 프로시저의 활성화 레코드가 스택 어디에 있을지는 모르기 때문입니다. 이 문제를 해결하는데는 두 가지 방법이 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;첫 번째 방법은 실행 시간에 상위 영역의 첫 번째 항목을 찾을 때까지 동적 체인의 활성화 레코드를 탐색하는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;두 번째 방법은 컴파일 시간에 호출자와 호출된 프로그램을 선언한 프로시저 사이의 중첩 깊이를 계산하고, 호출이 발생할 때, 호출된 프로시저의 활성화 레코드의 정적 링크를 호출자의 정적 체인에서 컴파일러 시간에 계산된 중첩 깊이와 동일한 링크 수 만큼 이동하여 결정하는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두 번째 방법에 대해 좀 더 자세히 설명하자면, 이전 슬라이드의 스택 상황에서 SUB3이 SUB1을 호출하는 때를 생각해봅시다. 컴파일러는 SUB3의 중첩 깊이가 SUB1을 선언한 프로시저인 BIGSUB의 2단계 안쪽이라는 것을 알 수 있습니다. 따라서 SUB3이 SUB1을 호출할 때, 활성화 레코드에서 정적 체인의 두 번째 링크가 가리키는 활성화 레코드를 가리키도록 설정하는 것입니다. (SUB3 -&amp;gt; SUB2 -&amp;gt; BIGSUB) 따라서 SUB1의 활성화 레코드에서 정적 링크는 BIGSUB를 가리키도록 설정되는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정적 체인의 단점은 비지역 변수에 참조하는 비용이 지역 변수의 참조보다 크다는 것입니다. 비지역 변수를 참조할 때마다 해당 변수가 선언이 된 영역을 찾기 위해서 정적 체인의 링크를 따라가야합니다. 해당 비지역 변수가 현재 위치에서 멀면 멀 수록 그 링크를 많이 따라가야 합니다. 다행히 실제 그렇게까지 먼 비지역 변수를 참조하는 경우는 드물지만, 정적 체인의 진짜 단점은 &lt;strong&gt;시간이 중요한 프로그램(Time Critical Program)&lt;/strong&gt;을 작업하는 경우 프로그래머가 비지역 변수를 참조할 때 그 비용을 추정하는 것이 어렵다는 것입니다. 왜냐하면 각각의 참조의 비용은 중첩 깊이에 따라 달라지기 때문입니다. 코드가 수정될 때마다 중첩의 깊이가 변화할 수 있고, 그로 인해 코드를 변경하기 전과 변경한 후의 시간이 얼마나 차이가 날지 계산하기 어려워지는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;정적 체인의 대안 중 하나는 &lt;strong&gt;디스플레이(Display)&lt;/strong&gt;입니다. 이 방법은 정적 링크를 활성화 레코드에 저장하지 않고, 디스플레이라는 단일 배열에 저장합니다. 특정 시간에서 디스플레이의 내용은 접근 가능한 활성화 레코드 인스턴스의 주소 목록입니다. 이것은 각각의 활성 범위에 대해 하나씩 나타나며, 중첩된 순서대로 표시됩니다.&lt;/p&gt;

&lt;p&gt;비지역 변수의 참조 쌍은 (디스플레이 오프셋, 지역 오프셋)으로 표현합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디스플레이에 저장된 활성화 레코드에 대한 링크는 디스플레이 오프셋이라는 정적으로 계산된 값을 사용하여 찾습니다. 활성화 레코드 내의 지역 오프셋은 정적 체인에서와 동일한 용도로 사용됩니다. 일반적으로 디스플레이에서 $k$라는 위치에 있는 포인터는 정적 깊이가 $k$인 프로시저에 대한 활성화 레코드를 가리킵니다.&lt;/p&gt;

&lt;p&gt;만약 새로운 프로시저가 호출되거나 기존의 프로시저가 종료될 때 디스플레이를 수정해야 한다면 다음과 같은 과정이 발생합니다. 정적 길이가 $k$인 프로시저 P의 호출이 발생할 때, 새 활성화 레코드에 디스플레이 $k$ 위치에 있는 포인터 복사본을 저장합니다. 그리고 디스플레이에서 $k$ 위치에 P의 활성화 레코드에 대한 링크를 배치합니다. 프로시저 종료 시, 종료된 부프로그램의 활성화 레코드에 저장된 포인터가 디스플레이에 다시 배치됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디스플레이를 이해하기 위해 예제를 하나 풀어보겠습니다. 프로시저 Q가 프로시저 P를 호출하는 상황이라고 가정해봅시다. Psd를 P의 정적 깊이, Qsd를 Q의 정적 깊이라고 정의하겠습니다. 그렇다면 가능한 경우는 1) Qsd = Psd, 2) Qsd &amp;lt; Psd, 3) Qsd &amp;gt; Psd 이렇게 3가지가 나오게 됩니다.&lt;/p&gt;

&lt;p&gt;프로그램 구조는 슬라이드 왼쪽에 나와있는 것으로 가정하겠습니다. 먼저 SUB2에서 SUB1을 호출할 때, 이 두 프로시저는 같은 정적 깊이를 갖는 경우입니다. 그렇다면 디스플레이 0번째 인덱스는 정적 깊이가 0인 MAIN_3을 가리키게 되고, 1번째 인덱스는 정적 깊이가 1인 BIGSUB를 가리키게 됩니다. SUB1을 호출하기 전에는 2번째 인덱스는 정적 깊이가 2인 SUB2를 가리키고 있습니다. 그런데 이 상황에서 SUB1을 호출한다면, SUB1은 SUB2와 마찬가지로 정적 깊이가 2이므로, 디스플레이의 2번째 인덱스가 SUB1을 가리키도록 수정됩니다.&lt;/p&gt;

&lt;p&gt;두 번째는 SUB2가 SUB3을 호출하는 상황을 확인해보겠습니다. 이 경우에는 SUB3의 정적 깊이가 SUB2보다 깊은 경우입니다. 이 경우는 너무 간단합니다. 그냥 디스플레이의 다음 인덱스가 새로 호출된 SUB3을 가리키도록 설정하면 끝나기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 프로그램 구조를 조금 바꾸었습니다. 호출 순서는 MAIN_4 -&amp;gt; BIGSUB -&amp;gt; SUB2 -&amp;gt; SUB3 -&amp;gt; SUB1 -&amp;gt; SUB4 입니다. SUB3이 호출될 때 까지는 이전의 상황과 마찬가지이므로 전혀 문제가 없습니다. 문제는 SUB1이 호출될 때부터 시작됩니다. SUB1은 SUB3보다 정적 깊이가 낮은 프로시저입니다. 따라서 디스플레이의 2번째 인덱스는 SUB1을 가리키게 됩니다. 문제는 2번째 인덱스가 스택의 가장 윗부분을 가리키게 된다는 것입니다. 따라서 디스플레이의 3번째 인덱스가 SUB3을 가리키고 있을 지라도, 컴파일러는 이것을 비활성된 것으로 인식합니다.&lt;/p&gt;

&lt;p&gt;이후에 SUB4가 호출될 때는 이전과 동일합니다. SUB4는 SUB1보다 정적 깊이가 깊은 곳에 위치해있기 때문에, 디스플레이의 3번째 인덱스가 SUB4를 가리키게 설정하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 SUB1만 호출되고 끝나는 상황이라고 가정해봅시다. 이전 슬라이드에서는 SUB1이 호출될 때 문제가 생겼었지만, 결국 SUB4로 인해 최종 디스플레이 배열은 문제가 없이 생성되었습니다. 그러나 이제는 SUB1이 선언되고 끝났기 때문에, 디스플레이의 3번째 인덱스가 SUB3을 가리키고 있음에도 이것이 활성화되지 않는 문제가 발생합니다. 하지만 정적 영역 언어를 기준으로 보았을 때, SUB1에서 SUB3의 지역 변수를 참조할 수 없으니 이것은 옮게 된 비활성화입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그럼 디스플레이를 구현하는 방법이 어떻게 되는지 알아보겠습니다. 먼저 디스플레이 배열의 크기를 정하는 것은 간단합니다. 컴파일러가 부프로그램에 대한 최대 정적 깊이를 알 수 있기 때문입니다. 따라서 디스플레이 배열은 실행 시간에 정적 배열로 메모리에 저장됩니다. 만약 컴퓨터가 메모리 위치에 따른 간접 주소 지정을 하는 경우, 비지역 접근은 지역 접근보다 메모리 사이클이 한 단계 증가합니다. 만약 디스플레이 배열을 레지스터에 위치시킨다면 추가적인 메모리 사이클이 필요하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정적 체인과 디스플레이를 비교해보겠습니다. 속도 면에서 보자면, 정적 수준이 한 단계 차이가 나는 경우 정적 체인이 디스플레이보다 빠릅니다. 왜냐하면 디스플레이가 레지스터에 저장되는 경우가 아니라면 간접 주소 지정을 통해 접근을 하게 되는데, 이 경우 비지역 변수에 대한 참조 과정이 한 단계 증가하기 때문입니다.&lt;/p&gt;

&lt;p&gt;그러나 두 단계 이상의 정적 수준에 있는 비지역 변수에 대한 참조는 정적 체인보다 빠릅니다. 정적 체인은 정적 수준의 깊이가 증가할수록 속도가 느려지지만, 디스플레이는 모든 단계의 비지역 변수 참조 속도가 동일하기 때문입니다.&lt;/p&gt;

&lt;p&gt;전체적으로 비교하자면, 정적 수준이 깊은 비지역 변수에 대한 참조가 많은 경우에는 디스플레이가 더 좋고, 그렇지 않은 경우에는 정적 체인이 더 좋습니다. 그리고 사실 일반적으로 정적 수준이 깊은 비지역 변수를 참조하는 일은 생각보다 많지 않기 때문에, 정적 체인이 더 좋다고 말할 수 있습니다. 사실 일반적인 정적 중첩은 3보다 작습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5장에서 C 기반 언어들은 &lt;span style=&quot;color:red&quot;&gt;블록(Block)&lt;/span&gt;라는 지역 영역을 선언할 수 있다고 배웠습니다. 블록은 &lt;strong&gt;복합문(Compound Statement)&lt;/strong&gt;과 &lt;strong&gt;데이터 정의(Data Declaration)&lt;/strong&gt;이 결합된 구조입니다. 여기에서는 블록의 구현 방법에 대해서만 논의하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;첫 번째 구현 방법은 블록을 매개변수가 없는 부프로그램으로 취급을 하는 것입니다. 이 경우 직전에 배운 정적 체인이나 디스플레이를 이용하여 간단하게 구현할 수 있습니다. 물론 블록을 부프로그램으로 취급을 하게 되면 그 만큼 정적 중첩이 더 많이 쌓이고, 그로 인해 디스플레이의 경우에는 배열의 사이즈가 커지는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;두 번째 방법은 블록 변수에 필요한 공간을 활성화 레코드에 같이 할당하는 것입니다. 이것은 블록 변수를 위해 요구되는 기억 장소가 정적으로 계산될 수 있기 때문에 사용할 수 있는 방법입니다. 이 방법을 사용할 경우, 일반적으로 블록 변수를 지역 변수 다음 위치에 배치합니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 나온 코드에서는 b, g가 차지하는 영역과 a, f가 차지하는 영역이 서로 중복되어 있습니다. 이것은 a, b, c를 가지고 있는 블록은 f, g가 있는 블록 시점에서는 이미 종료되었기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로는 동적 영역을 구현하는 방법에 대해 알아보겠습니다. 동적 영역을 구현하는 방법은 크게 &lt;strong&gt;깊은 접근(Deep Access)&lt;/strong&gt;과 &lt;strong&gt;얕은 접근(Shallow Access)&lt;/strong&gt;이 있습니다. 주의할 점은 이것들이 이전에 배웠던 깊은 바인딩과 얕은 바인딩과는 전혀 다른 이야기라는 것입니다.&lt;/p&gt;

&lt;p&gt;동적 영역에서 지역 변수가 스택 동적 변수이고 활성화 레코드에 포함되어 있다면, 비지역 변수의 참조는 가장 최근에 활성화된 부프로그램부터 시작해서 현재 활성화 중인 다른 부프로그램의 활성화 레코드를 탐색하면서 해결할 수 있습니다. 이 개념은 정적 체인 대신 동적 체인을 사용한다는 것만 제외하면 정적 영역에서 비지역 변수에 접근하는 것과 유사합니다. 동적 체인은 활성화된 역순으로 스택을 탐험하는데, 스택의 가장 위부터 아래로 탐색해나가기 때문에 이 방법을 깊은 접근이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;정적 영역과는 달리, 동적 영역 언어에서는 접근에 필요한 체인의 길이를 컴파일 타임에 결정할 수 있는 방법이 없습니다. 그렇기 때문에 동적 영역 언어는 정적 영역 언어보다 속도가 느립니다. 게다가 정적 영역 언어에서는 변수의 이름을 저장하지 않고 값만 저장해도 상관이 없었지만, 동적 영역 언어를 구현할 때는 활성화 레코드에 검색을 위해 변수 이름을 저장해두어야 합니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 나온 코드 예제는 가장 최근에 활성화된 부프로그램인 C에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x := u + v;&lt;/code&gt; 명령어를 수행하려고 합니다. 이 때, 변수 x는 C의 지역 변수이기 때문에 탐색이 필요 없습니다. 그러나 u와 v는 C의 지역 변수가 아니기 때문에 활성화 레코드를 탐색해야 합니다. 활성화 레코드 스택을 보면 C 이전에 활성화된 부프로그램은 B입니다. B에 u와 v가 저장되어 있는지 확인해야 하는데, 이것을 위해서는 변수 이름을 비교해보아야 합니다. B에도 u와 v가 없으니 계속 링크를 타고 올라가야 하고, 변수의 이름을 비교해보면서 u와 v를 찾는 과정을 반복합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 동적 영역을 구현하는 두 번째 방법인 얕은 접근입니다. 얕은 접근 방법에서는 부프로그램의 지역 변수가 활성화 레코드에 포함되어 있지 않습니다. 이 방법은 전체 프로그램에서 각각의 변수에 따라 개별적인 스택을 갖습니다. 만약 부프로그램이 활성화될 때 새로운 이름의 변수가 선언된다면, 그 이름으로 새로운 스택이 생성됩니다. 만약 기존에 있는 변수라면, 부프로그램의 이름에 해당하는 셀이 그 값과 함께 스택에 추가됩니다. 동적 영역 언어에서 비지역 변수에 접근할 때는 가장 최근에 활성화된 부프로그램의 변수를 가지게 되는데, 얕은 접근의 구조상 각 변수의 스택에 가장 위에 있는 셀은 가장 최근에 활성화된 부프로그램의 변수입니다. 즉, 비지역 변수에 접근할 때는 항상 스택의 맨 위에 있는 셀을 참조하면 됩니다.&lt;/p&gt;

&lt;p&gt;얕은 접근 방법은 그 구조에서 예상할 수 있다시피 비지역 변수에 대한 참조는 매우 빠릅니다. 그러나 부프로그램에 진입하거나 종료할 때마다 변수에 대한 스택이 변동되므로, 스택을 유지하는 비용이 크다는 단점이 있습니다. 슬라이드에 나온 스택 그림은 이전 슬라이드에서의 깊은 접근에서 다루었던 예제 코드와 동일한 코드를 사용했을 때를 나타낸 모습입니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 나와있지 않지만 얕은 접근이 구현 방법은 이것 말고도 있습니다. 예를 들어, SNOBOL 언어는 변수에 이름에 하나의 장소를 할당하는 중앙 테이블을 사용하고 있습니다. 각각의 항목은 변수가 현재 어느 부프로그램에 바인딩이 되어 있는지 활성(Active) 비트를 가지고 있습니다. 변수에 접근할 때는 중앙 테이블의 오프셋을 이용합니다. 이 오프셋은 정적이기 때문에 접근이 빠르다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;또한 각 변수의 최신 값만 저장하는 단일 셀을 가지는 테이블을 구현하는 방법도 있습니다. 이 방법은 최소한의 오버헤드만 가진다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;동적 영역 언어를 구현할 때 깊은 접근과 얕은 접근 중 어느 방법을 사용할 지는 부프로그램 호출과 비지역 변수를 참조를 어느 정도로 하는 지에 따라 달려 있습니다. 깊은 접근 방법은 부프로그램이 호출되거나 해제될 때 속도가 빠르지만, 참조에 대한 비용이 크고, 얕은 접근 방법은 그 반대로 참조는 효율적이지만, 부프로그램이 호출되거나 해제될 때 비효율적입니다.&lt;/p&gt;

&lt;p&gt;10장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Subprograms</title><link href="http://localhost:4000/pl/subprograms/" rel="alternate" type="text/html" title="Subprograms" /><published>2023-09-14T00:00:00+09:00</published><updated>2023-09-14T00:00:00+09:00</updated><id>http://localhost:4000/pl/subprograms</id><content type="html" xml:base="http://localhost:4000/pl/subprograms/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;9장의 주제는 부프로그램입니다. 다룰 내용은 부프로그램의 매개변수 전달 방법, 지역 참조 환경, 중복 부프로그램 등이 있습니다. 여기서는 부프로그램에 대해서만 알아보고, 부프로그램을 구현하는 방법은 다음 장에서 자세히 다룰 예정입니다. 이번 장의 핵심 문구는 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“부프로그램은 프로그램의 기본 요소이므로 프로그래밍 언어 설계에서 가장 중요한 개념 중 하나입니다”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로그래밍 언어에 포함되는 기본적인 두 개의 추상화는 프로세스 추상화와 데이터 추상화입니다. 데이터 추상화는 11장에서 다룰 예정이고, 이번 장에서 다룰 부프로그램이 바로 프로세스 추상화에 해당합니다.&lt;/p&gt;

&lt;p&gt;부프로그램의 개념은 배비지(Babbage)의 해석기관에서 유래했습니다. 해석기관은 프로그램이 다양한 장소에서 명령어의 묶음을 재사용하는 능력이 있었는데, 현대 프로그래밍 언어에서는 이를 부프로그램으로 구현하였습니다. 이러한 재사용은 메모리 공간과 코딩 시간을 절약하는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;해당 명령어의 묶음을 &lt;strong&gt;호출(Call)&lt;/strong&gt;하는 명령어를 통해 프로그램에 명령어의 묶음을 배치하는 것은 곧 추상화로 볼 수 있습니다. 왜냐하면 명령어 묶음의 세부 사항이 부프로그램으 호출하는 문장 하나로 대치되기 때문입니다.&lt;/p&gt;

&lt;p&gt;프로시저와 매크로는 비슷하면서도 차이가 있는데, 매크로는 함수 호출이나 반환과 같은 오버헤드가 발생하지 않지만 프로그램 길이가 길어질 수 있는 문제가 있습니다. 짧은 코드라면 매크로가 유리하지만, 긴 코드라면 프로시저를 이용하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 부프로그램의 기초부터 알아보겠습니다. 일반적인 부프로그램의 특성은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각각의 부프로그램은 단일 진입점을 갖는다.&lt;/li&gt;
  &lt;li&gt;호출 프로그램 단위는 호출된 부프로그램이 실행되는 동안 일시중지된다. 즉, 주어진 시간 동안 실행 중인 부프로그램은 1개만 존재한다.&lt;/li&gt;
  &lt;li&gt;부프로그램 실행이 종료되면 제어가 항상 호출한 프로그램으로 돌아간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 가정은 &lt;strong&gt;코루틴(Coroutine)&lt;/strong&gt;과 &lt;strong&gt;동시성(Concurrency)&lt;/strong&gt;에서 예외가 있습니다만, 이것은 해당 장에서 구체적으로 다루겠습니다.&lt;/p&gt;

&lt;p&gt;부프로그램의 정의는 부프로그램 추상화의 인터페이스와 동작을 서술하는 것입니다. &lt;strong&gt;부프로그램 호출(Subprogram Call)&lt;/strong&gt;은 부프로그램이 실행되도록 명시적으로 요청하는 것이고, 부프로그램이 호출된 후 실행을 시작했지만 아직 끝나지 않은 경우에는 &lt;strong&gt;활성화(Actice)&lt;/strong&gt;되었다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;부프로그램 헤더(Subprogram Header)&lt;/strong&gt;는 첫 줄에 선언되는 부프로그램의 정의입니다. 이것은 부프로그램 이름과 함께 매개변수 목록을 지정하는데 사용합니다.&lt;/p&gt;

&lt;p&gt;Fortran 언어에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUBROUTINE&lt;/code&gt; 이라는 명령어를 사용하여 헤더를 정의하고, Ada 언어에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;procedure ~ is&lt;/code&gt; 명령어를 이용하여 헤더를 정의합니다. 함수는 값을 반환하고 프로시저는 명령어를 실행하는 차이가 있지만, C 언어는 함수(Function)라는 한 종류의 부프로그램만 있습니다. 대신 헤더를 보고 그 함수가 값을 반환하는지 안하는지를 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램이 데이터에 접근할 수 있는 방법은 두 가지가 있습니다. 하나는 비지역 변수로의 직접적인 접근과, 나머지 하나는 함수의 매개변수를 통해 접근하는 방법입니다. 비지역 변수를 통한 접근은 프로그램의 신뢰성을 감소시키기 때문에 매개변수를 통해 데이터를 전달하는 방법이 권장됩니다.&lt;/p&gt;

&lt;p&gt;어떤 상황에서는 부프로그램의 매개변수로 데이터가 아닌 계산이 전달되는 것이 편리합니다. 이런 경우에는 계산을 구현하는 부프로그램의 이름이 매개변수로 사용됩니다. 이것은 나중에 9.6절에서 더 자세히 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;매개변수는 &lt;strong&gt;형식 매개변수(Formal Parameter)&lt;/strong&gt;와 &lt;strong&gt;실 매개변수(Actual Parameter)&lt;/strong&gt;로 나눌 수 있습니다. 형식 매개변수는 부프로그램 머리부에서 선언되는 매개변수입니다. 이 변수는 일반적인 의미의 변수가 아니기 때문에 독립 변수로 간주됩니다. 이런 변수들은 보통 부프로그램이 호출될 때만 기억장소에 바인딩되고, 이 바인딩도 다른 프로그램 변수를 통해 이루어집니다. 부프로그램의 형식 매개변수에 바인딩되는 부프로그램 호출의 매개변수를 실 매개변수라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;매개변수를 전달할 때, 매개변수의 위치에 따라 실 매개변수를 형식 매개변수에 바인딩하는 방법을 &lt;strong&gt;위치 매개변수(Positional Parameter)&lt;/strong&gt;라고 합니다. 매개변수 리스트가 짧은 경우에는 이 방법이 효율적이고 안전한 방법입니다,&lt;/p&gt;

&lt;p&gt;만약 매개변수 리스트가 길다면 프로그래머는 매개변수를 작성하는 도중 오류를 범할 가능성이 높습니다. 이 문제를 해결하는 방법은 &lt;strong&gt;키워드 매개변수(Keyworkd Parameter)&lt;/strong&gt;를 이용하는 것입니다. 키워드 매개변수에서는 실 매개변수가 바인딩될 형식 매개변수의 이름을 함께 호출하는 방식으로 지정합니다. 예를 들어, 슬라이드에 나온 것처럼 Ada 언어에서 LENGTH =&amp;gt; MY_LENGTH와 같이 형식 매개변수 LENGTH에 실 매개변수 MY_LENGTH를 직접 지정해주는 방식입니다. 이 방법의 단점은 프로그래머가 부프로그램의 형식 매개변수의 이름을 반드시 알고 있어야 한다는 것입니다.&lt;/p&gt;

&lt;p&gt;C++ 언어나 Ada에서는 형식 매개변수가 &lt;strong&gt;기본값(Default Value)&lt;/strong&gt;을 가질 수 있습니다. 기본값은 부프로그램을 호출할 때 실 매개변수가 전달되지 않는 경우 사용됩니다. 예를 들어, 슬라이드의 코드와 같이 EXEMPTION의 기본값은 정수 1로 설정되어 있습니다. 만약 이 부프로그램을 호출할 때, 이 매개변수가 생략된다면 자동으로 1이 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;형식 매개변수의 기본값을 지원하지 않는 경우, 호출의 실 매개변수의 수는 반드시 부프로그램 헤더에서 정의한 형식 매개변수의 수와 일치해야 합니다. 그러나 C 언어는 이것이 필수가 아닙니다. 예를 들어, C 언어의 printf 함수는 가변 개수의 매개변수를 허용하기 때문에 임의의 개수의 항목을 출력합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램은 &lt;span style=&quot;color:red&quot;&gt;프로시저(Procedure)&lt;/span&gt;와 &lt;span style=&quot;color:red&quot;&gt;함수(Function)&lt;/span&gt;로 나눌 수 있습니다. 이 둘의 가장 큰 차이는 반환값이 있느냐 없느냐의 여부입니다. 프로시저는 값을 반환하지 않지만, 함수는 값을 반환합니다. 이 두 역할이 명백하게 구분되어 있는 언어도 있지만, C 언어는 함수 한 가지만 존재하는 대신 함수에 반환값을 설정하지 않아서 프로시저처럼 사용할 수 있게 구현되어 있습니다.&lt;/p&gt;

&lt;p&gt;프로시저는 매개변수화된 계산을 정의하는 명령문의 모음입니다. 프로시저는 값을 반환하지 않기 때문에 호출자에게 결과를 전달할 수 있는 방법이 매우 제한되는데, 대표적인 방법이 프로시저 내에서 보이는 변수를 변경하거나, 호출자에게 데이터 전달을 허용하는 형식 매개변수를 갖는다면 그것을 변경시키는 방법입니다.&lt;/p&gt;

&lt;p&gt;함수는 요구되는 실 매개변수와 함께 표현식에서 이름으로 나타남으로써 호출됩니다. 함수에 의해 생성된 값은 효율적으로 호출을 대체하면서 호출 코드로 반환됩니다. 함수를 통해 새로운 사용자 정의 연산을 정의할 수 있습니다. 예를 들어서, 어떤 언어가 지수 연산자를 갖지 않는다면 이를 수행하는 함수를 만들 수 있습니다. Fortran와 같은 언어에서는 지수 연산을 지원하기 때문에 굳이 이것을 함수로 구현할 필요가 없습니다. 대부분의 언어에서는 프로그래머가 새로운 함수를 정의함으로써 연산자를 중복하는 것을 허용하는데, 이것은 9.12 절에서 자세하게 다루겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램은 프로그래밍 언어에서 복잡한 구조를 갖고 있기 때문에 그만큼 설계에 고려할 사항이 많습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;매개변수의 전달 방법은 무엇을 사용할 것인가?&lt;/li&gt;
  &lt;li&gt;형식 매개변수의 타입과 실 매개변수의 타입에 대해 타입 검사를 수행할 것인가?&lt;/li&gt;
  &lt;li&gt;지역 변수는 정적으로 할당되는가, 동적으로 할당되는가?&lt;/li&gt;
  &lt;li&gt;매개변수로 전달된 부프로그램의 참조 환경은 무엇인가?&lt;/li&gt;
  &lt;li&gt;부프로그램을 매개변수로 전달할 수 있는 경우, 전달된 부프로그램에 대한 호출에서 매개변수 타입을 검사하는가?&lt;/li&gt;
  &lt;li&gt;부프로그램이 오버로딩 될 수 있는가?&lt;/li&gt;
  &lt;li&gt;부프로그램이 제네릭일 수 있는가?&lt;/li&gt;
  &lt;li&gt;부프로그램이 분리된 컴파일, 또는 독립적인 컴파일이 가능한가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램 내에서 선언된 변수를 &lt;span style=&quot;color:red&quot;&gt;지역 변수(Local Variable)&lt;/span&gt;이라고 합니다. 지역 변수에 대한 접근은 일반적으로 해당 변수가 선언된 부프로그램으로 제한됩니다. 5장에서 다룬대로, 지역 변수는 &lt;strong&gt;정적(Static)&lt;/strong&gt;이거나 &lt;strong&gt;스택 동적(Stack Dyanmic)&lt;/strong&gt;입니다. 지역 변수가 스택 동적이라면, 지역 변수는 부프로그램이 실행을 시작할 때 기억공간에 바인딩되고, 실행이 종료되면 저장소에서 해제됩니다.&lt;/p&gt;

&lt;p&gt;스택 동적 지역 변수의 장점은 유연성입니다. 특히, 재귀적 부프로그램을 만들기 위해서는 스택 동적 변수가 필수적입니다. 그 외의 장점은 활성 부프로그램에 있는 지역 변수의 기억 장소가 다른 모든 비활성 부프로그램의 지역 변수와 같은 공간을 공유하므로 저장공간을 아낄 수 있다는 것이지만, 기억공간이 충분히 늘어난 지금은 큰 장점이라고 보진 않습니다.&lt;/p&gt;

&lt;p&gt;스택 동적 지역 변수의 단점은 부프로그램이 호출될 때마다 지역 변수를 할당, 초기화, 해제하는 시간이 소모된다는 것입니다. 또한 간접 주소 방식을 통해 기억 공간에 접근하므로 접근 속도가 느리다는 단점이 있습니다. 또한 &lt;strong&gt;과거 민감형(History-sensitive)&lt;/strong&gt;이 아니므로 호출 사이에 지역 변수에 데이터 값을 유지할 수 없다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반대로 정적 지역 변수를 사용한다면 매우 효율적이라는 장점이 있습니다. 기본적으로 프로그램이 실행될 때 저장공간에 바인딩되기 때문에 할당이나 해제에 실행 시간 부담이 없고, 접근이 빠르며 과거 민감형 부프로그램을 허용한다는 것입니다. 그러나 재귀를 허용하지 않고 기억공간을 다른 비활성 부프로그램의 변수들과 공유할 수 없다는 단점도 있습니다.&lt;/p&gt;

&lt;p&gt;ALGOL 60과 그 후속 언어들에서 지역 변수는 기본적으로 스택 동적으로 구현되어 있습니다. 그러나 C 언어 같은 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt; 이라는 명령어를 이용하여 정적 변수로 선언할 수 있는 옵션을 제공합니다. Fortran 77의 경우에는 재귀가 없기 때문에 모든 지역 변수가 정적 지역 변수입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 이번 장에서 가장 중요한 매개변수 전달 방법에 대해 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;형식 매개변수는 3개의 의미적 모델 중 하나로 결정됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;형식 매개변수가 해당 실 매개변수로부터 데이터를 받는다. &lt;strong&gt;(in mode)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;형식 매개변수가 데이터를 실 매개변수에 전달한다. &lt;strong&gt;(out mode)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;형식 매개변수가 실 매개변수로부터 데이터를 받고, 반대로 데이터를 실 매개변수에 전달한다. &lt;strong&gt;(inout mode)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데이터 이동이 매개변수 전달에서 일어나는 방법은 두 가지 개념적인 모델이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실제 값이 물리적으로 이동된다.&lt;/li&gt;
  &lt;li&gt;접근 경로(포인터나 참조)가 이동한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세 가지의 기본 매개변수 전달 모드의 구현을 위해, 다양한 모델이 언어 설계자에 의해 개발되었습니다. 여기서 소개하는 것은 그 중 많이 고려되는 5가지의 매개변수 전달 모델을 소개합니다.&lt;/p&gt;

&lt;p&gt;첫 번째 모델은 매개변수를 값으로 전달하는 &lt;span style=&quot;color:red&quot;&gt;Pass by Value&lt;/span&gt; 입니다. Pass by Value에서 실 매개변수의 값은 해당 형식 매개변수를 초기화하는데 사용되며, 이 매개변수는 부프로그램에서 지역 변수로 간주됩니다. 따라서, Pass by Value는 in mode의 의미가 구현된 것으로 볼 수 있습니다. Pass by Value는 보통 데이터를 복사하는 것으로 구현합니다. 왜냐하면 Pass by Value에서 실 매개변수가 가지고 있는 값은 쓰기로부터 보호가 되어야 하기 때문입니다. 따라서 매개변수가 배열과 같이 큰 개체인 경우에는 이것을 기억공간에 복사하는데 많은 비용이 들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 번째 모델은 out mode의 의미를 구현한 &lt;span style=&quot;color:red&quot;&gt;Pass by Result&lt;/span&gt; 입니다. 매개변수가 전달될 때, 어떠한 값도 부프로그램에 전달되지 않습니다. 이 때 매개변수는 지억 변수로 작동하긴 하지만, 제어가 호출자에게 반환되기 직전에 그 값이 호출자의 실 매개변수에 전달됩니다. Pass by Result도 Pass by Value의 단점을 그대로 갖는데, 실 매개변수로 전달되는 것도 데이터가 복사되어 전달되는 것이기 때문에 추가적인 기억공간이 필요하다는 것입니다.&lt;/p&gt;

&lt;p&gt;그런데 Pass by Result는 실 매개변수의 충돌과 같은 추가적인 문제점도 가지고 있습니다. 예를 들어, 슬라이드의 코드와 같이 sub 라는 부프로그램은 x와 y라는 두 가지 형식 매개변수를 가지고 있습니다. 부프로그램 내에서 x에는 3, y에는 5가 배정됩니다. 그런데 main()에서 sub를 호출할 때 실 매개변수로 모두 p1이 들어갑니다. 이 때, 함수 호출이 끝나고 p1에는 어떤 값이 들어가야 할까요? 이 상황에서는 나중에 실 매개변수에 배정되는 것이 p1의 값이 됩니다. (즉, 실 매개변수에 값이 복사되는 순서)&lt;/p&gt;

&lt;p&gt;Pass by Result의 또 다른 문제는 구현자가 실 매개변수의 주소를 평가하기 위해 두 개의 다른 시점(호출 시, 복귀 시) 중에서 하나를 선택할 수 있다는 것입니다. 슬라이드 아래쪽에 있는 코드를 보면 list[index]의 주소가 부프로그램 중간에서 변경됩니다. 만약 주소가 부프로그램 진입 시 바인딩된다면 list[3]에 3이 반환될 것입니다. 그런데 반환 바로 전에 바인딩된다면 list[5]에 3이 반환될 것 입니다. 이것은 언어의 구현에 따라 다르기 때문에, 똑같이 Pass by Result를 선택한 언어 사이에도 이식하는 것을 어렵게 만듭니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;Pass by Value Result&lt;/span&gt;는 Pass by Value와 Pass by Result를 결합하여 inout mode를 구현한 것입니다. 실 매개변수의 값은 해당 형식 매개변수를 초기화하는데 사용되며, 그 후 지역 변수로써 사용됩니다. 또한 부프로그램 종료 시 형식 매개변수의 값이 실 매개변수로 다시 복사됩니다. 이 과정은 실 매개변수 -&amp;gt; 형식 매개변수의 복사와 형식 매개변수 -&amp;gt; 실 매개변수의 복사가 이루어지는 방식이기 때문에 &lt;strong&gt;Pass by Copy&lt;/strong&gt;라고 부르기도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;Pass by Reference&lt;/span&gt;는 또 다른 inout mode를 구현한 모델입니다. 그러나 이전 모델들처럼 데이터 값을 복사하는 것 대신에 접근 경로(일반적으로 주소)를 전송합니다. 따라서 부프로그램이 호출자의 실 매개변수에 접근하는 것을 허용합니다. Pass by Reference의 장점은 전달 과정이 시간과 기억공간적 관점에서 효율적이라는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러나 Pass by Reference에도 단점은 존재합니다. 첫 번째 단점은 형식 매개변수에 접근할 때 한 단계 더 많은 간접 주소를 사용하기 때문에 형식 매개변수에 접근할 때 더 느릴 수 있습니다. 두 번째 단점은 프로그래머의 실수로 인해 잘못된 값이 실 매개변수에 적용될 수 있습니다. 하지만 이 두 가지 단점보다 더 큰 세 번째 단점은 &lt;strong&gt;별칭(Alias)&lt;/strong&gt;를 만들 수 있다는 것입니다. 이것은 Pass by Reference가 부프로그램이 호출자에 접근 가능한 경로를 만들기 때문에 비지역 변수를 건드릴 수 있기 때문에 발생합니다. 별칭은 이전 장에서도 설명했었지만 프로그램의 가독성과 신뢰성에 악영향을 미치고, 프로그램 검증을 어렵게 만듭니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 제시된 코드를 통해 어떤 식으로 Pass by Reference에서 별칭이 만들어지는지 확인해 보겠습니다. 왼쪽의 코드에서는 global이 전역 변수로 선언되어있고, local이 smallsub의 형식 매개변수로 선언이 되어 있습니다. 그런데 smallsub를 호출할 때 실 매개변수로 global이 사용되었습니다. 따라서 smallsub 내에서 global과 local은 별칭이 되어 버립니다.&lt;/p&gt;

&lt;p&gt;오른쪽의 코드에서는 sub라는 부프로그램에서 first와 second라는 두 개의 형식 매개변수가 정의되었습니다. 그런데 어쩌다가 sub를 호출할 때 두 매개변수에 모두 실 매개변수로 total을 사용했습니다. 이 경우 sub의 first와 second는 별칭이 되어 버립니다.&lt;/p&gt;

&lt;p&gt;이러한 별칭 문제는 Pass by Reference가 아니라 Pass by Value Result를 사용하면 해결됩니다. 그러나 이 경우에는 별칭 말고도 다른 문제가 발생하기 때문에 설계자가 전달 방법을 신중하게 선택할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;마지막 모델은 &lt;span style=&quot;color:red&quot;&gt;Pass by Name&lt;/span&gt; 입니다. 이 방법도 Pass by Value Result나 Pass by Reference와 같은 inout mode를 구현한 모델입니다. 이 방법은 매개변수가 이름으로 전달될 때, 실 매개변수가 부프로그램에 나타나는 해당 모든 형식 매개변수를 그대로 대체합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지금까지 논의한 방법들은 부프로그램을 호출할 때 형식 매개변수의 값이나 주소에 바인딩되었는데, Pass by Name은 전혀 다른 방법을 사용하여 inout mode를 구현하였습니다. Pass by Name에서 형식 매개변수는 부프로그램 호출 시에 바인딩되지만, 값이나 주소의 실제 바인딩은 형식 매개변수에 값이 배정되거나 참조될 때까지 연기됩니다. (늦은 바인딩)&lt;/p&gt;

&lt;p&gt;Pass by Name의 구현은 매우 어려운데, 실 매개변수의 타입에 따라 구현 방법이 결정되기 때문입니다. 예를 들어, 변수를 전달할 때는 Pass by Reference와 같은 방법을 사용하고, 상수를 전달할 때는 Pass by Value와 같은 방법을 사용합니다. 배열을 전달할 때가 매우 골치아픈데, 이 때는 형식 매개변수를 참조할 때마다 변경될 수 있습니다. 예를 들어, 슬라이드 내에 있는 코드를 확인해봅시다. LIST는 2개의 원소가 있는 배열로 정의가 되었고, GLOBAL은 전역 변수입니다. SUB가 호출되기 전에 GLOBAL에는 1이 배정되므로 SUB가 호출될 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUB(LIST[1])&lt;/code&gt;이 됩니다. SUB 내의 첫 명령어인 PARAM 에 3을 대입하는 것은 당연히 LIST[1]에 배정됩니다. 그런데 그 다음 줄에는 GLOBAL의 값을 1 증가시키는 명령어가 있습니다. Pass by Name은 형식 매개변수가 참조될 때마다 변경되므로, 다음 줄의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PARAM := 5&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIST[2] := 5&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pass by Name에서 발생하는 또 다른 문제를 알아봅시다. 왼쪽 코드를 보시면 swap이라는 프로시저가 있습니다. 이 프로시저는 FIRST와 SECOND를 매개변수로 받아 두 개의 값을 서로 교환하는 작업을 수행합니다. 만약 오른쪽의 윗부분 예시처럼, KK, II라는 두 개의 정수가 매개변수로 들어온다면 문제없이 수행됩니다. 그런데 만약 그 아래의 코드처럼 I와 A[I]가 매개변수로 들어오면 어떻게 될까요? I에 A[I]값이 먼저 삽입되기 때문에, A[I]에 TEMP의 값이 들어가는 것이 아니라 A[A[I]]에 TEMP의 값이 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;Pass by Name은 높은 유연성을 가지지만, 그로 인해 프로세스 속도가 느리고, 구현이 어려우며, 프로그램의 가독성과 신뢰성을 낮추는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;Jensen’s Devices&lt;/span&gt;는 Pass by Name을 활용하여 하나의 프로시저를 다양한 목적으로 사용하기 위한 방법입니다. 식과 식에 나타나는 한 개 이상의 변수를 매개변수로 부프로그램에 전달하는데, 부프로그램에서 매개변수의 변수 중 하나가 변경될 때마다 해당 변경으로 인해 형식 매개변수의 값이 변경될 수 있습니다.&lt;/p&gt;

&lt;p&gt;Jensen’s Devices의 대표적인 예는 바로 합을 계산하는 프로시저입니다. 예제 코드에서 나온 SUM 프로시저는 ADDER, INDEX, LENGTH 3개의 매개변수를 받아 INDEX가 LENGTH에 도달할 때까지 TEMPSUM에 ADDER를 더합니다. 이 프로시저는 얼핏 보면 단순하지만, 매개변수에 따라 다양한 계산을 수행할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM(A, I, 100)&lt;/code&gt;으로 호출한 경우, 100 * A 계산을 수행&lt;/li&gt;
  &lt;li&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM(A[I], I, 100)&lt;/code&gt;으로 호출할 경우, 배열 A의 1부터 100까지의 합 계산을 수행&lt;/li&gt;
  &lt;li&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM(A[I] * A[I], I, 100)&lt;/code&gt;으로 호출할 경우, 배열 A 제곱의 1부터 100까지의 합 계산을 수행&lt;/li&gt;
  &lt;li&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM(A[I] * B[I], I, 100)&lt;/code&gt;으로 호출할 경우, 배열 A와 B의 곱을 1부터 100까지의 합 계산을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Jensen’s Devices의 아이디어는 식과 식에 사용된 하나 이상의 변수를 모두 서브루틴에 전달하는 것입니다. ALGOL 60이 대표적으로 Call by Name을 사용하는데, ALGOL 60은 Call by Name을 구현하기 위해 호출자의 참조 환경에서 실 매개변수를 평가하는 숨겨진 서브루틴을 전달하는 방법을 사용했습니다. 이러한 숨겨진 루틴을 일반적으로 &lt;strong&gt;Thunk&lt;/strong&gt;라고 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개별 변수의 값을 변경함으로써, 호출된 루틴은 내장된 표현식의 값을 의도적이고 체계적으로 변경할 수 있습니다. 이러한 장치는 합산 루틴을 작성하는 데 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 사실 Pass by Name을 이렇게 영리하게 사용하는 경우는 매우 드물며, 이러한 방법은 Pass by Name 아닌 다른 매개변수 전달로도 충분히 구현할 수 있습니다. 게다가, 형식 매개변수를 사용할 때마다 Thunk를 호출하는 비용이 엄청나다는 것이 입증되었기 때문에 ALGOL 68에서는 이러한 전달 방법이 삭제되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 주요 언어들에서 매개변수 전달 방법을 어떻게 사용하고 있는지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 Fortran 언어는 Fortran 77 이전까지 Pass by Reference를 사용하다가, Fortran 77부터는 Pass by Value Result를 사용하는 것으로 변경되었습니다. ALGOL 60은 이전 슬라이드에서도 언급했듯이, Pass by Name을 사용했습니다. SIMULA-67 또한 마찬가지로 Pass by Name을 사용했습니다.&lt;/p&gt;

&lt;p&gt;그러나 ALGOL 68과 C 언어부터는 Pass by Value를 사용하기 시작했습니다. 만약 매개변수를 변경할 필요가 있을 때는 포인터 타입을 사용함으로써 Pass by Reference와 같은 효과를 얻을 수 있습니다. 이 언어들의 특징은 형식 매개변수를 나열할 때, 매개변수의 이름 옆에 매개변수의 타입을 같이 선언하는 문법을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;ALGOL W의 경우에는 Pass by Result를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal 언어와 Modula-2 언어의 경우는 조금 특이한데, 기본적으로 Pass by Value로 매개변수를 전달하지만, var 이라는 예약어를 사용하여 형식 매개변수를 정의한다면 Pass by Reference로 전달합니다.&lt;/p&gt;

&lt;p&gt;Ada 언어는 이보다 더 특이하게 기술적으로 이 문제를 접근했습니다. Ada 언어는 매개변수 앞에 in/out/in out 예약어를 붙임으로써 매개변수가 전달되는 방법을 구분합니다. 각각 in mode / out mode / in out mode를 의미합니다.&lt;/p&gt;

&lt;p&gt;이전에는 실 매개변수의 타입이 형식 매개변수의 타입과 같은지 확인하는 절차가 따로 없었으나, 최근에는 이것을 검사하는 것이 소프트웨어의 신뢰성을 높인다고 알려져 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 77나 초창기 C 언어 같은 초기 프로그래밍 언어는 매개변수 타입 검사를 요구하지 않았습니다. 그러나 그 이후 개발된 Pascal, Modula-2, Fortran 90과 같은 언어들은 매개변수의 타입 검사를 실시합니다.&lt;/p&gt;

&lt;p&gt;ANSI C 언어는 조금 특이한 방식을 가지고 있습니다. 만약 함수를 선언할 때 형식 매개변수에 타입을 작성하지 않으면, 초창기 C 언어와 마찬가지로 타입 검사를 하지 않습니다. 물론 C 언어에 기반했기 때문에 프로그램 내에서 해당 형식 매개변수의 타입을 명세하기는 하지만, 그렇다고 실 매개변수와 타입이 같을 필요는 없습니다.&lt;/p&gt;

&lt;p&gt;만약 함수를 선언할 때 형식 매개변수의 타입을 작성하면 타입 검사를 수행합니다. 만약 타입 검사 후에 타입이 다르더라도, int - double과 같이 같은 숫자형 변수라면 강제 변환(Coercion)이 일어납니다. 만약 변환이 가능하지 않거나 매개변수의 개수가 틀리다면 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;C++ 언어(C99 포함)는 ANSI C와는 다른 방식으로 타입 검사를 피할 수 있습니다. 형식 매개변수를 선언할 때, 생략 기호(Ellipsis)를 사용하면 매개변수의 개수나 타입 검사를 피할 수 있습니다. 예를 들어, 교재에 나온 코드인 printf 함수의 경우 적어도 한 개의 매개변수가 필요합니다. 그 외에는 몇 개의 매개변수를 갖던 상관이 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 매개변수 전달 방법을 구현하는 방법에 대해 알아보겠습니다. ALGOL 60을 비롯한 그 후속 언어들에서는 실행 시간 스택(Run-time Stack)을 이용하여 매개변수를 연결하였습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Pass by Value에서 매개변수는 그 값이 스택에 복사됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pass by Result에서 매개변수는 실제 매개변수가 스택에 배치되고, 호출된 부프로그램이 종료할 때 부프로그램에서 사용된 형식 매개변수와 일치하는 실제 매개변수를 스택에서 검색하여 매칭됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pass by Value Result는 Pass by Value와 Pass by Result를 합친 것으로 구현합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pass by Reference는 실 매개변수의 타입에 관계 없이 그 주소가 스택에 배치되어야 합니다. 컴파일러는 호출된 부프로그램으로 제어권을 넘기기 전에 식을 평가하는 코드를 작성해야 합니다. 해당 식의 코드 결과가 스택이 배치되는 주소입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pass by Name은 이전 방법들과 구현 방법이 상이합니다. 크게 2가지 방법으로 나눌 수 있는데, 매개변수가 없는 프로시저로 구현하거나 실행 시간 상주 코드 세그먼트인 Thunk로 구현하는 것입니다. (후자의 경우가 훨씬 많이 사용됨)&lt;/p&gt;

&lt;p&gt;호출된 부프로그램의 Pass by Name 매개변수에 대한 모든 참조에 대해 Thunk를 호출해야 합니다.&lt;/p&gt;

&lt;p&gt;Thunk는 전달된 부프로그램이 선언된 부프로그램의 적절한 참조 환경에서 참조를 수행하고, 실 매개변수의 주소를 반환합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;매개변수 전달 방법을 선택하는데는 두 가지 고려사항이 있습니다. 하나는 효율성이고, 하나는 단방향 데이터 이동과 양방향 데이터 이동의 선택입니다. 현대 소프트웨어 공학(Software Engineerning)에서는 부프로그램 밖에 있는 데이터는 부프로그램 내에서 접근을 최소화하는 것을 지향하고 있습니다. 따라서 일반적으로는 in mode를 사용하는 것이 권장됩니다.&lt;/p&gt;

&lt;p&gt;그런데 이러한 원리와 상충되는 고려사항도 있습니다. 예를 들어, 크기가 큰 배열이 Pass by Value로 전달될 경우, 배열 전체가 실행 시간 스택에 들어가야 하는 문제가 있습니다. 이것은 시간적으로도, 공간적으로도 부담이 크기 때문에 배열은 Pass by Reference로 전달되는 경우가 있습니다. 따라서 Ada 언어나 C++ 언어는 이것을 사용자에게 선택하게끔 하고 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 부프로그램을 다른 부프로그램의 매개변수로 전달하는 방법에 대해 알아보겠습니다. 언뜻 보면 이 개념은 자연스럽고 당연한 것처럼 보이지만, 동작하는 과정은 복잡합니다. 단지 부프로그램의 코드만 전달하는 것으로도 구현은 가능하지만, 이렇게 구현하게 되면 2가지 문제점이 발생합니다.&lt;/p&gt;

&lt;p&gt;첫 번째 문제는 매개변수로 전달된 부프로그램의 매개변수 타입 검사 문제입니다. 두 번째 문제는 중첩된 부프로그램을 허용하는 경우 발생합니다. 바로 전달된 부프로그램을 실행시키기 위해 어떤 참조 환경이 사용되어야 하는가의 문제인데, 다음 슬라이드에서와 같이 세 가지 방법이 존재합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;첫 번째 참조 환경은 전달된 부프로그램을 실행시키는 호출문의 환경인 &lt;strong&gt;얕은 바인딩(Shallow Binding)&lt;/strong&gt;입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;두 번째 참조 환경은 전달된 부프로그램의 정의 환경인 &lt;strong&gt;깊은 바인딩(Deep Binding)&lt;/strong&gt;입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;세 번째 참조 환경은 부프로그램을 실 매개변수로 전달한 호출문의 환경인 &lt;strong&gt;애드혹 바인딩(Ad-hoc Binding)&lt;/strong&gt;입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 참조 환경의 차이를 알아보기 위해 슬라이드에 나와있는 코드를 확인해보겠습니다. 코드에서는 SUB1 -&amp;gt; SUB3 -&amp;gt; SUB4 -&amp;gt; SUB2 순서대로 프로시저가 호출됩니다. 주의할 것은, SUB3 내에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUB4(SUB2)&lt;/code&gt;와 같이 프로시저가 중첩되어 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;만약 얕은 바인딩이 사용된다면, SUB2 내에서 사용되는 변수 x는 SUB4의 변수에 바인딩됩니다. 따라서 이 경우 출력이 4가 나옵니다.&lt;/p&gt;

&lt;p&gt;만약 깊은 바인딩이 사용된다면, 구조적으로 상위에 있는 변수를 참조하므로 SUB1의 x에 바인딩됩니다. 따라서 이 경우 출력이 1이 나옵니다.&lt;/p&gt;

&lt;p&gt;만약 애드혹 바인딩이 사용된다면, 자신(SUB2)을 호출하기 직전에 정의되었던 x에 바인딩됩니다. 따라서 이 경우 직전에 정의된 SUB3의 x 값인 3이 출력됩니다.&lt;/p&gt;

&lt;p&gt;일반적으로 정적 바인딩을 가지는 언어는 텍스트의 위치만으로 쉽게 결정할 수 있는 깊은 바인딩을 사용하고, 동적 바인딩을 가지는 언어는 얕은 바인딩을 사용합니다. 애드혹 바인딩은 잘 사용되지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;오버로드된 부프로그램(Overloaded Subprogram)&lt;/span&gt;은 같은 참조 환경에서 다른 부프로그램들과 이름이 같은 부프로그램입니다. 주의할 점은, 이름은 같지만 매개변수의 개수나 순서, 타입, 반환 타입 등은 다른 부프로그램들과는 달라야 합니다. 오버로드된 부프로그램이 어떤 부프로그램인지는 실 매개변수의 리스트에 의해 결정되기 때문입니다.&lt;/p&gt;

&lt;p&gt;Ada 언어에서는 함수와 프로시저 모두 오버로드된 부프로그램을 허용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어의 함수는 매개변수의 개수나 타입이 고유하다면 오버로드가 가능합니다. 컴파일러는 매개변수의 타입으로 모호함을 해결하는데, 이 과정이 생각보다 복잡합니다. 특히, C++ 언어는 매개변수의 강제 변환을 허용하기 때문에 모호함을 해결하는 것이 매우 어렵습니다. 또한 기본 매개변수도 모호함을 일으키는 요소 중 하나입니다. 예를 들어, 슬라이드에 주어진 코드에서는 두 개의 fun() 함수가 존재합니다. 그런데 위의 fun() 함수는 기본 매개변수로 실수형 매개변수 b를 가지고 있습니다. 그런데 기본 매개변수는 함수를 호출할 때 생략하는 것이 가능하므로, 만약 함수를 호출할 때 fun()이라고 호출하면 기본 매개변수를 생략한 첫 번째 fun()을 호출한 것인지, 아니면 두 번째 fun()을 호출한 것인지 알 수가 없습니다. 따라서 이 경우 모호함을 일으켜 컴파일 오류를 발생시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;제네릭 부프로그램(Generic Subprogram)&lt;/span&gt;은 매개변수가 다른 값일 뿐만 아니라 다른 타입을 가질 수 있게 일반적인 타입으로 정의할 수 있습니다. 이것은 소프트웨어를 재사용할 수 있게끔 가능하게 만들어 생산성을 증가시키는 이점이 있습니다. 보통 제네릭 부프로그램은 객체 지향 프로그래밍 언어를 배울 때 &lt;strong&gt;다형성(Polymorphism)&lt;/strong&gt;을 언급하면서 같이 배우곤 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제네릭 부프로그램을 허용한다면 사용자 프로그램의 요청에 따라 컴파일러가 다양한 버전의 부프로그램을 자동적으로 구성합니다. 제네릭 단위는 단지 프로시저의 템플릿일 뿐, 컴파일러에 의해 코드가 생성되지 않습니다. 따라서 어떤 특정 타입으로 인스턴스화되지 않는 이상, 프로그램에 영향을 전혀 미치지 않습니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 있는 코드는 GENERIC_SORT로 정의된 제네릭 부프로그램을 INTEGER_SORT라는 이름으로 인스턴스화하여 INTEGER 유형의 변수를 정렬하는 부프로그램으로 만든 예시입니다. 다만 예시로 나온 코드는 진짜 제네릭 부프로그램은 아닙니다.&lt;/p&gt;

&lt;p&gt;C++ 언어에서 제네릭 부프로그램은 Templete이라는 이름을 갖고, Java 언어에서는 &lt;T&gt;를 이용하여 표기합니다.&lt;/T&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran II에서와 같이, 규모가 큰 소프트웨어의 경우 프로그램의 일부만 컴파일하는 기능은 필수적입니다. 컴파일 할 수 있는 프로그램의 일부분을 &lt;strong&gt;컴파일 단위(Compilation Unit)&lt;/strong&gt;라고도 부릅니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;span style=&quot;color:red&quot;&gt;부분 컴파일(Separate Compilation)&lt;/span&gt;에 대해서 말하자면 부분 컴파일은 매개변수 타입 검사가 필요합니다.&lt;/p&gt;

&lt;p&gt;컴파일 단위끼리는 서로 다른 시간에 컴파일될 수 있지만, 만약 해당 컴파일 단위가 다른 컴파일 단위에 접근하거나 영향을 미치는 경우에는 해당 컴파일이 서로 독립적이지 않습니다.&lt;/p&gt;

&lt;p&gt;안정적으로 독립적인 컴파일을 수행하기 위해서는 컴파일러가 프로그램의 속성(변수, 타입, 인터페이스를 포함한 부프로그램)에 대한 정보에 접근할 수 있어야 합니다.&lt;/p&gt;

&lt;p&gt;Ada 언어에서는 컴파일러가 접근할 수 있는 라이브러리에 이러한 종류의 단위 인터페이스 정보를 유지함으로써 구현하였습니다.&lt;/p&gt;

&lt;p&gt;모든 컴파일은 해당 컴파일의 인터페이스 정보를 라이브러리에 배치하게 만듭니다.&lt;/p&gt;

&lt;p&gt;Ada, Modula-2, Fortran 90이 이러한 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/32.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;독립적인 컴파일(Independent Compilation)&lt;/span&gt;은 부분 컴파일과는 다르게 매개변수의 타입 검사를 필요로 하지 않습니다. 따라서 프로그램 유닛은 다른 프로그램 유닛에 대한 정보 없이 컴파일이 가능합니다.&lt;/p&gt;

&lt;p&gt;게다가 별도로 컴파일된 유닛간 인터페이스의 일관성을 확인하지도 않습니다.&lt;/p&gt;

&lt;p&gt;Fortran 77, C 언어가 이러한 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;다음으로는 함수의 설계 고려 사항에 대해 알아보겠습니다. 함수의 설계 고려 사항에는 다음과 같은 3가지 요소가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;부작용(Side Effect)이 허용되는가?&lt;/li&gt;
  &lt;li&gt;어떤 타입의 값이 반환되는가?&lt;/li&gt;
  &lt;li&gt;몇 개의 값이 반환될 수 있는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저 부작용에 대해 생각해봅시다. 5장에서 나왔던대로, 식에서 호출되는 함수의 부작용으로 인해 함수의 매개변수는 항상 in mode여야 합니다. 예를 들어, Ada 언어의 함수는 항상 in mode 형식 매개변수만 가질 수 있습니다. 이러한 제약은 함수가 매개변수에 의한 부작용, 또는 매개변수와 전역 변수의 별칭(Alias)에 의한 부작용이 발생하는 것을 효과적으로 방지합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/33.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러나 Pascal이나 C 언어에서 함수는 Pass by Value 또는 Pass by Reference 매개변수를 가질 수 있으므로 부작용이나 별칭을 발생시키는 함수를 허용합니다.&lt;/p&gt;

&lt;p&gt;두 번째 고려사항으로 넘어가면, 대부분의 명령형 언어는 해당 함수에서 반환할 수 있는 타입을 제한하고 있습니다. 몇몇 언어의 반환 타입 제한을 살펴보면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Fortran 77 : 함수는 구조화되지 않은 타입만 반환할 수 있음&lt;/li&gt;
  &lt;li&gt;Pascal, Modular-2 : 함수가 단순한 타입만 반환할 수 있음 (정수, 실수, 문자, 불리안, 포인터, 열거 타입)&lt;/li&gt;
  &lt;li&gt;C : 배열과 함수를 제외한 모든 타입이 함수에 의해 반환될 수 있음 (C++ 언어는 클래스도 반환 가능)&lt;/li&gt;
  &lt;li&gt;Ada (+ Python, Ruby) : 모든 타입을 반환할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세 번째 고려사항인 반환 값의 개수에 대해 논하자면, 대부분의 명령형 언어는 한 개의 값만 반환이 가능합니다. 그러나 Ruby, Lua, Python 같은 언어는 여러 개의 값이 반환되는 것을 허용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/34.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램 간에 필요한 소통의 대부분은 매개변수를 통해 수행할 수 있지만, 대부분의 언어는 외부 환경에서 변수에 접근하는 다른 방법을 제공합니다. 부프로그램의 비지역 변수는 부프로그램 내에서 볼 수 있지만, 지역적으로 선언되지 않은 변수입니다.&lt;/p&gt;

&lt;p&gt;만약 정적 영역 언어라면, 필요한 것보다 비지역 변수에 대한 더 많은 접근 방법을 제공합니다.&lt;/p&gt;

&lt;p&gt;그러나 동적 영역 언어라면, 부프로그램의 모든 지역 변수는 텍스트가 얼마나 가까이 있는지에 상관 없이, 실행중인 다른 부프로그램에서 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나, 이런 식으로 비지역 변수를 참조할 때는 정적으로 타입을 검사할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/35.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 언어는 COMMON이라는 명령어를 통해 전역 저장소 블록에 대한 접근 방법을 제공합니다. COMMON 블록은 블록 이름을 선언하는 첫 번째 COMMON 문이 컴파일러에 의해 발견될 때 생성됩니다. 그런데 만약 두 개의 부프로그램에 이름이 다른 동일한 데이터 블록이 포함될 수 있다는 문제가 존재합니다. 슬라이드에 나온 코드에서도 A/B가 차지하는 영역과 C/D/E가 차지하는 공간이 겹치는 문제점이 발생하였습니다. 이것과 비슷한 이유로, 동적 배열도 COMMON 블록에 넣을 수 없습니다. 따라서 COMMON 블록을 최대한 사용하지 않는 것이 바람직합니다.&lt;/p&gt;

&lt;p&gt;Modula-2와 Ada 언어는 접근이 필요한 외부 모듈을 지정할 수 있도록 데이터 공유의 대안적인 방법을 제공합니다. 모든 모듈은 접근이 필요한 다른 모듈을 정확하게 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/36.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C 언어는 다른 언어들과 다르게 전역 변수는 함수의 정의 외부에서 선언하여 생성할 수 있습니다. 또한 extern 문을 사용하여 다른 파일에 있는 전역 변수를 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 마지막으로 &lt;span style=&quot;color:red&quot;&gt;사용자 정의 연산자 오버로딩(User-defeind Overloaded Operator)&lt;/span&gt;에 대해 알아보겠습니다. Ada, C++, Python과 같은 언어에서는 매개변수의 타입이나 수, 반환 타입이 다르다면 사용자가 연산을 재정의할 수 있습니다.&lt;/p&gt;

&lt;p&gt;9장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Statement-Level Control Structures</title><link href="http://localhost:4000/pl/statement-level-control-structures/" rel="alternate" type="text/html" title="Statement-Level Control Structures" /><published>2023-09-08T00:00:00+09:00</published><updated>2023-09-08T00:00:00+09:00</updated><id>http://localhost:4000/pl/statement-level-control-structures</id><content type="html" xml:base="http://localhost:4000/pl/statement-level-control-structures/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8장의 주제는 문장 단계 제어 구조입니다. 프로그램의 제어 흐름, 또는 실행 순서는 여러 단계에서 검사할 수 있습니다. 프로그램에서 발생할 수 있는 제어 흐름은 다음과 같이 3가지로 나눌 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;식 내 제어 흐름 -&amp;gt; 연산자 우선순위 및 관련성&lt;/li&gt;
  &lt;li&gt;문장 간 제어 흐름 -&amp;gt; 문장 단계 제어 구조&lt;/li&gt;
  &lt;li&gt;유닛 간 제어 흐름 -&amp;gt; 프로시저 호출&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;식 내에서의 제어 흐름은 7장에서 다루었고, 이번 장에서는 프로그램 내의 문장들 사이에서 발생하는 제어 흐름에 대해 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;연산을 표현하기 위해서는 시퀀스, 선택 및 논리 반복문 절대적으로 필요하다는 이론적 결과가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령형 언어에서 연산은 식을 수행하고 결과 값을 변수에 할당하는 과정입니다. 그러나 결과 값은 배정문 만으로 얻기 힘들며, 일반적으로 제어문이 추가적으로 필요합니다. 명령형 언어에서 제어는 제어 흐름 경로 중에서 선택하는 것(조건문), 특정 문장을 반복적으로 실행하는 것(반복문)으로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;초기 프로그래밍 언어인 Fortran의 제어문은 기계의 명령어와 직접적으로 관련되어 있었습니다. 따라서 언어의 설계보다는 명령어 설계의 결과였습니다. 당시에는 프로그래밍의 어려움에 대해서 사람들이 체감하지 못했기 때문에 이것이 문제가 없다고 느꼈지만, 현대에서 이러한 제어문은 부적절하다고 판단하고 있습니다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어가 발전해오면서, 순서도로 표현할 수 있는 모든 알고리즘은 단 두 개의 제어문만으로 코딩이 가능하다는 것이 증명되었습니다. 하나는 if를 비롯한 조건문이고, 나머지 하나는 for를 비롯한 반복문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;많은 제어문은 작성력을 향상시킬 수 있습니다. 그러나 제어문의 수가 많아질수록 언어의 단순성은 낮아집니다. 그렇다면 단순성을 크게 떨어트리지 않고 작성력을 높이기 위해서는 언어를 얼마나 확장해야 할까요? 이 부분은 이렇다! 할 만한 정확한 정답을 찾기 힘듭니다. 제어문이 너무 적으면 단순한 제어문을 반복적으로 사용해야하기 때문에 오히려 가독성을 낮출 수 있습니다. (ex. switch 문의 부재 - if 문의 과도한 사용)&lt;/p&gt;

&lt;p&gt;순서도에서 선택문과 반복문은 슬라이드의 그림과 같이 표현합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 60 언어에서는 단일 문장으로 추상화할 수 있는 문장의 모음을 복합문으로, 복합문에 변수 선언이 포함된 것을 블록이라고 정의합니다. Pascal 언어는 ALGOL 60의 설계를 따라 복합문을 정의하지만, 블록을 허용하지는 않습니다. C 언어는 중괄호를 사용하여 복합문과 블록을 모두 무제한으로 허용하고 있습니다.&lt;/p&gt;

&lt;p&gt;복합문의 설계에는 단 한 가지 고려 사항이 있습니다. 바로 제어문이 여러 개의 진입점을 가질 수 있는가에 대해서입니다. 대부분의 컴퓨터과학자는 제어문이 여러 개의 진입점을 갖는 것은 복잡하므로 가독성이 떨어지는데 비해, 유연성이 그다지 늘어나지 않는다고 생각하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;선택문(Selection Statement)&lt;/span&gt;은 프로그램에서 두 개 이상의 실행 경로 가운데 하나를 선택할 수 있는 문장입니다. 선택문을 일반적으로 2방향 선택문과 다방향 선택문으로 나뉩니다.&lt;/p&gt;

&lt;p&gt;먼저 2방향 선택문부터 다뤄보도록 하겠습니다. 대부분 언어에서 2방향 선택문의 구조는 매우 유사하지만, 다음과 같은 설계 고려 사항에 따른 미묘한 차이가 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선택을 제어하는 식의 타입은 무엇인가? (대부분의 언어에서는 불리안 식, C 언어에서는 산술 표현식)&lt;/li&gt;
  &lt;li&gt;단일 명령문만 선택할 수 있습니까, 아니면 명령문의 그룹도 선택할 수 있습니까?&lt;/li&gt;
  &lt;li&gt;다른 선택자의 ‘then’ 문에 중첩된 선택자의 의미를 어떻게 지정해야 합니까?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모든 명령형 언어에는 &lt;strong&gt;단방향 선택기(Single-Way Selector)&lt;/strong&gt;가 포함되어 있는데, 대부분 양방향 선택기의 하위 형태로 구현되어 있습니다. 그러나 BASIC과 Fortran은 예외이므로, 이 부분을 잠시 짚고 넘어가겠습니다.&lt;/p&gt;

&lt;p&gt;Fortran 언어에서 If(불리안 식) 문에서는 단일 선택만 가능하고, 중첩이 허용되지 않습니다. 이것은 GOTO 문의 사용을 촉진합니다. 매우 단순하지만, 유연성이 부족하다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;복합문은 문장의 그룹을 조건부로 실행하기 위한 간단한 방법입니다, ALGOL 60 언어에서는 begin과 end를 통해 복합문의 그룹을 명세합니다.&lt;/p&gt;

&lt;p&gt;Fortran 77, 90을 포함하여 ALGOL 60의 영향을 받은 대부분의 언어는 복합문을 선택할 수 있는 단방향 선택기를 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;양방향 선택기(Two-Way Selector)&lt;/strong&gt;는 두 가지 제어 경로 중 하나를 선택하는 것을 허용하는 제어문입니다. ALGOL 60에서는 if-then-else를 이용하여 이것을 구현했습니다.&lt;/p&gt;

&lt;p&gt;또한 선택자를 중첩할 수도 있습니다. 그러니 중첩 선택자들 간에 모호함이 발생한다는 문제가 있습니다. 예를 들어, 슬라이드에 있는 코드처럼 if - if - then - else 문을 사용했을 때, else가 어떤 if 문에 대해 수행되는지가 문제입니다. (들여쓰기를 보고 첫 번째 if 문과 매칭되야 할 것으로 착각하실 수 있는데, Python 같은 특수한 언어를 제외하고 들여쓰기는 언어에 아무런 영향을 미치지 않습니다)&lt;/p&gt;

&lt;p&gt;대부분의 명령형 언어에서는 else 문이 가장 가까이 있고 짝이 없는 then 절과 짝을 이루도록 지정합니다.&lt;/p&gt;

&lt;p&gt;ALGOL 60 언어에서 if 문은 else 문이 then에 직접 연결될 수 없고, 반드시 복합문에 넣어야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;if 문의 마지막 절이 then이든 else이든 복합문이 아닌 경우, 전체 선택 구조의 끝을 표시하는 구문 요소가 없습니다. 만약 선택 구조의 끝을 나타내는 특수어를 사용한다면 중첩 선택문의 모호함을 해결하고, 가독성을 향상시킬 수 있습니다. Modula-2 언어에서는 END, Fortran 77에서는 END IF를 사용하여 if 문의 끝을 나타냅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;다중 선택기(Multiple Selector)&lt;/strong&gt;는 여러 개의 문장이나 문장 그룹 중 하나를 선택하는 제어문입니다. 선택기의 일반화 개념으로 이해하시면 됩니다. 다중 선택기의 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선택을 제어하는 문장의 형식과 타입은 무엇인가?&lt;/li&gt;
  &lt;li&gt;단일 명령문만 선택할 수 있습니까, 아니면 명령문의 그룹도 선택할 수 있습니까?&lt;/li&gt;
  &lt;li&gt;전체 구성이 구문 구조로 캡슐화되어야 합니까?&lt;/li&gt;
  &lt;li&gt;선택 가능한 단일 명령문만 포함하도록 구조를 통한 실행 흐름을 제한해야 합니까? (ex. switch - break)&lt;/li&gt;
  &lt;li&gt;만약 표현되지 않는 선택자 식의 값이 존재할 경우, 어떻게 처리할 것인가? (ex. 1, 2, 3 선택인데 조건식이 4가 나온 경우)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortran에서는 슬라이드의 코드와 같이 GOTO 문을 이용하여 다중 선택기를 사용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현대의 다중 선택기는 Case 문을 이용하고 있습니다. ALGOL-W 에서 다중 선택기의 구조는 캡슐화되어 있으며, 선택 가능한 단일 세그먼트를 제공합니다. 실행하는 문장은 조건식에 값에 의해 선택된 문장들입니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어에서 선택 가능한 세그먼트에는 라벨이 지정되어 있습니다. 조건식은 정수, 불리안, 문자와 같은 순서 타입(Ordinal Type)으로 구성되어 있습니다. 조건식이 수행되고 나서 값이 세그먼트의 상수와 비교됩니다. 상수 목록은 조건식과 동일한 타입이어야 하며, 목록들 간에 상호 베타적이지만 완전할 필요는 없습니다. (ex. 1, 2, 3 과 같이 겹치는 부분이 없어야 하며 상수 목록이 정수 전체를 포함할 필요는 없음)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C 언어에서 제어식과 상수식은 모두 정수 타입입니다. 또한 세그먼트 별로 암묵적인 분기를 지원하지 않습니다. (즉, 명시적으로 세그먼트 별로 break를 나타내야 정확하게 분기됩니다)&lt;/p&gt;

&lt;p&gt;만약 순서 타입이 아닌 불리안 식을 기반으로 선택을 하는 경우에는 중첩된 양방향 선택기를 사용하여 다중 선택기처럼 만들 수 있습니다. 예를 들어, Ada 언어나 Fortran 90 에서 불리안 식과 else if를 사용한 코드가 슬라이드에 나와 있습니다. (Python도 이와 비슷하게 구현됩니다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;반복문(Iterative Statement)&lt;/span&gt;은 명령어, 또는 명령어 모음이 여러 횟수만큼 실행되도록 하는 문장입니다. 반복문을 흔히 루프(Loop)라고도 부릅니다. 반복문은 반복적 구조보다는 재귀 같은 것을 통해 함수형 언어로 수행되는 경우가 많습니다. 처음 개발된 반복문은 배열에 포함된 데이터를 처리하기 위해 개발되었기 때문에, 배열과 직접적인 관련이 있습니다.&lt;/p&gt;

&lt;p&gt;반복문의 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;반복이 어떻게 제어되는가? (논리, 계수, 또는 그 두 가지의 혼합형)&lt;/li&gt;
  &lt;li&gt;제어 메커니즘이 루프 어느 부분에 위치해야 하는가? (앞부분, 뒷부분, 또는 사용자 마음대로)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 계수로 제어하는 반복문에 대해 알아보겠습니다. 이러한 반복문은 초기 값(Initial), 종료 값(Terminal), 단계 크기(Stepsize)로 구성되어 있습니다. (이것들을 루프 매개변수라고 부릅니다) 계수로 제어하는 반복문은 종종 기계 명령어에 의해 지원됩니다. 이 때 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;루프 변수의 유형과 범위는 무엇인가? (정수, 문자, 열거형, 부동 소수점 등)&lt;/li&gt;
  &lt;li&gt;루프 종료 시 루프 변수에는 어떤 값이 들어가는가?&lt;/li&gt;
  &lt;li&gt;루프 변수, 또는 루프 매개변수가 루프 내에서 변경되는 것이 허용되는가? 그렇다면 그 변경 사항이 루프 제어에 영향을 주는가?&lt;/li&gt;
  &lt;li&gt;반복의 완료 검사는 루프의 맨 위에서 이루어지는가, 맨 아래에서 이루어지는가?&lt;/li&gt;
  &lt;li&gt;루프 매개변수는 한 번만 평가되는가? 아니면 각 반복에 대해 매번 평가되는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran IV 언어에서 반복문은 DO를 이용하여 사용합니다. 루프 변수에 대한 검사는 반복문의 수행 후 발생하며(Post-test), 초기 값, 종료 값, 단계 크기 변수는 부호 없는 정수, 또는 양수 값을 갖는 단순 정수 변수로 제한됩니다.&lt;/p&gt;

&lt;p&gt;만약 루프가 정상적으로 종료한다면 루프 변수의 값은 정의되지 않으며, 만약 비정상으로 종료된다면 가장 최근에 할당된 값이 저장됩니다.&lt;/p&gt;

&lt;p&gt;루프 변수와 루프 매개변수는 루프 내부에서 변경할 수 없기 때문에 루프 매개변수를 두 번 이상 평가할 필요가 없습니다. (즉, 반복문이 실행되기 전에 몇 번 반복을 해야하는지 예측할 수 있음)&lt;/p&gt;

&lt;p&gt;또한 Fortran IV 에서 루프 내부는 단일 명령어만 사용이 가능하기 때문에, 명령어 집합을 반복하고 싶다면 GOTO 문을 활용해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 77과 90에서 DO 문은 많이 변경되었습니다.&lt;/p&gt;

&lt;p&gt;먼저 루프 변수에 대한 검사는 반복문의 수행 전 발생하며(Pretest), 루프 변수는 정수, 실수, 그리고 확장 실수 타입에 대해서도 가능합니다. 루프 매개변수는 표현식으로 나타내는 것이 허용되며, 양수 값과 음수 값을 모두 가질 수 있습니다.&lt;/p&gt;

&lt;p&gt;루프는 루프 매개변수가 아니라 반복 횟수에 따라 제어됩니다. 따라서 루프 내에서 루프 매개변수가 변경되더라도, 이것은 루프 제어에 영향을 미치지 않습니다. 즉, 반복 횟수는 사용자가 접근할 수 없는 내부 변수입니다.&lt;/p&gt;

&lt;p&gt;DO 반복문에 진입하는 것은 DO 문을 사용해서만 입력할 수 있습니다. (단일 진입 구조)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 60에서 반복문은 계수기와 불리안 식으로 루프를 제어할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 for의 모든 표현식은 루프 문의 모든 반복이나 실행에 대해 평가됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어에서 반복문은 비교적 간단한 계수기-제어 사전 검사 루프입니다. &lt;strong&gt;reverse&lt;/strong&gt;는 discrete_range의 범위를 역순으로 루프 변수에 할당한다는 의미이고, discrete_range는 1~10 이나 Monday~Friday와 같이 정수나 열거 타입의 부분 범위를 말합니다.&lt;/p&gt;

&lt;p&gt;Ada 언어의 가장 큰 특징은 루프 변수의 범위입니다. 루프 변수는 루프 안에서만 묵시적으로 선언되고, 루프 종료 후에는 무시됩니다. 예를 들어, 슬라이드에 나와 있는 코드에서 COUNT는 실수형 변수로 1.35가 할당됩니다. 그런데 for 문의 루프 변수의 이름도 동일하게 COUNT입니다. 이 상황에서, 처음 선언한 COUNT 변수는 for 문에 영향을 받지 않습니다. 즉, for 문이 끝나도 COUNT 변수에는 여전히 실수값 1.35가 저장됩니다. 또한 루프 변수에는 루프 내부의 값을 할당할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 가장 친근한 언어인 C 언어의 경우를 살펴보겠습니다. C 언어도 Ada 언어와 마찬가지로 사전 검사 계수 루프 구조입니다. C 언어의 for 문이 어떻게 구성되어 있는지는 다들 아실테니 생략하도록 하겠습니다. C 언어의 for 문은 두 번째 표현식의 값이 0이면 종료됩니다. 그리고 그 외에는 루프 내부의 명령어, 또는 명령어 집합이 실행됩니다.&lt;/p&gt;

&lt;p&gt;또한 C 언어 for 문의 루프 매개변수들은 모두 선택적입니다. 예를 들어, 두 번째 식을 생략한다면 무한 루프로써 간주되고, 첫 번째와 세 번째 식이 생략되면 루프 변수를 고려하지 않습니다. 먄악 첫 번째 식만 생략되면 단순히 초기화가 일어나지 않는다는 것을 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반복 제어가 불리안 식에 기반하는 반복문을 &lt;span style=&quot;color:red&quot;&gt;논리 제어 루프(Logically Controlled Loop)&lt;/span&gt;라고 합니다. 논리 제어 루프는 계수기 제어 루프보다 일반적입니다. 즉, 모든 계수기 제어 루프는 논리 제어 루프로 표현할 수 있지만, 그 반대는 불가능합니다. 논리 제어 루프에서의 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제어가 사전 검사(Pretest)인가 사후 검사(Post-test)인가?&lt;/li&gt;
  &lt;li&gt;논리 제어 루프가 계수기 제어 루프의 특별한 형식인가, 아니면 전혀 다른 문법을 가지는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어, Pascal, Modula-2, C 기반 언어들은 사전 검사와 사후 검사 논리 제어 루프를 모두 가지고 있습니다. 예를 들어, C 언어의 while 문은 사전 검사 논리 제어 루프이고, do-while 문은 사후 검사 논리 제어 루프입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상황에 따라서는 프로그래머 루프 제어를 위한 검사를 루프의 처음이나 마지막이 아닌 곳을 선택해야할 수도 있습니다. 몇몇 언어는 이러한 기능을 제공하는데, 이것을 &lt;span style=&quot;color:red&quot;&gt;사용자 지정 루프 제어(User-located Loop Control)&lt;/span&gt;라고 합니다. 구현 자체는 간단하지만, 역시 이전 루프문과 마찬가지로 설계 고려 사항이 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;조건 매커니즘이 탈출에 필수적이어야 하는가?&lt;/li&gt;
  &lt;li&gt;탈출할 때는 하나의 루프만 탈출해야 하는가, 아니면 포괄하는 루프를 모두 탈출해야 하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ada 언어에서는 루프문에 레이블을 붙일 수 있습니다. 따라서 루프문 내에서 특정 레이블 루프를 지정하여 탈출하는 것이 가능합니다.&lt;/p&gt;

&lt;p&gt;C 언어에서는 루프문에 레이블을 붙일 수 없기 때문에 무조건 가장 가까이 있는 루프문만을 지정할 수 있습니다. break를 통해 가장 가까이 있는 루프문을 탈출할 수 있으며, continue를 통해 루프문을 탈출하지 않고 현재 반복에서 나머지 명령어를 생략하는 방식이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자료구조에 기반한 반복문도 있습니다. 이 때 루프는 계수기나 불리안 식이 아니라 자료구조의 원소 수에 의해 제어됩니다.&lt;/p&gt;

&lt;p&gt;Java 언어에서는 배열의 값이나 Iteratable 인터페이스를 통해 구현된 객체를 통해 for 문을 제어할 수 있습니다. 예를 들어, 문자열을 포함하는 myList라는 이름의 ArrayList 컬렉션이 있는 경우, 조건문에 이를 나타내면 각 원소를 myElement로 설정하며 반복문을 수행합니다.&lt;/p&gt;

&lt;p&gt;C# 언어도 마찬가지로 문자열 자료형인 String을 이용하여 foreach 문을 제어하는 것이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;무조건 분기문(Unconditional Branch)&lt;/span&gt;는 실행 제어를 프로그램의 지정된 위치로 이동시킵니다.&lt;/p&gt;

&lt;p&gt;무조건 분기문의 대표적인 명령어는 바로 GOTO 문으로, 프로그램의 실행 흐름을 제어하는 가장 강력한 명령문이지만 이 힘으로 인해 사용을 위험하게 만듭니다. (큰 힘에는 큰 책임이 따른다…)&lt;/p&gt;

&lt;p&gt;명령어의 실행 순서가 작성된 순서와 거의 동일할 때 가독성이 가장 좋습니다. (일반적으로 위해서 아래) 따라서 이러한 무조건 분기문은 가독성을 매우 낮출 수 있습니다. 그러한 문제점으로 인해 Modula-2, Bliss, CLU 등과 같은 언어는 GOTO 문이 없이 설계되었습니다. (+ Java, Python, Ruby) 여담으로 GOTO 문의 위험성을 알린 사람이 바로 다익스트라 알고리즘으로 유명한 &lt;strong&gt;에드가 다익스트라(Edger Dijkstra)&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;그러나 현재 가장 많이 사용되는 언어들에는 GOTO 문이 포함되어 있습니다. (대표적으로 C 언어)&lt;/p&gt;

&lt;p&gt;반복문에서 다루었던 루프 탈출 명령어는 사실 일종의 GOTO 문입니다. 그러나 이들은 상당히 역할이 제한된 GOTO 문이므로 가독성에 악영향을 미치지 않고, 오히려 가독성을 향상시키기도 합니다. 왜냐하면 이것들을 사용하지 않는다면 이해하기가 더 어렵거나 부자연스러운 코드가 나타날 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;무조건 분기문을 사용하기 위해서는 어느 위치로 이동할지 표시할 수 있어야 합니다. 이 때 많은 언어들이 코드 앞에 레이블을 붙이는 것으로 해결합니다. ALGOL 60 언어나 C 언어는 식별자를 이용하여 레이블을 붙이고, Fortran 언어나 Pascal은 음이 아닌 상수 정수를 이용하여 나타냅니다. PL/I은 특이하게 변수를 이용한 레이블을 허용합니다.&lt;/p&gt;

&lt;p&gt;이러한 레이블을 허용하는 대부분의 언어에서는 레이블의 사용을 어느 정도 제한하고 있습니다. 만약 Pascal 언어에서 레이블은 변수처럼 정의되지만, 그것을 매개변수로 전달하거나, 저장하거나, 수정할 수 없습니다. 또한 Pascal에서의 GOTO 문은 실행이 시작되었고 아직 종료되지 않은 경우를 제외하고, 제어 구조의 복합문의 명령어를 대상으로 지정할 수 없습니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 슬라이드의 왼쪽에서는 GOTO 100을 지정했지만, 레이블 100을 포함하고 있는 while 문은 이미 실행이 종료되었기 때문에 불가능합니다. 오른쪽과 같이 실행은 되었으나 종료되지 않은 경우에만 지정이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;span style=&quot;color:red&quot;&gt;보호 명령(Guarded Command)&lt;/span&gt;에 대해 알아보겠습니다. 보호 명령은 동시성 프로그래밍(Concurrent Programming)을 위해 도입된 개념이며, 다익스트라가 선택문과 비슷한 구조로 만들었습니다. 보호 명령의 각 줄은 한 개의 불리안 식(보호)와 한 개의 명령어, 또는 명령어 묶음으로 구성됩니다.&lt;/p&gt;

&lt;p&gt;형태는 다중 선택문과 유사하지만, 이 표현식에 도달한다면 모든 불리안 식이 평가됩니다. 둘 이상의 식이 참인 경우, 해당 명령어 중 하나가 비결정적으로(=무작위로) 선택됩니다. 만약 참이 하나도 없다면 프로그램을 종료시키는 실행 시간 오류가 발생합니다. 이것은 프로그래머가 모든 가능성을 고려하도록 강요합니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 슬라이드에 나와 있는 것처럼 Ada 언어로 보호 명령을 구현한 코드를 보겠습니다. 만약 i = 0이고 j = 1이라면, 첫 번째와 세 번째 명령어 중 무작위가 선택되어 수행됩니다. 만약 i = j이고 i가 0이 아니면, 어떤 조건도 참이 아니기 때문에 실행 시간 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;보호 명령을 사용하면 프로그램을 좀 더 깔끔하게 작성할 수 있다는 장점이 있습니다. 예를 들어, 슬라이드 아래에 나와 있는 코드는 4개의 정수 q1, q2, q3, q4가 주어져 있을 때 이를 오름차순으로 정렬하는 코드입니다. 이것은 반복문이기 때문에 모든 불리안 식이 거짓이면 루프가 종료되는 방식입니다. 만약 이것을 보호 명령을 사용하지 않고 구현한다면 정렬 알고리즘을 사용해야 하는데, 이것은 상당히 많은 코드를 요구하는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 순서도는 보호 명령을 사용한 조건문과 반복문이 어떤 과정을 통해 수행되는지 나타내는 그림입니다. 조건문은 모든 불리안 식이 거짓이면 실행 시간 에러를 내고, 두 개 이상의 조건이 참이면 그 중 무작위로 선택하여 실행합니다. 반복문은 모든 불리안 식이 거짓이면 빠져나오고, 두 개 이상의 조건이 참이면 그 중 무작위로 선택하여 실행합니다. 물론 한 개의 조건만 참이면 그 명령어만 실행합니다.&lt;/p&gt;

&lt;p&gt;8장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Expressions and the Assignment Statement</title><link href="http://localhost:4000/pl/expressions-and-the-assignment-statement/" rel="alternate" type="text/html" title="Expressions and the Assignment Statement" /><published>2023-09-07T00:00:00+09:00</published><updated>2023-09-07T00:00:00+09:00</updated><id>http://localhost:4000/pl/expressions-and-the-assignment-statement</id><content type="html" xml:base="http://localhost:4000/pl/expressions-and-the-assignment-statement/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;7장의 주제는 식과 배정문입니다. 이번 장을 한 문장으로 요약하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“식의 연산자 수행 순서는 언어의 연관성 및 우선순위 규칙에 따라 결정됩니다. 폰 노이만 구조 환경에서 배정문은 가장 기본적인 문장입니다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 먼저 &lt;span style=&quot;color:red&quot;&gt;산술식(Arithmetic Expression)&lt;/span&gt;에 대해 알아보겠습니다. 프로그래밍 언어에서 수학의 산술식과 동일하게 표현하는 것은 고급 언어의 주요 목표 중 하나였습니다. 따라서 프로그래밍 언어에서의 산술식은 수학에서의 관례를 그대로 가져온 경우가 많습니다.&lt;/p&gt;

&lt;p&gt;따라서 연산자의 수행 순서는 수학에서의 그것과 거의 동일합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;식 하나에 서로 다른 우선순위 수준의 연산자가 수행되는 순서는 우선순위의 계층 구조로 평가합니다. 예를 들어, a + b * c에서 * 연산은 + 연산보다 높은 계층에 있기 때문에 먼저 계산합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단항 + 연산자를 &lt;strong&gt;항등 연산자(Identity Operator)&lt;/strong&gt;라고 부릅니다. 왜냐하면 피연산자에 대해 아무런 효과를 미치지 않기 때문입니다. A로 표시하나 +A로 표시하나 의미는 동일합니다. 단항 - 연산자는 피연산자의 부호를 변경합니다. 일반적으로 단항 연산자는 다른 연산자와 인접하는 것을 피하기 위해 소괄호를 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;명령형 언어의 연산자 우선순위 규칙은 거의 모두 동일합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;식에서 동일한 우선순위를 갖는 연산자가 여러 개 존재할 경우, 어떤 연산자가 먼저 수행될 것인지는 프로그래밍 언어의 &lt;span style=&quot;color:red&quot;&gt;결합 법칙(Associativity Rule)&lt;/span&gt;에 따릅니다. 프로그래밍 언어의 결합 법칙은 일반적으로 왼쪽에서 오른쪽 순서입니다. 예를 들어, A - B + C - D 식에서는 A - B가 가장 먼저 계산됩니다. 그러나 예외적인 경우도 있는데, C 언어에서 ++, –, 단항 연산자 +과 -인 경우에는 오른쪽부터 계산됩니다. APL은 특이하게도, 연산자 우선순위가 존재하지 않고 무조건 오른쪽부터 왼쪽으로 수행합니다. 예를 들어, A * B + C 라는 연산이 있다면, APC은 B + C를 먼저 수행합니다.&lt;/p&gt;

&lt;p&gt;만약 컴파일러가 연산자 수행 순서를 변경할 수 있는 경우, 식의 수행을 위한 코드를 더 빨리 생성할 수 있습니다. 무슨 말이냐 하면, 예를 들어 A + B + C + D라는 식이 있다고 가정해봅시다. 기본적으로 정수의 덧셈은 우선순위가 동일하기 때문에 왼쪽부터 수행하게 됩니다. 만약 A와 B가 매우 큰 양수이고, C와 D가 절대값이 매우 큰 음수라면, 순서대로 덧셈을 진행했을 때 A + B는 오버플로를 야기하게 됩니다. 이것은 수학의 문제가 아니라 컴퓨터 산술의 한계로 인해 발생하는 것이기 때문에, 컴퓨터에서는 이것이 동일한 연산이 아닐 수도 있다는 뜻이 됩니다. 따라서 컴파일러가 이러한 덧셈 연산의 순서를 재조정하면 오버플로 문제를 회피할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 프로그래머는 식에 괄호를 포함하여 우선순위 규칙이나 결합 법칙을 변경할 수 있습니다. 예를 들어, (A + B) * C 와 같이 괄호를 포함하여 우선순위가 낮은 덧셈 연산을 곱셈 연산보다 먼저 처리하게 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 연산자의 피연산자가 &lt;span style=&quot;color:red&quot;&gt;부작용(Side Effect)&lt;/span&gt;을 갖고있다면, 피연산자의 수행 순서가 중요합니다. 함수적 부작용이란, 함수가 매개변수나 전역 변수를 변경하는 것을 말합니다. 예를 들어, 위 슬라이드 중간에 있는 코드를 보겠습니다. sub1 프로시저에서 정수형 변수 a가 선언되어 있습니다. 그런데 하위 프로시저 sub2에서 a에 10을 할당하고, b에 a + fun(b)를 할당합니다. 문제는, 함수 fun()에서 a의 값을 변화시키는 명령어가 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;이런 경우 a + fun(b)에서 fun(b)의 실행 순서의 따라 15가 될지, 32가 될지 달라집니다. 이러한 문제를 해결하기 위한 두 가지 해결책이 있습니다. 첫 번째 방법은 처음부터 언어를 설계하는 컴퓨터과학자가 함수적 부작용을 허용하지 않게 만들어서 함수 결과가 식의 값에 영향을 미치는 것을 막는 것입니다. 그러나 명령형 언어에서 이것을 허용하지 않게 되면 프로그램의 유연성이 감소시키는 또 다른 문제가 발생합니다. 예를 들어, 함수적 부작용을 막는다면 함수에서 전역 변수에 접근할 수 없습니다. 두 번째 방법은 식에 포함된 피연산자들이 특정 순서로 수행된다고 정의하는 것입니다. 예를 들어, Java 언어는 피연산자들이 무조건 왼쪽부터 오른쪽으로 수행되는 것으로 정의되었기 때문에 예제 코드와 같은 상황에서 항상 15의 결과가 나옵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 최근 대부분의 고급 언어에서는 if-then-else 문으로 조건 연산을 수행합니다. C 언어 같은 경우에는 더 간단하게 ? 연산자로 표기할 수 있습니다.&lt;/p&gt;

&lt;p&gt;산술 연산자는 여러 가지 목적으로 사용될 수도 있습니다. 예를 들어, + 연산자는 일반적으로 정수나 실수의 덧셈 연산을 수행하는 연산자이지만, Java 언어에서는 문자열을 잇는데 사용할 수도 있습니다. 이것을 &lt;span style=&quot;color:red&quot;&gt;연산자 오버로딩(Operator Overloading)&lt;/span&gt;이라고 부릅니다. 연산자 오버로딩을 남용하면 가독성이나 신뢰성을 낮출 수 있기 때문에 사용에 주의해야 합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 Fortran 언어에서 + 연산은 정수 피연산자에 사용하면 정수 덧셈, 실수 피연산자에 사용하게 되면 실수 덧셈을 수행합니다. 이것은 수학적으로도 일반적인 표현이기 때문에 크게 문제가 되지 않지만, C 언어에서 &amp;amp; 연산자는 이것과 경우가 조금 다릅니다. &amp;amp; 연산자를 이항 연산으로 사용하면 논리 AND 연산을 수행하지만, 단항 연산자라면 변수의 주소를 불러옵니다. 이 경우 만약 C 언어에서 실수로 왼쪽의 피연산자를 누락한다면 컴파일러는 이 오류를 탐지하지 못합니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어는 연산자 오버로딩을 피하기 위해 실수 나눗셈에는 / 연산자를 사용하고, 정수 나눗셈에는 div 연산자를 사용합니다.&lt;/p&gt;

&lt;p&gt;또한 프로그래밍 언어 중에서는 사용자 정의 연산자 오버로딩을 허용하는 경우도 있습니다. 예를 들어 Ada 언어는 오버로딩 된 연산자를 발견하면 피연산자의 타입에 따라 올바른 의미를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 &lt;span style=&quot;color:red&quot;&gt;타입 변환(Type Conversion)&lt;/span&gt;에 대해 알아보겠습니다. 타입 변환에는 두 가지 종류가 있는데, 컴파일러에 의해 수행되는 묵시적 타입 변환(Coercion)과 프로그래머가 명시적으로 수행하는 타입 변환(Casting)이 있습니다.&lt;/p&gt;

&lt;p&gt;타입 변환으로 데이터 타입은 축소될 수도 있고 확장될 수도 있습니다. Java 언어에서 double 데이터 타입을 float로 변환하는 것은 &lt;strong&gt;축소 변환(Narrowing Conversion)&lt;/strong&gt;입니다. 반대로 float 데이터 타입을 double로 변환하는 것은 &lt;strong&gt;확장 변환(Widening Conversion)&lt;/strong&gt;입니다. 확장 변환은 거의 항상 안전하지만, 축소 변환은 상황에 따라 값의 크기가 변경될 수 있으므로 위험합니다.&lt;/p&gt;

&lt;p&gt;확장 변환은 대부분 안전하지만, 정확성을 낮추는 문제가 발생할 수도 있습니다. 예를 들어, int 데이터 타입을 float로 변환한다고 가정해봅시다. int는 일반적으로 32비트에 저장되는데, float도 마찬가지로 32비트에 저장됩니다. 따라서 int에서의 정수는 9자리 십진수까지 정확하게 저장할 수 있지만, float는 단지 7자리 십진수까지의 정확성만 보장됩니다. 따라서 정수 데이터 타입에서 부동 소수점 데이터 타입으로의 확장 변환은 정확성 손실이 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;묵시적 타입 변환의 설계 방법에 대해 자세히 알아보겠습니다. Fortran 77의 경우 모든 숫자형 데이터 타입은 확장 변환으로만 묵시적 타입 변환이 수행됩니다. 고전 C 언어의 경우에는 거의 항상 확장 변환이 수행됩니다. 예를 들어, float나 short int와 같은 데이터 타입으로도 수행 가능한 연산이라고 할지라도, 식이나 매개변수로써 사용될 때 항상 double이나 int로 강제 변환됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 하나의 식 안에 여러 데이터 타입이 혼재할 때도 타입 변환이 일어날 수 있습니다. 이것은 타입 검사와도 연관된 내용입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 Fortran 77에서, A, B, C는 정수형 변수로, D는 실수형 변수로 정의가 되어 있습니다. 그리고 C = FUN(A + D) 식을 수행하는데, FUN() 함수는 매개변수로 정수형 변수가 들어가야 합니다. 이 경우 A + D가 정수 + 실수이기 때문에 엄밀한 타입 검사를 수행할 경우 오류가 발생해야하지만, Fortran 77은 이것을 오류로 탐지하지 않고 A를 실수 타입으로 강제로 변환합니다. 이와 달리 Ada 언어와 Modula-2 언어는 식에서 정수와 부동 소수점 실수의 연산을 허용하지 않습니다.&lt;/p&gt;

&lt;p&gt;명시작 타입 변환은 Ada 언어와 Modula-2 언어에서 함수 호출로 수행합니다. 예를 들어, FLOAT(SUM)과 같이 함수의 매개변수로 변수를 넣어서 그 반환값을 원하는 데이터 타입으로 받은 구조입니다. C 언어에서는 소괄호를 이용하여 (int) SUM과 같이 표기합니다.&lt;/p&gt;

&lt;p&gt;이러한 타입 변환은 식의 오류를 발생시킬 수도 있습니다. 이런 오류는 주로 컴퓨터의 산술 연산의 한계로 인해 발생합니다. 계산 결과가 너무 작으면 &lt;strong&gt;언더플로(Underflow)&lt;/strong&gt;나 너무 크면 &lt;strong&gt;오버플로(Overflow)&lt;/strong&gt; 문제가 발생할 수 있습니다. 또한 강제 변환으로 인해 값이 0으로 변환되어 나눗셈에서 오류가 발생할 수도 있습니다. 이러한 오류를 &lt;span style=&quot;color:red&quot;&gt;예외(Exception)&lt;/span&gt;라고 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 &lt;span style=&quot;color:red&quot;&gt;관계식(Relational Expression)&lt;/span&gt;에 대해 알아보겠습니다. 관계식은 2개의 피연산자와 1개의 관계 연산자(Relational Operator)로 이루어진 식입니다. 관계식의 결과값은 Boolean 타입(True/False)입니다. 관계 연산자는 일반적으로 다양한 데이터 타입에 대해 오버로딩 될 수 있습니다. 관계식의 참이나 거짓을 결정하는 연산은 피연산자의 타입에 따라 달라집니다. 피연산자가 정수인 경우에는 단순하지만, 문자열인 경우에는 다소 복잡할 수도 있습니다. 관계 연산자는 항상 산술 연산자보다 우선순위가 낮다는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;불리안 식(Boolean Expression)&lt;/span&gt;은 불리안 변수, 불리안 변수, 관계식, 불리안 연산자로만 구성된 식을 말합니다. 불리안 연산자는 AND, OR, NOT을 말합니다. 이러한 식에서도 연산자간의 우선순위가 존재합니다. (C99 이전의) C 언어 같은 경우에는 Boolean 타입이 없기 때문에 Boolean 값도 없습니다. 대신 0은 false, 그 외의 값은 모두 true로 취급합니다. 따라서 a &amp;gt; b &amp;gt; c와 같은 연산이 가능하지만, 실제 이 식에서 b &amp;gt; c 연산은 수행되지 않습니다. C 언어는 이러한 특성으로 인해 불리안 식에서 오류를 감지하기 어렵습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;단락 평가(Short-circuit Evaluation)&lt;/span&gt;는 모든 피연산자와 연산자를 수행하지 않고 결과가 결정되는 것을 말합니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(13 * A) * (B / 13 - 1)&lt;/code&gt; 이란 식은 A가 0이라면 나머지 식을 계산할 필요도 없이 0이 나옵니다. 그러나 컴퓨터는 실행 중에 이러한 산술식을 쉽게 발견하기 어렵기 때문에 일반적으로 고려되지 않습니다.&lt;/p&gt;

&lt;p&gt;그러나 불리안 식의 경우는 조금 다릅니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(A &amp;gt;= 0) and (B &amp;lt; 10)&lt;/code&gt;라는 식은 A &amp;lt; 0이면 (B &amp;lt; 10)의 결과는 볼 필요도 없습니다. 산술식과는 달리, 컴퓨터는 이러한 단락을 쉽게 발견할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어에서는 단락 평가를 사용하지 않으므로 때때로 실행 시간 오류를 발생시킵니다. 예제의 코드를 보면, 단락 평가를 사용하지 않을 때는 항상 while 문 내의 두 개의 식을 모두 수행합니다. 이 식에서 마지막 루프에서 index의 값은 11이 되는데, 만약 단락 평가를 사용한다면 (index &amp;lt;= listlen)이 False이기 때문에 바로 while문을 빠져나옵니다. 그러나 단락 평가를 사용하지 않는다면 (list[index] &amp;lt;&amp;gt; key) 식까지 수행해야 하는데, 이 때 list[11]은 배열의 범위 밖이기 때문에 실행 시간 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;Fortran 언어에서는 결과를 결정하는 데 필요한 것보다 더 많은 식을 수행하지 않도록 선택할 수 있습니다. 그런데 이 경우에도 문제가 발생할 수 있습니다. 만약 수행하지 않는 식에 부작용이 있는 경우인데요, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a &amp;gt; b) || (b++ / 3)&lt;/code&gt;에서 (a &amp;gt; b)가 True이면 뒤의 연산은 수행할 필요가 없습니다. 그런데 이 식에는 ++ 라는 증감 연산자가 포함되어 있습니다. 프로그래머는 항상 이 식이 수행될 때마다 b의 값을 증가시키고 싶었겠지만, 그것이 수행되지 않는다면 의도대로 동작하지 않는다는 문제가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어에서는 프로그래머가 and then과 or else의 연산자를 사용하여 불리안 연산자 and와 or가 단락 평가를 할 수 있도록 허용합니다. 슬라이드에 나온 코드는 이전 슬라이드의 Pascal 언어와 동일한 역할을 수행하지만, 범위를 벗어난 실행 시간 오류를 발생시키지 않습니다.&lt;/p&gt;

&lt;p&gt;C 언어와 Modula-2에서는 AND와 OR 연산 모두 기본적으로 단락 평가를 수행합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;단락 평가의 여부는 Ada 언어와 같이 프로그래머에게 선택권을 주는게 가장 좋은 설계입니다. Ada의 and then과 or else는 불리안 식의 일부를 조건부로 평가하는데 사용됩니다. 단락 평가의 올바른 사용은 이전 슬라이드의 코드처럼 예외를 발생시키는 식의 수행을 방지하는 것입니다.&lt;/p&gt;

&lt;p&gt;단락 평가의 여부를 프로그래머에게 맡겼기 때문에 프로그래머는 코드 설계를 정확하게 수행할 필요가 있습니다. 예를 들어, 중간에 있는 코드에서 G(Dog)는 Dog가 null이 아닌 경우에만 수행됩니다. and then이 없으면 항상 G(Dog)가 수행되어 Dog가 null 일 때 예외가 발생합니다.&lt;/p&gt;

&lt;p&gt;Ada에서 and then과 or else는 오버로딩 될 수 없으므로, 엄밀히 말하면 연산자가 아닙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;배정문(Assignment Statement)&lt;/span&gt;은 명령형 언어의 핵심 구성 요소 중 하나로써, 프로그래머가 변수에 대한 값의 바인딩을 동적으로 변경할 수 있는 메커니즘입니다.&lt;/p&gt;

&lt;p&gt;가장 간단한 배정문은 대상 변수, 배정 연산자, 식으로 구성되어 있습니다. 배정 연산자(Assignment Operator)는 최근 대부분의 언어에서 ‘=’를 사용합니다만, 과거에는 동등 연산자과 구분하기 위해 ‘:=’를 사용했습니다. 현재 동등 연산자는 ‘==’를 사용하기 때문에 배정 연산자와 구분이 가능합니다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어에 따라 대상이 여러 변수인 경우에도 배정이 가능한 경우가 있습니다. 예를 들어, PL/I의 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM, TOTAL = 0&lt;/code&gt;을 사용하면 SUM과 TOTAL 변수에 모두 0이 배정됩니다. C 언어의 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM = TOTAL = 0&lt;/code&gt;을 이용하서 같은 배정을 수행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배정문에 조건을 넣어 값을 배정하는 것도 가능합니다. 예를 들어, C++ 언어에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flag ? count1 : count 2 = 0;&lt;/code&gt; 라는 표현은 다음 코드와 동일한 의미를 갖습니다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;count1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;count2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;복합 배정 연산자(Compound Assignment Operator)&lt;/span&gt;는 배정문의 좌변과 우변에서 공통적으로 사용되는 피연산자를 축약하는 방법입니다. 예를 들어, C 언어에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum = sum + value;&lt;/code&gt; 와 같이 좌변과 우변에서 동일한 변수가 사용될 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum += value;&lt;/code&gt;로 표현하는 것을 허용합니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;단항 배정 연산자(Unary Assignment Operator)&lt;/span&gt;는 증가 연산이나 감소 연산을 배정문으로 축약하여 단일 연산자로 사용하는 방법입니다. 예를 들어, C 언어에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count = count + 1;&lt;/code&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count++;&lt;/code&gt;로 축약하여 표현할 수 있습니다. 단항 배정 연산자를 지원하지 않는 언어는 대표적으로 Python 언어가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C를 비롯한 C 기반 언어들에서 배정문은 배정되는 값과 동일한 결과를 생성합니다. 그래서 배정문 자체를 식의 피연산자로 쓸 수 있습니다. 예를 들어, 슬라이드의 반복문에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch = get()&lt;/code&gt; 이라는 배정문이 있습니다. 이때 ch에는 표준 입력으로 받은 문자가 들어가지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch = get()&lt;/code&gt;의 수행 결과도 동일하게 해당 문자가 들어갑니다. 이 때, 반드시 소괄호로 영역을 지정해줘야 합니다. 왜냐하면 배정 연산자는 관계 연산자보다 우선순위가 낮기 때문입니다. (그 경우 ch에는 0이나 1의 값이 들어갑니다)&lt;/p&gt;

&lt;p&gt;이러한 표현을 허용하는 것은 가독성을 매우 낮추는 단점이 있습니다. 대신 이 방법을 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum = count = 0;&lt;/code&gt;처럼 여러 대상에게 동시에 할당하는 것이 가능해집니다. 다만 이로 인해 관련 오류를 찾기 힘들어지는 단점이 있습니다. C 언어를 처음 배울 때  조건문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x == y&lt;/code&gt;가 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x = y&lt;/code&gt;를 입력하는 실수를 하신 분들이 많을겁니다. 만약 이것이 오류라면 컴파일러가 오류를 잡아주지만, C 언어에서는 이게 정상적인 식으로 인식되기 때문에 직접 눈으로 찾지 않는 이상 발견할 수 없다는 문제가 있습니다. 따라서 Java 언어는 이것을 불허하여 이 문제를 예방하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;혼합형 식과 마찬가지로 &lt;span style=&quot;color:red&quot;&gt;혼합형 배정문(Mixed-mode Assignment)&lt;/span&gt;도 존재할 수 있습니다. 혼합형 배정문을 설계할 때는 다음을 고려해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;식의 타입이 할당되는 변수의 타입과 동일해야 하는가?&lt;/li&gt;
  &lt;li&gt;두 타입이 일치하지 않는 경우에는 타입 강제 변환을 사용해야 하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortran 언어(그리고 C)에서는 혼합형 식에서 사용되는 것처럼 혼합형 배정문에 타입 강제 변환을 사용합니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어에서는 부동 소수점 변수에 할당할 수 있는 일부 강제 변환 정수가 포함되어 있습니다.&lt;/p&gt;

&lt;p&gt;Ada 언어나 Modula-2 언어에서 할당할 때는 정수를 부동 소수점으로 강제 변환하는 것을 허용하지 않습니다.&lt;/p&gt;

&lt;p&gt;7장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Data Types</title><link href="http://localhost:4000/pl/data-types/" rel="alternate" type="text/html" title="Data Types" /><published>2023-09-01T00:00:00+09:00</published><updated>2023-09-01T00:00:00+09:00</updated><id>http://localhost:4000/pl/data-types</id><content type="html" xml:base="http://localhost:4000/pl/data-types/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;6장에서는 데이터 타입의 개념과 각 데이터 타입의 특성을 소개합니다. 이번 장을 한 문장으로 요약하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“컴퓨터 프로그램은 데이터를 조작하여 결과를 생성합니다. 이 작업을 쉽게 수행할 수 있는지 판단하는 중요한 요소는 데이터 타입이 실제 문제와 얼마나 유사한가입니다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;데이터 타입(Data Type)&lt;/span&gt;은 데이터 값들의 모임과 그 값들에 대해 미리 정의된 연산들의 집합으로 정의됩니다. 프로그램은 데이터를 토대로 여러 연산을 통해 결과를 도출하기 때문에, 사용하는 언어에서 제공하는 데이터 타입이 현실의 문제와 얼마나 잘 매칭되는가가 중요합니다.&lt;/p&gt;

&lt;p&gt;몇 가지 사례를 소개하자면, Fortran 90 이전에는 기본적인 데이터 구조만을 지원했기 때문에, 연결 리스트나 트리가 모두 배열로 구현되었습니다. COBOL은 십진수의 데이터 값과 레코드를 위한 데이터 타입을 지원했습니다. PL/I는 다양한 분야에 사용하는 것을 목적으로 만들어졌기 때문에 많은 데이터 타입을 지원하였습니다. ALGOL 68은 기본적인 데이터 타입을 지원하되, 필요한 경우 사용자가 직접 만들 수 있는 데이터 타입을 지원하였습니다. Ada 언어에 이르러서는 추상 데이터 타입을 지원하기 시작했습니다. 추상 데이터 타입은 직접적으로 구현 방법을 명시하지는 않고 데이터와 데이터에 대한 연산을 나타내는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;원시 데이터 타입(Primitive Data Type)&lt;/span&gt;은 다른 타입의 관점에서 정의되지 않은 데이터 타입을 말합니다. 즉, 언어에서 기본적으로 제공하는 데이터 타입이라고 생각하시면 됩니다. 이러한 데이터 타입은 표현과 연산이 하드웨어에서 지원하는데, 구조화된 타입을 제공하기 위해서는 원시 데이터 타입과 함께 한 개 이상의 타입 생성자가 함께 사용됩니다.&lt;/p&gt;

&lt;p&gt;원시 데이터 타입 중 &lt;strong&gt;수치 타입(Numeric Type)&lt;/strong&gt;에 대해 알아보겠습니다. 수치 타입 중 가장 대표적인 타입이 바로 &lt;span style=&quot;color:red&quot;&gt;정수(Integer)&lt;/span&gt;입니다. 정수형 타입은 컴퓨터에 따라 다른 크기가 지원되는데, 예를 들어 byte, word, long word, quadword 등이 있습니다. C, C++, C# 등과 같은 언어에서는 부호가 없는 정수(Unsigned Int) 타입을 지원하는데, 이것은 주로 이진 데이터에 대해 사용합니다.&lt;/p&gt;

&lt;p&gt;Word가 실제로 메모리에 차지하는 비트의 수는 컴퓨터의 CPU에 따라 달라집니다. (16비트 컴퓨터, 32비트 컴퓨터 등)&lt;/p&gt;

&lt;p&gt;정수 자료형을 구현할 때는 비트 문자열로 표기하며, 일반적으로 가장 왼쪽에 있는 비트는 부호를 나타냈습니다. 그러나 최근에는 덧셈과 뺄셈 연산이 편리한 2의 보수(2’s Compliment) 표기법을 많이 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실수를 모델링하기 위해서는 일반적으로 &lt;span style=&quot;color:red&quot;&gt;부동 소수점(Floating Point)&lt;/span&gt;을 사용합니다. 그러나 부동 소수점은 대부분 실수 값을 근사할 뿐입니다. 많이 사용되는 실수인 $\pi$나 $e$ 조차 정확하게 표기가 불가능합니다. 예를 들어 십진수 0.1을 부동 소수점으로 표기한다면, 이진수 0.0001100110011…로 정확하게 표현되지 않습니다.&lt;/p&gt;

&lt;p&gt;부동 소수점 데이터 타입은 대부분의 언어에 포함되어 있지만, 많은 소형 컴퓨터에서는 하드웨어에서 지원하지 않는 경우가 많습니다. 이런 경우 고정 소수점 방식을 사용하거나, 아니면 근사치를 나타낸 표를 저장하여 처리하기도 합니다. 그러나 이런 경우까지 고려하실 필요는 없고, 과학적인 프로그래밍을 지원하는 언어에서는 일반적으로 float와 double이라는 두 가지 타입을 제공합니다.&lt;/p&gt;

&lt;p&gt;부동 소수점은 IEEE 754 규격을 이용하여 구현하는데, 이것은 부호 비트, 지수부, 소수부로 구성되어 있습니다. double 타입은 일반적으로 더 정밀한 소수를 표현하기 위해서 사용하므로, float 타입에 비해 두 배 이상의 소수부를 갖고 있는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비즈니스 업무에 사용하는 것이 상정된 컴퓨터들은 하드웨어에서 &lt;span style=&quot;color:red&quot;&gt;십진수(Decimal)&lt;/span&gt; 데이터 타입을 지원합니다. 십진수 타입은 부동 소수점과 다르게 제한된 범위 내에서 소수 값을 정확하게 저장할 수 있는 장점이 있습니다. 대표적인 십진수 데이터 타입은 &lt;strong&gt;BCD(Binary Coded Decimal)&lt;/strong&gt;로, 이진수 코드를 사용하여 문자열과 비슷하게 저장하는 방식입니다. BCD에는 packed 방식과 unpacked 방식이 있습니다. unpacked 방식은 자리수 하나당 1개의 바이트를 이용해서 표현하는 방식이고 (4개는 의미 없음), packed 방식은 2개의 자리를 1개의 바이트로 압축하여 표현하는 방식입니다. unpacked 방식의 경우 남는 4개의 비트를 1로 채우지만, 마지막 글자의 경우 숫자가 양수인지 음수인지에 따라 다릅니다. 양수의 경우 1100, 음수의 경우에는 1101로 표현합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;불리안 타입(Boolean Type)&lt;/span&gt;은 참과 거짓만 나타낼 수 있는 가장 간단한 데이터 타입입니다. ALGOL 60에서 처음 도입되었으며, 스위치나 플래그를 표현하기 위해서 사용합니다. 불리안 타입은 한 개의 비트로 표현이 가능하지만, 컴퓨터에서 한 개의 비트를 효율적으로 접근할 수 없기 때문에 일반적으로 1개의 바이트로 구현됩니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;문자 타입(Character Type)&lt;/span&gt;은 일반적으로 수치 값으로 컴퓨터에 저장됩니다. 가장 많이 사용하는 기법은 ASCII(American Standard Code for Information Interchange)로써 0부터 127까지의 값을 사용합니다. 그러나 세계화가 이루어짐에 따라 128개의 글자가 부족해졌고, 결국 1991년 Unicode라는 새로운 규격이 만들어졌습니다. C 언어와 C++ 언어는 계속 ASCII 코드를 사용하지만, Java, Python과 같이 그 뒤에 나온 언어들은 Unicode를 사용하여 문자를 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;문자열 타입(Character String Type)&lt;/span&gt;은 문자들로 구성되는 타입입니다. 문자열은 문자 조작을 하는 모든 프로그램에서 필수적인 데이터 타입입니다. 문자열 타입을 설계할 때 중요한 두 가지 고려사항이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스트링이 원시 타입인가, 아니면 단순히 문자 배열의 특수한 종류인가?&lt;/li&gt;
  &lt;li&gt;스트링이 정적의 길이를 갖는가, 아니면 동적인 길이를 갖는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저 첫 번째 고려사항부터 살펴보겠습니다. 문자열을 단순히 문자의 배열로 취급하는 대표적인 언어가 바로 C 언어입니다. 이러한 언어들에서는 표준 라이브러리를 통해 문자열 연산 기능을 제공하며(string.h), 널 문자(\0)를 이용하여 문자의 끝을 나타냅니다.&lt;/p&gt;

&lt;p&gt;반대로 문자열을 원시 타입으로 제공하는 언어들도 있습니다. Java나 Python이 채택한 방법인데, 이러한 방법은 언어의 작성력이 증가하며 그에 따른 비용도 크지 않다는 장점이 있습니다. 원시 타입으로 문자열 타입을 제공할 경우, 할당, 관계 연산자, 연결 및 하위 문자열 참조와 같은 기능을 기본 연산으로 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로는 문자열 길이에 관한 고려사항입니다. 생성될 때 길이가 같이 정해지는 문자열을 &lt;span style=&quot;color:red&quot;&gt;정적 길이 스트링(Static Length String)&lt;/span&gt;이라고 합니다. Fortran 77과 90, COBOL, Ada 언어에서 기본적으로 제공하는 문자열이 바로 이런 방식입니다.&lt;/p&gt;

&lt;p&gt;다른 방법으로는 문자열 변수를 선언할 때 길이가 같이 선언되지만, 고정된 최대 길이까지 가변적인 길이를 갖는 것을 허용하는 &lt;span style=&quot;color:red&quot;&gt;제한된 동적 길이 스트링(Limited Dynamic Length String)&lt;/span&gt;이 있습니다. C 언어에서의 문자열이 바로 이런 구조입니다. 왜냐하면 문자열의 길이를 나타낼 때, 배열의 길이 자체가 변하는 것이 아니라 널 문자가 어디에 있는지에 따라 문자열의 끝이 달라지기 때문입니다.&lt;/p&gt;

&lt;p&gt;마지막 방법은 문자열이 최대 길이의 제한 없이 가변 길이를 갖는 것을 허용하는 &lt;span style=&quot;color:red&quot;&gt;동적 길이 스트링(Dynamic Length String)&lt;/span&gt; 방식입니다. JavaScript나 C++ 언어가 이러한 방식을 채택하고 있는데, 동적 기억공간 할당과 회수에 따른 부담이 늘어나지만 유연성을 갖는다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;특이하게 Ada 95 이후의 Ada 언어는 이 세 가지 방법을 모두 지원합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문자열 타입은 언어의 작성력에 중요한 요소입니다. 문자열을 배열로 다루는 것은 원시 타입으로 다루는 것보다 더 복잡해질 수 있습니다. 예를 들어, C 언어에서 strcpy를 사용하지 않고 구현한다고 하면 반복문이 반드시 필요합니다. 프로그래밍 언어에서 문자열을 원시 타입으로 추가하는 것은 비용도 거의 들지 않는 일이기 때문에 굉장히 비효율적인 일입니다. 따라서 현대 프로그래밍 언어에서는 대부분 문자열을 원시 타입으로써 제공합니다. 패턴 매칭이나 접합과 같은 연산은 대부분의 프로그램에서 필수적이기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문자열 타입은 하드웨어에서 직접 지원될 수도 있지만, 대부분의 경우에는 소프트웨어로써 구현됩니다. 만약 문자열 타입이 문자 배열로 표현되는 경우에는 언어 자체에서 문자열 관련 연산을 거의 제공하지 않습니다.&lt;/p&gt;

&lt;p&gt;정적 길이 스트링에서 변수의 속성 모음(Descriptor)은 컴파일 과정에서만 요구되며, 변수 이름, 길이, 첫 번째 문자가 저장된 주소입니다. 제한된 동적 길이 스트링에서는 변수 이름, 첫 번째 문자가 저장된 주소, 최대 길이, 현재 길이가 저장되며 실행 시간 속성 모음이 필요합니다. 이 두 방법에서는 동적 기억공간 할당이 필요하지 않습니다. 제한된 동적 길이 스트링도 변수가 기억공간에 바인딩될 때 최대 길이까지 저장할 수 있는 크기만큼 할당되기 때문입니다.&lt;/p&gt;

&lt;p&gt;그러나 동적 길이 스트링의 구현은 다소 복잡합니다. 첫 번째 방법은 연결 리스트에 문자열을 저장하는 것입니다. 만약 문자열의 길이가 늘어난다면 새로 필요한 기억공간은 힙의 무작위 위치에서 생성됩니다. 이 방법은 보다 많은 공간이 필요하고 접근도 느리다는 단점이 있습니다. 두 번째 방법은 문자열 전체를 인접한 기억공간에 저장하는 것입니다. 문제는 동적 길이 스트링은 문자열이 얼마나 늘어날지 예측할 수 없다는 것입니다. 따라서 이 방법에서 문자열의 길이가 늘어난다면, 문자열 전체를 저장할 수 있는 새로운 영역으로 이동합니다. 이 방법은 첫 번째 방법에 비해 접근이 빠르고 저장공간을 비교적 적게 차지하지만, 할당 시간이 느리다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;순서 타입(Ordinal Type)&lt;/span&gt;은 가능한 값의 범위가 양의 정수의 집합과 관련이 있는 타입입니다. Pascal이나 Java에서 제공하는 기본 순서 타입은 Integer, char, boolean 등이 있습니다. 일반적으로 프로그래밍 언어에서 지원하는 사용자 정의 순서 타입은 &lt;strong&gt;열거(Enumeration)&lt;/strong&gt; 타입과 &lt;strong&gt;부분범위(Subrange)&lt;/strong&gt; 타입입니다.&lt;/p&gt;

&lt;p&gt;열거 타입은 기호 상수(Symbolic Constant)인 모든 가능한 값들이 열거되는 타입입니다. 대표적으로 슬라이드에 나온 Ada 언어에서 요일을 저장한 타입이 있습니다. 이러한 열거 타입은 전형적으로 0, 1, … 등의 정수가 할당되지만, 정의에 따라 임의의 정수가 할당될 수도 있습니다. 열거 타입을 설계할 때 고려할 것들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;열거 상수가 한 개 이상의 타입 정의에 나타나는 것이 허용되는가?&lt;/li&gt;
  &lt;li&gt;그렇다면, 프로그램에서 이러한 상수 참조시 그 타입이 어떻게 검사되는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 고려 사항들은 타입 검사와 관련이 있습니다. 만약 열거 변수가 수치 타입으로 강제 변환되면, 연산들의 범위나 값들에 대한 제어가 없습니다. 따라서 이제부터 각각 언어에서 열거 타입을 어떻게 구현하였는지 자세히 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal, C, C++ 언어 같은 경우에 열거 상수는 주어진 참조 환경에서 둘 이상의 열거 타입에 사용될 수 없습니다. 또한 열거형 변수는 배열 첨자, 반복문의 변수, Case 문의 선택기로도 사용할 수 있습니다. 또한 관계 연산자와도 비교할 수 있습니다. 이러한 것들이 가능한 이유는, 열거 변수가 정수 문맥에서 사용될 때 정수형 변수로 강제 변환되기 때문입니다. 그러나 반대로 다른 타입의 값이 열거 타입으로 강제 변환되지는 않습니다.&lt;/p&gt;

&lt;p&gt;Ada 언어 같은 경우에는 동일 환경에서 열거 상수가 두 개 이상의 선언에서 정의될 수 있습니다. 이것을 &lt;span style=&quot;color:red&quot;&gt;중복 리터럴(Overloaded Literal)&lt;/span&gt;이라고 부릅니다. Ada에서는 타입 검사를 위해 열거 변수가 정수형 변수로 강제 변환되지 않습니다. 이는 컴파일 시간에서 문맥 오류를 탐지하는 것을 가능하게 합니다.&lt;/p&gt;

&lt;p&gt;열거 타입을 사용하는 이유는 매우 직접적인 방식으로 가독성을 증가시키기 때문입니다. 이름을 통해 정의된 값은 쉽게 인식되지만, 숫자로 코드화할 경우 쉽게 인식하기 어렵기 때문입니다. 숫자형 데이터 타입과 비교했을 때, 산술 연선이 불가능하고 범위 오류를 쉽게 감지할 수 있다는 장점이 있습니다. 열거형 변수에는 정의된 범위 밖의 값을 할당할 수 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부분 범위 타입은 순서 타입의 연속된 부분 순서열입니다. 예를 들면, Pascal 언어에서 index를 1부터 100까지의 범위를 갖는 변수로 설정했습니다. 이것은 정수의 연속된 부분 순서열이라고 볼 수 있습니다. 부분 범위 타입을 사용하는 이유는 가독성과 안정성이 증가하기 때문입니다. 간단한 타입이기 때문에, 설계할 때 고려사항은 딱히 없습니다. 다만 왜인지 Ada 95 이후로는 대부분의 언어에서 부분 범위 타입을 지원하지 않습니다. (왜 그런지 교재 제작자도 이상하게 생각하더라구요)&lt;/p&gt;

&lt;p&gt;앞서 소개한 대로, 이러한 사용자 정의 순서 타입의 구현은 보통 (음이 아닌) 정수로 구현됩니다. 부분 범위 타입은 범위 검사가 포함되어야 한다는 점만 제외하면 상위 유형(정수형 타입)과 동일한 방식으로 구현됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;배열(Array)&lt;/span&gt;은 동질적인 데이터 원소들의 묶음으로, 개개의 원소는 배열의 첫 번째 원소와 상대적인 위치에서 식별됩니다. 배열의 원소들은 모두 동일한 데이터 타입을 갖고, 배열 원소에 대한 참조는 대괄호와 같은 첨자 식을 이용하여 나타냅니다. 이 때, 참조되고 있는 메모리 위치의 주소를 결정하기 위해 실행 시간 계산이 추가로 필요합니다.&lt;/p&gt;

&lt;p&gt;배열 타입을 설계할 때 고려해야할 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아래 첨자에는 어떤 유형이 적합한가? (정수형, 순서형 등)&lt;/li&gt;
  &lt;li&gt;아래 첨자의 범위는 언제 바인딩되는가? (실행 시간 vs 컴파일 시간)&lt;/li&gt;
  &lt;li&gt;배열 할당은 언제 발생하는가? (실행 시간 vs 컴파일 시간)&lt;/li&gt;
  &lt;li&gt;아래 첨자는 몇 개나 허용되는가? (가능한 차원의 수)&lt;/li&gt;
  &lt;li&gt;공간이 할당될 때 배열이 초기화되는가?&lt;/li&gt;
  &lt;li&gt;어떤 종류의 슬라이스가 존재하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 페이지부터 이러한 고려 사항을 하나씩 따져보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열의 원소들은 두 단계의 구문 메커니즘에 의해 참조됩니다. 첫 번째는 배열의 이름이고, 두 번째는 첨자나 색인입니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a[100]&lt;/code&gt;과 같이 참조할 때, a가 배열의 이름이고, 100이 첨자입니다. 선택 연산은 배열 이름과 첨자로부터 하나의 원소로 매핑하는 것으로 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;배열에서 첨자를 표시할 때 소괄호를 이용하는 경우도 있고 대괄호를 이용하는 경우도 있습니다. Fortran과 PL/I이 개발되었을 당시에는 첨자를 나타낼 적절한 문자가 없었기 때문에 소괄호를 선택하였습니다. 그러나 소괄호를 사용하는 경우에는 함수에서 인자를 호출하는 것과 혼동될 여지가 있었기 때문에, 90년대 이후로는 대괄호를 이용하여 첨자를 표시하게 됩니다.&lt;/p&gt;

&lt;p&gt;배열의 첨자 타입은 일반적으로 정적으로 바인딩됩니다. 먼저 첨자 범위의 하한은 C 계열 언어에서 0으로 정의되며, Fortran 1, 2, 4에서는 1로 고정됩니다. Fortran 77과 90에서도 기본적으로 1로 설정되어 있지만, 임의의 정수로 설정할 수 있습니다. 이 범위가 프로그래머로부터 명시적으로 선언되어야 하는 언어도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열 첨자의 범위에 대한 바인딩과 저장공간에 대한 바인딩을 토대로 다음과 같이 네 가지 종류로 나눌 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;정적 배열(Static Array)&lt;/strong&gt; : 첨자의 범위와 기억공간 할당이 모두 정적으로 바인딩되는 배열입니다. 따라서 실행 시간 전에 바인딩이 끝나며, 동적 할당이나 회수가 이루어지지 않기 때문에 매우 효율적이라는 장점이 있습니다. Fortran 77의 배열이 이 방법을 채택하고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고정 스택 동적 배열(Fixed Stack Dynamic Array)&lt;/strong&gt; : 첨자의 범위는 정적으로 바인딩되지만, 기억공간 할당이 실행 시간 중에 발생하는 배열입니다. 두 개의 부프로그램이 있고, 각각 고정 스택 동적 배열을 갖고 있다면 동시에 실행되지 않는 한 그 배열들은 기억공간을 공유하기 때문에 기억공간을 효율적으로 사용할 수 있다는 장점이 있습니다. 대신 할당과 회수 시간이 별도로 소모되는 단점도 있습니다. Pascal의 지역 배열이 이 방법을 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스택 동적 배열(Stack Dynamic Array)&lt;/strong&gt; : 첨자의 범위와 기억공간의 바인딩이 모두 실행 시간 중에 동적으로 바인딩되는 배열입니다. 그러나 일단 첨자 범위가 바인딩되고 기억공간이 할당되면 변수의 수명 동안 고정됩니다. 이 방법은 배열이 사용되기 전까지 미리 선언할 필요가 없기 때문에 유연성이 높다는 장점이 있습니다. C 언어가 대표적으로 이 방법을 사용하고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;힙 동적 배열(Heap Dynamic Array)&lt;/strong&gt; : 첨자의 범위와 기억공간의 바인딩이 모두 동적이며, 배열의 수명 동안 변경이 가능한 배열입니다. 스택 동적 배열보다 더 유연하다는 장점이 있습니다만, 힙으로부터 할당과 해제가 일어나기 때문에 더 느리다는 단점이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여담으로 다양한 데이터 타입을 저장할 수 있는 배열도 있습니다. 이러한 배열을 &lt;span style=&quot;color:red&quot;&gt;이기종 배열(Heterogeneous Array)&lt;/span&gt;이라고 부르는데, 배열의 원소가 동일한 데이터 타입일 필요가 없는 배열입니다. Perl, Python, JavaScript, Ruby 등에서 지원되며, 이 배열은 그 특성상 힙 동적 배열로 정의됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 다룰 내용은 배열의 첨자 수에 관한 설계입니다. 프로그래밍 언어의 역사에서 다루었듯이, Fortran I의 경우에는 첨자를 3개까지만 허용했습니다. 즉, 3차원 배열까지만 생성이 가능했다는 것입니다. 이후 Fortran 77과 90에서는 최대 7개를 지원했고, 그 이후 등장한 언어들에서는 무제한 차원의 배열이 가능했습니다.&lt;/p&gt;

&lt;p&gt;의외로 C 언어는 1개의 첨자만 사용할 수 있습니다. 그러나 배열 자체가 배열의 원소가 될 수 있으므로, 다차원 배열의 생성이 가능한 것입니다. 이와 같은 방식을 &lt;span style=&quot;color:red&quot;&gt;직교 설계(Orthogonal design)&lt;/span&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;몇몇 언어는 배열이 기억공간에 할당되는 시점에 배열을 초기화하는 방법을 제공합니다. 예를 들어, Fortran 77에서는 모든 데이터가 정적으로 할당되므로 DATA 문을 사용한 로드 시간 초기화가 허용됩니다.&lt;/p&gt;

&lt;p&gt;C 언어 또한 정적 배열을 이용한 초기화가 가능합니다. 그러나 동적 배열은 이런식으로 초기화가 불가능합니다.&lt;/p&gt;

&lt;p&gt;Pascal이나 Modular-2와 같은 언어에서는 프로그램 선언에서 배열 초기화를 허용하지 않습니다.&lt;/p&gt;

&lt;p&gt;Ada 언어는 두 가지 방법으로 배열 초기화가 가능합니다. 값을 저장하는 순서대로 나열하는 방법과 =&amp;gt; 연산자를 사용하여 값들을 색인 위치에 직접 할당하는 방법입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;배열 연산(Array Operations)&lt;/span&gt;은 배열 단위로 연산을 수행하는 것을 말합니다. 예를 들어, 배정, 접합, 비교, 슬라이스 등이 있습니다. 이 중 슬라이스는 다음 장에서 따로 논의하도록 하고, 여기에서는 나머지 케이스만을 다루겠습니다.&lt;/p&gt;

&lt;p&gt;Fortran 90에서는 elemental 이라고 부르는 배열 연산을 제공합니다. 제공하는 연산들이 배열 원소들의 쌍(Pair) 연산이기 때문에 그렇게 이름이 붙었다고 합니다. 대표적으로 + 연산은 두 배열의 원소 쌍들의 합을 계산한 배열입니다. 이 외에도 할당, 산술, 관계 및 논리 연산자는 모든 크기의 배열에 대해 오버로딩되어 있습니다.&lt;/p&gt;

&lt;p&gt;APL은 가장 강력한 배열 연산을 지원하는 언어입니다. +, -, *, / 4가지 기본 산술 연산은 물론, 벡터, 행렬, 스칼라 피연산자에 대해서도 정의되어 있습니다. 내적, 외적 연산까지 지원합니다.&lt;/p&gt;

&lt;p&gt;C 언어는 기본적으로 배열 연산을 지원하지 않습니다. Java나 C++ 언어는 메소드를 통해 일부만 지원하며, Python은 배열 접합이나 비교, 원소 추가와 관련된 일부 연산을 지원합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열의 &lt;span style=&quot;color:red&quot;&gt;슬라이스(Slice)&lt;/span&gt;는 배열의 부분 구조입니다. 예를 들어, Fortran 90 언어에서 MAT(1:3, 2)는 1행부터 3행까지 2번째 열을 잘라서 만든 부분 배열이고, MAT(2:3, 1:3)은 2행부터 3행까지에서 1열부터 3열까지 자른 부분 배열입니다.&lt;/p&gt;

&lt;p&gt;Python 언어는 더 복잡한 슬라이스를 지원합니다. 예를 들어, vector[0:7:2]는 배열의 0부터 7까지 슬라이스하는데, 2 단위로 원소들을 슬라이스하는 명령어입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열을 구현하는 것은 원시 타입을 구현하는 것보다 훨씬 더 많은 노력이 필요합니다. 왜냐하면 효율적인 실행 시간 접근을 위해서는 배열에 대한 접근 방법이 컴파일 시간에 만들어져야 하기 때문입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, list[k]의 주소를 계산한다고 가정해봅시다. 1차원 배열은 각각의 원소가 인접한 메모리로 바인딩되기 때문에 (배열 list의 시작 첨자가 1이라면) list[k]의 주소 = list[1]의 주소 + (k - 1) * 원소의 크기 로 계산할 수 있을 것입니다. 원소의 타입이 정적으로 바인딩되고, 배열이 기억공간에 정적으로 바인딩되면 이 식은 실행 시간 전에 계산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 식을 컴파일 시간 내에 계산하기 위해서는 1차원 배열에 대한 속성이 그림과 같은 구조로 설정되어야 합니다. 만약 이러한 항목들이 동적으로 바인딩된다면, 배열의 주소는 실행 시간에 계산할 수밖에 없습니다.&lt;/p&gt;

&lt;p&gt;다차원 배열은 1차원 배열보다 구현하기 복잡합니다. 하드웨어 메모리는 일반적으로 선형으로 구성되어 있기 때문에, 다차원 배열을 1차원 배열로 매핑해야만 합니다. 이 때, 1차원 배열로 매핑하는 방법은 &lt;span style=&quot;color:red&quot;&gt;행 우선 순서(Row Major Order)&lt;/span&gt;와 &lt;span style=&quot;color:red&quot;&gt;열 우선 순서(Column Major Order)&lt;/span&gt;로 나눌 수 있습니다. 행 우선 순서는 1행의 내용을 저장 - 2행의 내용을 저장 - 3행의 내용을 저장 - … 순서대로 저장하는 방식이고, 열 우선 순서는 1열의 내용을 저장 - 2열의 내용을 저장 - 3열의 내용을 저장 - … 순서대로 저장하는 방식입니다. 대부분의 명령형 언어에서는 행 우선 순서대로 저장을 하며, Fortran과 같은 일부 언어에서만 열 우선 저장을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다차원 배열에서 &lt;span style=&quot;color:red&quot;&gt;접근 함수(Access Function)&lt;/span&gt;는 기반 주소와 참조 값들의 집합을 메모리 주소로 매핑하는 함수입니다. 예를 들어, 행 우선 순서로 2차원 배열에 대한 접근 함수를 구해보겠습니다. 시작 주소가 a[1,1]로 주어진 상황에서, 임의의 배열 원소인 a[i,j]의 주소를 계산한다면 a[1,1]의 주소 + ((i-1)*n +(j-1)) * 원소의 크기로 계산할 수 있습니다. 이 식에서 i와 j 부분은 그 값에 따라 달리지기 때문에, 상수와 변수 부분을 구분해서 정리하면 a[1,1]의 주소 - (n+1) * 원소의 크기 + (i * n + j) * 원소의 크기로 바꿔쓸 수 있습니다. 이를 반영하여, 다차원 배열에서 컴파일 시간에 계산할 수 있는 속성은 위 슬라이드의 마지막 그림과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 슬라이드는 3차원 배열에서 특정 배열 원소의 주소를 행 우선 순서/열 우선 순서로 계산하는 것을 나타낸 슬라이드입니다. 계산 방법은 쉽게 설명되어 있으니 한번 읽고 넘어가시면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;연상 배열(Associative Array)&lt;/span&gt;은 &lt;strong&gt;키(Key)&lt;/strong&gt;라고 불리는 원소의 개수와 동일한 개수의 값들로 참조되는 정렬되지 않은 배열을 말합니다. 일반적인 배열에서 색인 값은 전혀 정의할 필요가 없지만, 연상 배열에서는 색인 값도 키와 함께 정의되어야 합니다. 따라서 연상 배열의 실제 원소는 키와 값의 쌍으로 이루어져 있습니다. Perl, Python, Ruby 등의 언어에서는 연상 배열을 기본적으로 지원하며, Java나 C++ 언어에서는 표준 클래스 라이브러리로써 지원합니다. (ex. HashMap)&lt;/p&gt;

&lt;p&gt;Perl 언어에서 연상 배열은 &lt;strong&gt;해쉬(Hash)&lt;/strong&gt;라는 이름으로 지원됩니다. 모든 해쉬 변수는 % 기호로 시작해야 하며, =&amp;gt; 연산자 를 이용해 키와 값을 배정합니다. Python 언어에서는 &lt;strong&gt;사전(Dictionary)&lt;/strong&gt; 자료형을 통해 연상 배열을 지원합니다.&lt;/p&gt;

&lt;p&gt;해쉬의 장점은 원소에 접근할 때 일반적인 배열보다 매우 효율적이라는 것입니다. 왜냐하면 원소에 접근할 때 사용하는 해쉬 연산이 배열보다 효율적이기 때문입니다. 따라서 만약 취급할 데이터가 이름과 급료와 같이 쌍으로 구성되어 있다면 해쉬를 사용하는 것이 좋습니다. 그러나 리스트의 모든 원소를 처리해야하는 경우에는 배열을 사용하는것이 더 낫습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;레코드(Record)&lt;/span&gt;는 각각의 원소들이 이름으로 식별되고 다양한 데이터 타입을 가질 수 있는 자료형입니다. 이러한 자료형은 1960년대 초 COBOL에서 처음 도입된 이후 가장 인기있었던 프로그래밍 언어의 요소였습니다. 배열과 비교해보자면, 배열은 색인을 통해 원소에 접근하고 모든 원소가 동일한 데이터 타입을 갖지만, 레코드는 식별자로 원소에 접근하고 원소가 다양한 데이터 타입을 가질 수 있다는 차이점이 있습니다. 예를 들면, 학생의 정보를 저장할 때 이름은 문자열, 학번은 정수, 학점은 실수로 저장해 만드는 자료형이라고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;레코드의 구조는 언어마다 조금씩 다르게 지원합니다. 최초로 레코드를 지원했던 COBOL을 예로 들면, EMPLOYEE-RECORD 레코드는 EMPLOYEE-NAME과 HOURLY-RATE로 구성되어 있습니다. 앞의 01, 02, 05는 수준 번호로써 레코드의 계층 구조를 나타내며, PICTURE는 기억공간 형식을 나타냅니다. X(20)은 최대 20개의 글자로 이루어진 자료형을 나타내며, 99V99는 중간에 소수점을 갖는 4개의 십진수 숫자라는 의미입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어는 COBOL과는 다르게 계층 번호를 사용하지 않고 레코드 내부에 레코드를 또 선언함으로써 나타냅니다. 그리고 모든 Ada의 레코드 타입은 이름을 갖는 타입이어야만 합니다.&lt;/p&gt;

&lt;p&gt;Fortran과 C 언어에서 중첩 레코드를 사용할 경우, 중첩된 레코드를 먼저 선언하고 상위 레코드에서 하위 레코드를 참조하는 형식으로 정의합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;레코드 필드를 참조하는 방법도 여러 가지가 있습니다. 먼저 COBOL 언어는 OF 라는 명령어를 사용하여 참조합니다. 예를 들어, 이전 슬라이드에 나와있던 COBOL 레코드에서 MIDDLE 이라는 필드를 참조하려면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIDDLE OF EMPLOYEE-NAME OF EMPLOYEE-RECORD&lt;/code&gt; 와 같이 작성하면 됩니다. 이 외의 다른 언어들에서는 대부분 EMPLOYEE_RECORD.EMPLOYEE_NAME.MIDDLE과 같이 .(마침표)를 이용해서 표현합니다. 이렇게 마침표를 이용해 표시하는 방법을 &lt;strong&gt;도트 표기법(Dot Notation)&lt;/strong&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;레코드 필드를 참조할 때 두 가지 형식이 있는데, 레코드 필드까지 모든 중간 레코드의 이름이 포함되어야 하는 &lt;span style=&quot;color:red&quot;&gt;완전 자격 참조(Fully Qualified Reference)&lt;/span&gt;와, 참조 환경이 명확하다면 레코드 이름의 일부나 전체를 생략할 수 있는 &lt;span style=&quot;color:red&quot;&gt;생략 참조(Elliptical Reference)&lt;/span&gt; 형식이 있습니다. COBOL의 레코드는 생략 참조를 허용함으로써 프로그래머의 편리성을 고려하였지만, 생략 참조는 가독성에 문제가 생길 수 있기 때문에 일반적으로 완전 자격 참조 방식을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal이나 Modular-2 언어 같은 경우에는 레코드를 할당하는 것이 가능합니다. Ada 언어 또한 레코드의 할당과 동일성의 비교를 지원합니다. COBOL 언어 같은 경우에는 MOVE CORRESPONDING 명령어를 통해 대상 레코드에 동일한 이름이 필드가 있을 경우 원본 레코드의 필드를 복사하는 기능을 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;레코드 필드도 배열과 마찬가지로 인접한 메모리에 저장됩니다. 그러나 배열과는 다르게 필드의 크기가 반드시 같지는 않기 때문에 배열과는 다른 접근 방식을 사용합니다. 이러한 문제는 레코드의 시작 주소에 상대적인 오프셋 주소를 필드에 포함시킴으로써 해결합니다. 아래 그림은 컴파일 시간 속성의 형식을 나타내고 있습니다.&lt;/p&gt;

&lt;p&gt;또한 레코드의 경우 필드별 크기가 상이하기 때문에 컴퓨터 메모리의 효율적인 접근을 위한 &lt;strong&gt;워드 정렬(Word Alignment)&lt;/strong&gt;이라는 기법을 사용합니다. 예를 들어 오른쪽과 같은 구조체 코드가 있습니다. 이 경우 문자형 변수 c는 1바이트, 정수형 변수 i는 4바이트를 차지합니다. 원래라면 구조체 aa는 이 둘을 합친 5바이트를 차지해야하지만, 32비트 컴퓨터의 경우 4바이트(=32비트) 단위로 명령어를 처리하기 때문에 5바이트씩 처리하게 되면 비효율적인 접근이 발생합니다. 따라서 이 경우에는 컴퓨터가 한번에 가져올 수 있는 데이터의 크기에 맞추기 위해, 일부러 쓰지않는 3바이트를 더 배정해서 8바이트로 만드는 것이 접근에 유리합니다. 이런 용도로 추가하는 비트를 &lt;strong&gt;패딩(Padding)&lt;/strong&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;공용체(Union)&lt;/span&gt;는 변수가 프로그램 실행 중에 다른 시간이라면 다른 타입의 값을 저장할 수 있는 타입을 말합니다. 예를 들면, 컴파일러를 위한 상수들의 테이블이 있습니다. 이 테이블은 컴파일 중인 프로그램에서 발견된 상수들을 저장하는데 사용되는데, 프로그램에 사용되는 상수들은 데이터 타입이 다양합니다. 그런데 이 테이블에 저장된 값은 동일한 테이블 필드에 저장되므로, 발견되는 데이터 타입 중 가장 큰 타입을 기준으로 기억공간이 할당됩니다. 즉, 데이터 타입의 합집합(Union)이라고 볼 수 있으므로 이러한 이름이 붙었습니다.&lt;/p&gt;

&lt;p&gt;공용체의 주요한 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타입 검사가 요구되어야 하는가? (만약 타입 검사가 요구된다면 반드시 동적으로 구현되어야 한다)&lt;/li&gt;
  &lt;li&gt;공용체가 레코드에 포함되어야 하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 설계 고려 사항을 참고하여 공용체가 구현된 언어를 간략하게 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 Fortran 언어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EQUIVALENCE&lt;/code&gt;라는 구문으로 공용체를 선언합니다. Fortran에서는 공용체의 타입 검사를 실시하지 않습니다. ALGOL 68 언어는 Fortran과 다르게 타입 검사를 요구합니다. 이 때, 공용체가 현재 갖고 있는 타입을 나타내기 위해 &lt;strong&gt;태그(Tag)&lt;/strong&gt; 나 &lt;strong&gt;판별자(Discriminant)&lt;/strong&gt;를 표기하는데, 이러한 것을 포함하는 공용체를 &lt;span style=&quot;color:red&quot;&gt;판별 공용체(Discriminated Union)&lt;/span&gt;라고 부릅니다. 판별 공용체는 실행 시간에서 타입을 검사합니다.&lt;/p&gt;

&lt;p&gt;ALGOL 68은 판별 공용체를 &lt;span style=&quot;color:red&quot;&gt;적합성 문장(Conformity Clause)&lt;/span&gt;으로 구현하였습니다. 이것은 실행 시간에 변수가 어떤 타입을 갖고 있는지 테스트하여 각 경우의 수 별로 다르게 처리하는 방법입니다. 오른쪽의 코드를 보시면 ir1은 정수형, 실수형 변수가 저장될 수 있는 공용체로 정의되어 있습니다. 아래의 case 문에서는 ir1이 정수일 때와 실수일 때로 나누어서 문구를 처리합니다. 이러한 방식으로 공용체의 타입을 관리하는 것이 적합성 문장입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/32.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal 언어는 판별 공용체와 레코드 구조를 결합하여 &lt;span style=&quot;color:red&quot;&gt;변종 레코드(Variant Record)&lt;/span&gt;로 구현하였습니다. 이것은 판별 공용체를 갖고 있는 레코드 구조 타입입니다. Pascal 언어의 판별자는 현재 타입의 값이 저장된 레코드에서 사용자가 접근할 수 있는 변수입니다. 코드 예시를 보면 case 문에 form이라는 이름이 있는데, 이것이 바로 판별자입니다. 레코드에 circle, triangle, rectangle 이 저장될 수 있는데, 이 중 하나를 선택하는 의미입니다.&lt;/p&gt;

&lt;p&gt;공용체는 결국 프로그램의 신뢰성을 떨어트리기 때문에 최근에는 지향하지 않는 타입입니다. 기본적으로 메모리를 공유하기 때문에, 공용체 내의 변수의 값을 변경하면 다른 변수의 값도 변형됩니다. 또한 C, C++ 언어와 같이 타입 검사를 하지 않는 자유 공용체를 사용하는 경우 강 타입 언어로부터 멀어지게 됩니다. 타입 검사를 하더라도 그것이 매우 어렵기 때문에 Java나 C#과 같은 최근 언어에서는 공용체를 지원하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/33.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;공용체는 포함된 모든 가능한 변수를 같은 주소에 배정하는 것으로 간단하게 구현할 수 있습니다. 당연히 공용체에서 가장 큰 크기를 차지하는 변수만큼 기억공간이 할당됩니다. 예제로 나온 Ada 코드와 같이 공용체가 주어진 경우, 컴파일 시간 내에 이것을 저장하기 위한 배치는 다음과 같을 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공용체의 시작 주소&lt;/li&gt;
  &lt;li&gt;판별체(=TAG)&lt;/li&gt;
  &lt;li&gt;필드 접근을 위한 오프셋(=상대 주소)&lt;/li&gt;
  &lt;li&gt;TRUE - COUNT (INTEGER), FALSE - SUM (CHARACTER)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/34.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;집합(Set)&lt;/span&gt; 타입은 기본 타입의 고유한 값을 정렬되지 않은 모음으로 저장할 수 있는 타입입니다. 집합 타입의 설계 고려 사항은 최대 원소의 개수를 몇 개로 정할 것이냐입니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어를 예로 들면, 집합의 최대 원소 수는 구현에 따라 다르지만, 일반적으로 100개 이하입니다. 집합과 그 원소에 대한 연산은 단일 Word 크기에 맞는 비트 문자열로 표현함으로써 가장 효율적으로 구현할 수 있습니다. 예를 들어, {red, blue, green} 집합의 부분 집합인 {red, green}을 2진수 101로 표현하는 것입니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어에서 집합 연산은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;’:=’&lt;/strong&gt; : 집합 타입의 적절한 배정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’+’&lt;/strong&gt; : 합집합&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;‘*‘&lt;/strong&gt; : 교집합&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’-‘&lt;/strong&gt; : 차집합&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’=’&lt;/strong&gt; : 동일한 집합인가 판단&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;집합을 배열과 비교해보면, 집합의 연산은 배열의 연산보다 효율적이라는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/35.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전 슬라이드에서 말씀드렸듯이 집합은 일반적으로 비트 스트링 형태로 메모리에 저장합니다. 따라서 집합의 연산의 대부분은 간단한 논리 연산으로 해결이 가능하므로 효율적입니다. 예를 들어, 합집합 연산은 논리 OR, 원소의 포함 여부는 논리 AND 연산으로 간단하게 계산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/36.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;포인터(Pointer)&lt;/span&gt; 타입은 변수가 메모리 주소와 특수 값 nil로 구성되는 값들의 범위를 갖습니다. nil은 유효한 주소가 아니며, 포인터가 메모리 셀을 현재 참조할 수 없음을 나타냅니다. 포인터는 간접 주소 지정과 동적 할당 관리 용도로 주로 사용됩니다. 포인터는 일반적으로 타입 연산자(C언어에서의 *)를 사용하여 정의됩니다. 그러나 배열이나 레코드와는 다르게 실제 데이터를 저장하기 위해서 사용하기보다는, 다른 변수를 참조하기 위해서 사용합니다. 이렇게 다른 변수를 참조하기 위해서 사용하는 변수를 &lt;strong&gt;참조 타입(Reference Type)&lt;/strong&gt;이라고도 부릅니다. 반대로 실제 데이터를 저장하는 변수는 &lt;strong&gt;값 타입(Value Type)&lt;/strong&gt;이라고도 부릅니다.&lt;/p&gt;

&lt;p&gt;포인터의 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포인터 변수의 영역(Scope)과 수명(Lifetime)은 어떻게 되는가?&lt;/li&gt;
  &lt;li&gt;포인터가 참조하는 동적 변수의 수명은 어떻게 되는가?&lt;/li&gt;
  &lt;li&gt;포인터가 가리킬 수 있는 값의 타입이 제한되는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포인터는 기본적으로 &lt;strong&gt;배정&lt;/strong&gt;과 &lt;strong&gt;역참조&lt;/strong&gt; 두 가지 연산을 제공합니다. 배정은 포인터 변수의 값을 다른 주소로 설정하는 것이고, 역참조는 포인터 변수에 바인딩된 메모리 셀이 가리키는 값에 대한 참조를 말합니다. 예를 들어, 예제 코드에서 aa는 포인터 타입으로 정의되어 있습니다. 다음 줄에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aa = &amp;amp;bb&lt;/code&gt;는 aa에 bb의 주소를 배정함으로써 포인터 변수 aa가 bb의 메모리 셀을 가리키게 만드는 연산입니다. 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc = *aa&lt;/code&gt;를 통해 변수 cc에 aa가 가리키는 메모리 셀의 값, 즉 55를 저장하게 만드는 역참조 연산입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/37.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;포인터라는 개념을 처음 도입한 언어는 PL/I이었습니다. 포인터의 개념이 도입되고 나서 프로그램의 유연성이 매우 높아졌지만, 덩달아 여러 가지 유형의 프로그래밍 오류가 초래되었습니다. 따라서 Java와 같은 최근의 언어에서는 포인터를 사용하지 않고 참조 타입으로 대체하였습니다. 여기서는 포인터로 발생할 수 있는 여러 가지 문제를 짚고 넘어가보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 포인터 변수에 대한 &lt;strong&gt;타입 검사(Type Checking)&lt;/strong&gt; 문제입니다. 포인터가 가리킬 수 있는 개체 유형을 도메인 타입이라고 합니다. PL/I의 포인터는 단일 도메인 타입으로 제한되지 않았기 때문에 포인터에 대한 타입 검사가 어려웠습니다. C/C++ 언어에서는 정수 변수를 가리키는 포인터 변수는 정수 포인터, 실수 변수를 가리키는 포인터 변수는 실수 포인터와 같이 가리키는 데이터 타입에 따라 포인터 변수의 타입이 고정되어 있기 때문에 이 문제를 약간이나마 해결했습니다.&lt;/p&gt;

&lt;p&gt;다음으로는 &lt;strong&gt;허상 포인터(Dangling Pointer)&lt;/strong&gt; 문제입니다. 이 문제는 C 언어를 배울 때도 다루는 문제입니다. 허상 포인터는 이미 회수된 변수의 주소를 가리키는 포인터를 말합니다. 허상 포인터의 문제는 가리키고 있는 기억장소의 위치에 다른 변수가 할당될 수도 있기 때문에 위험합니다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;strong&gt;분실된 객체(Lost Object)&lt;/strong&gt; 문제입니다. 이것은 허상 포인터와 반대로, 기억공간에는 여전히 데이터가 저장되어 있지만, 사용자 프로그램에서 더이상 접근할 수 없게된 객체입니다. 이러한 변수를 흔히 쓰레기(Garbage)라고도 부릅니다. 왜냐면 더 이상 원래의 목적대로 사용할 수도 없고, 그렇다고 다른 용도로 재사용할 수도 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;위 슬라이드의 마지막 부분에서는 허상 포인터와 분실된 객체가 발생할 수 있는 코드 예시를 나타내고 있습니다. 왼쪽의 예제에서는 포인터 전역 변수인 i가 정의되어 있습니다. 그런데 부프로그램 sub1()에서 지역변수인 j가 새로 선언되어있습니다. sub1()에서 포인터 변수 i가 j를 가리키게 배정되었습니다. 그런데 변수 j는 부프로그램 sub1()의 지역변수이기 때문에, sub1()이 종료되면 수명이 끝납니다. 따라서 sub1()이 호출된 이후 *i는 이미 회수된 변수의 주소를 가리키게 됩니다.&lt;/p&gt;

&lt;p&gt;오른쪽 코드에서는 포인터 문자 변수 c가 정의되어 있습니다. 두 번째 줄에서 동적 할당을 통해 c에 새로운 기억공간이 할당됩니다. 그런데 이를 해제하지 않고, 나중에 또 c에 새로운 기억공간을 할당합니다. 이렇게 되면 첫 번째 할당한 기억공간은 프로그램 내에서 더이상 접근할 수 없습니다. 따라서 이 때 분실된 객체 문제가 발생하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/38.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal 언어에서 포인터는 동적으로 할당된 변수에 접근하는데만 사용됩니다. 동적 할당에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; 명령어를 사용하고, 해제할때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispoose&lt;/code&gt; 명령어를 사용합니다. dispose 명령어는 허상 포인터 문제가 거의 항상 발생했기 때문에, dispose 명령어가 나오면 이걸 무시하는 경우도 많았습니다. 이것은 허상 포인터 문제를 발생하지 않게 하지만, 프로그램이 더 이상 필요로 하지 않는 힙의 재사용을 불가능하게 만드는 단점이 있습니다. 이것은 초기 Pascal 언어가 산업용 보다는 교육용 언어로 설계되었기 때문에 발생하는 문제입니다.&lt;/p&gt;

&lt;p&gt;포인터는 어쩌면 goto문과 비슷한데, goto문이 문장의 제어 범위를 확대시키는 것처럼 포인터는 변수가 참조할 수 있는 메모리 셀의 범위를 확대시킵니다. goto문이 프로그래밍 언어 설계자들에게 비난을 받는 것처럼 포인터도 이와 같은 비난을 받는데요, 오른쪽에 포인터에 대한 악담이 실려있는데, 이 내용이 재미있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“고급 언어에서 포인터의 도입은 우리가 결코 회복할 수 없는 후퇴였습니다”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마치 우한 폐렴 때 질병관리청에서 그 전으로는 절 때 돌아갈 수 없다고 말한 것과 비슷한 느낌이네요.&lt;/p&gt;

&lt;p&gt;C 언어에서 포인터는 어셈블리 언어에서 주소를 사용하는 것처럼 사용할 수 있는데요, 이러한 설계는 허상 포인터나 분실된 객체 문제에 대해 어떤 해결책도 없다는 단점이 있습니다. 그러나 그 대신 C 언어에서는 포인터의 산술 연산이 가능하다는 특징이 있습니다. 기본적으로 ‘*’ 연산은 포인터의 역참조 연산, ‘&amp;amp;’ 연산은 변수의 주소를 생성합니다. 이 외에도 포인터 변수와 일반 변수의 산술 연산이 가능한데, 예를 들어 ptr + index 라는 연산이 있습니다. 이 것은 ptr에 index 값을 단순히 더하는 것이 아니라, 먼저 ptr이 가리키고 있는 메모리 셀의 크기 단위로 index의 값이 조절됩니다. 만약 ptr의 크기가 4인 메모리 셀을 가리키면, index에 먼저 4를 곱한 다음 ptr에 더하는 방식입니다. 이렇게 설정된 목적은 포인터 연산으로 배열을 표현하기 위해서입니다. 예를 들어, 포인터 변수 ptr에 1차원 배열이 할당되었다고 하면, *(ptr + 1)은 ptr[1]과 동일한 의미입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/39.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;참조 타입(Reference Type)&lt;/span&gt;은 포인터와 유사하지만, 포인터가 메모리의 주소를 참조하는 것과 달리 참조 타입은 메모리의 객체나 값을 참조합니다. 따라서 포인터는 주소값을 다루기 때문에 산술 연산이 가능하지만, 참조 타입은 그렇지 않다는 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;대표적인 참조 타입은 C++ 언어에서 구현되어 있습니다. C++ 언어의 참조 타입은 항상 암시적으로 역참조되는 상수 포인터로 구현되어 있는데, 상수이기 때문에 정의할 때 어떤 변수에 주소값으로 초기화되어야 합니다. 물론 초기화된 후에는 다른 변수를 참조하도록 설정할 수 없습니다. 일반적으로 C++ 언어에서 참조 타입은 함수에서 호출 함수와 피호출 함수간의 양방향 통신에 사용됩니다. 이러한 예제는 다음을 참고해주시기 바랍니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void sub1(int&amp;amp; num){
  num = 10;
}
int n = 0;
sub1(n);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같이 함수 매개변수를 참조 타입으로 설정하면, n을 포인터로 넘기지 않아도 n의 값을 0에서 10으로 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/40.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;대부분의 대형 컴퓨터에서 포인터는 2바이트 또는 4바이트 메모리 셀(워드 크기)에 저장된 단일 값으로 저장됩니다. 그런데 포인터를 구현할 때는 포인터를 저장하는 것 자체보다는 포인터로 인해 발생하는 허상 포인터 문제를 고려하는 것이 더 중요합니다.&lt;/p&gt;

&lt;p&gt;첫 번째 방법은 &lt;span style=&quot;color:red&quot;&gt;비석 접근 방법(Tombstone Approach)&lt;/span&gt;입니다. 이것은 모든 동적 변수에 비석이라는 특수한 셀을 포함시키는 것입니다. 실제 사용하는 포인터 변수는 이 비석을 가리키게 하고, 비석이 동적 변수를 가리키게 만드는 구조입니다. 만약 동적 변수가 기억장소에서 해제된다면, 비석은 그대로 남지만 nil을 가리키도록 설정됩니다. 즉, 비석을 통해 포인터가 회수된 기억공간을 계속 가리키는 것을 방지하는 방법입니다.&lt;/p&gt;

&lt;p&gt;아이디어만 들어도 이 방법의 문제점이 자연스럽게 떠오릅니다. 먼저, 동적 변수가 해제될 때도 비석은 해제되지 않기 때문에 그 만큼의 기억공간이 낭비됩니다. 게다가, 포인터 변수가 기억공간을 직접 가리키지 않고 비석을 통해 간접적으로 가리키기 때문에 그만큼의 접근 시간이 추가로 소모됩니다. 일반적으로는 이 정도의 시간적/공간적 비용을 감당하면서까지 신뢰성을 확보할 필요가 없기 때문에, 이 방법을 사용하는 언어는 거의 없습니다. 버전 9 이하의 매킨토시나 C++ 언어의 일부 라이브러리(std::weak_ptr)만 이 방법을 사용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/41.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;허상 포인터를 해결하는 두 번째 아이디어는 &lt;span style=&quot;color:red&quot;&gt;잠금과 키 접근 방법(Locks-and-key Approach)&lt;/span&gt;입니다. 이 방법은 동적 변수를 (변수, 잠금값)의 순서쌍으로 나타내고, 동적 변수를 가리키는 포인터는 (키, 주소)의 순서쌍으로 나타냅니다. 동적 변수가 할당되면 잠금값이 생성되어 포인터 변수의 키 값과 동적 변수의 잠금값에 이 값이 저장됩니다. 포인터가 역참조될 때는 포인터의 키 값과 동적 변수의 잠금값과 비교함으로써 그 접금이 일치하는지, 아닌지 확인합니다. 만약 포인터가 복사된다면 잠금값도 같이 복사되어야 하고, 해제될 때는 잠금값도 해제되어야 합니다.&lt;/p&gt;

&lt;p&gt;사실 이러한 방법들 보다는 그냥 프로그래머 직접 매번 동적 변수를 해제해주는 것이 좋습니다. 프로그램 내에서 모든 동적 변수가 명시적으로 해제된다면 허상 포인터 문제는 발생하지 않기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/42.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 힙 메모리 관리에 대해 알아보도록 하겠습니다. 힙 메모리 관리는 매우 복잡한 실행 시간 프로세스로, 여기서는 모든 힙이 동일한 크기로 할당/회수되는 시나리오와 가변 크기로 할당/회수되는 시나리오, 두 가지 상황으로 나누어 고려해보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 동일한 크기에 대해 회수에 대해 먼저 논의하자면, 기억공간 회수를 통해 사용가능한 셀을 묶어 가용 공간 리스트를 만들 수 있습니다. 할당은 필요할 때 이 리스트로부터 요구된 셀의 개수를 가져오는 것입니다. 할당보다 회수가 더 어려운 문제인데, 동적 변수는 2개 이상의 포인터로 가리켜질 수 있으므로 그 변수가 언제 프로그램에서 더 이상 사용되지 않는지 판단하는 것이 어렵기 때문입니다. 예를 들어, 동적 변수를 가리키던 포인터가 없어진다고 해서 그 동적 변수가 쓰이지 않는다고 보장할 수 없습니다. 다른 포인터가 그 동적 변수를 가리키고 있을 수도 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;LISP 언어에서는 회수하는 방법에 따라 두 가지 방법으로 나눌 수 있는데, 순차적으로 회수하는 &lt;strong&gt;참조 계수기 접근 방법(Reference Counter)&lt;/strong&gt;과 &lt;strong&gt;쓰레기 수집 접근 방법(Grabage Collection Approach)&lt;/strong&gt;이 있습니다.&lt;/p&gt;

&lt;p&gt;먼저 참조 계수기 접근 방법부터 알아보겠습니다. 참조 계수기 방법은 접근할 수 없는 메모리 셀이 생성될 때마다 회수를 수거하는 방법입니다. 이것을 구현하기 위해, 항상 모든 메모리 셀에 대해 현재 자신을 가리키고 있는 포인터의 갯수를 저장하는 계수기를 사용합니다. 만약 어떤 셀의 계수기 값이 0이 된다면 이 메모리 셀을 가리키는 포인터가 없다는 뜻이므로 더 이상 쓰지 않는 메모리 셀로 판단하여 회수합니다.&lt;/p&gt;

&lt;p&gt;참조 계수기 방법에는 세 가지 문제점이 존재합니다. 첫째는 기억공간의 셀 크기가 작다면, 그만큼 계수기가 차지는 공간이 부담이 될 수 있습니다. 둘째로 계수기의 값을 조절하기 위한 시간적 부담도 존재합니다. 특히나 LISP은 거의 모든 명령문마다 포인터의 값이 변경되므로, 프로그램 실행 시간에서 계수기가 차지하는 실행 시간이 매우 부담스럽습니다. 마지막으로 셀이 순환적으로 참조되어 있는 경우입니다. 이러한 순환 리스트에 속하는 셀은 적어도 1의 계수기 값을 갖게 되므로 영원히 회수되지 않는다는 문제점이 있습니다.&lt;/p&gt;

&lt;p&gt;다만 참조 계수기 방법에 단점만 있는 것은 아닙니다. 참조 계수기 방법은 순차적으로 동작하는 방식이기 때문에 프로그램의 수행과 번갈아가며 발생합니다. 따라서 전체적으로 프로그램 실행에 지연을 초래하지 않는다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/43.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 쓰레기 수집 접근 방법에 대해 알아보겠습니다. 실행 시간에서 저장공간이 요구될 때 기억공간의 메모리 셀을 할당하고, 필요할 때 포인터와 셀의 연결을 끊습니다. 이 때는 일단 기억공간 회수에 신경쓰지 않고, 사용가능한 모든 셀이 할당될 때까지 이루어집니다. 이 과정에서 발생하는 쓰레기를 수집하기 위해, 쓰레기 수집 프로세스가 시작됩니다. 쓰레기 수집을 위해, 모든 셀은 수집 과정에서 사용되는 여분의 비트나 필드를 갖습니다. 쓰레기 수집을 위한 간단한 알고리즘은 다음과 같이 나타낼 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;힙의 모든 셀은 쓰레기인지 나타내는 표시가 설정됩니다.&lt;/li&gt;
  &lt;li&gt;프로그램의 모든 포인터는 힙으로 추적되고, 도달 가능한 셀은 쓰레기가 아닌 것으로 표시합니다.&lt;/li&gt;
  &lt;li&gt;쓰레기가 아닌 것으로 표시되지 않은 힙의 모든 셀을 회수합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 쓰레기 수집 접근 방법의 가장 큰 단점은 가장 필요할 때 가장 최악으로 동작한다는 것입니다. 이게 무슨 말이냐 하면, 쓰레기 수집은 힙의 기억공간을 대부분 사용되었을 때만 사용됩니다. 그런데 이 방법은 대부분의 셀을 추적해서 현재 사용중인지 확인해야하기 때문에, 상당한 많은 시간이 소요됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/44.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 메모리 셀이 가변 크기인 경우에는 문제가 더 복잡해집니다. 우선 가변 크기 셀에서는 동일한 크기의 셀에서 발생하는 모든 어려움을 기본적으로 갖고 있고, 다음과 같은 추가적인 문제가 더 발생합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;힙에 있는 모든 셀이 쓰레기라는 것을 나타내기 위한 표시의 초기 설정이 어렵습니다. 왜냐하면 각각의 셀이 다른 크기이기 때문에, 셀의 영역이 어디서부터 어디까지인지 스캔하는 것이 어렵기 때문입니다. 이에 대한 대책으로는 셀의 첫 번째 필드로 그 셀의 크기를 표시하는 것입니다.&lt;/li&gt;
  &lt;li&gt;만약 포인터를 전혀 포함하지 않는 셀이라면 어떻게 표시를 할 것인지도 문제가 됩니다. 물론 이것은 내부 포인터를 추가하면 해결되는 문제이지만, 이것으로 인해 추가적인 공간적 부담과 시간적 부담이 발생합니다.&lt;/li&gt;
  &lt;li&gt;사용가능한 기억공간의 리스트를 관리하는 것도 문제입니다. 회수된 기억공간의 크기는 클 수도 있지만 작을 수도 있습니다. 만약 회수된 기억공간 중 하나가 필요한 기억공간의 크기에 맞지 않다면 충분한 크기를 가진 다른 기억공간을 찾아야합니다. 이에 대한 해결책으로는 기억공간의 크기가 작은 경우 인접한 블록을 합병하는 것이지만, 이 과정에서도 추가적인 시간적 부담이 발생합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 문제점 중, 1번과 2번의 문제는 참조 계수기 방법을 사용하면 어느 정도 해결이 가능합니다. 그러나 3번 문제는 참조 계수기로도 해결할 수 없습니다. 나쁜 소식은 대부분의 프로그래밍 언어에서는 이러한 가변 크기 셀의 관리가 반드시 필요하다는 것입니다.&lt;/p&gt;

&lt;p&gt;6장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry></feed>