<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-06T17:57:05+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">KEEPMIND</title><subtitle>A place I record so that I don&apos;t forget.</subtitle><author><name>Joonsu Ryu</name></author><entry><title type="html">Support for Object-Oriented Programming</title><link href="http://localhost:4000/pl/support-for-object-oriented-programming/" rel="alternate" type="text/html" title="Support for Object-Oriented Programming" /><published>2023-10-06T00:00:00+09:00</published><updated>2023-10-06T00:00:00+09:00</updated><id>http://localhost:4000/pl/support-for-object-oriented-programming</id><content type="html" xml:base="http://localhost:4000/pl/support-for-object-oriented-programming/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;드디어 프로그래밍 언어론의 마지막 장입니다. 이 장은 객체 지향 프로그래밍에 대해 상세하게 알아보겠습니다. 순서대로, 객체 지향 프로그래밍의 기본 개념, 객체 지향 프로그래밍 언어의 사례 연구로써 몇 가지 예시와 함께 C++의 대한 소개, 그리고 객체 지향 프로그래밍의 장점과 단점에 대해 다루어보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번 장의 순서는 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;서론&lt;/li&gt;
  &lt;li&gt;객체 지향 프로그래밍에 대한 기본 개념들
    &lt;ul&gt;
      &lt;li&gt;추상 데이터 타입&lt;/li&gt;
      &lt;li&gt;객체와 메시지 전송&lt;/li&gt;
      &lt;li&gt;클래스와 인스턴스&lt;/li&gt;
      &lt;li&gt;(다중) 상속&lt;/li&gt;
      &lt;li&gt;동적 바인딩과 다형성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체 지향 프로그래밍 언어
    &lt;ul&gt;
      &lt;li&gt;분류&lt;/li&gt;
      &lt;li&gt;C++ 언어를 통한 사례 연구&lt;/li&gt;
      &lt;li&gt;분석&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정리&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림은 2장 프로그래밍 언어의 발전사에 나왔던 그림입니다. 이 중에서 C++, Java, Ada 95는 객체 지향 프로그래밍을 완벽하게 지원하는 언어이고, 그 외의 언어들은 완벽한 객체 지향 프로그래밍을 지원하지는 않지만 영향을 미친 언어들입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2장에서 배웠던 프로그래밍 언어의 패러다임을 다시 정리하겠습니다. 참고로 시간에 따라 정리된 것이 아닙니다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;블록 구조(절차 지향 프로그래밍) : 프로그램은 블록과 프로시저의 중첩된 집합으로 구성되어 있습니다. 1960년대와 1970년대의 주요 패러다임으로 ALGOL, Pascal, PL/I, Ada, Modula 등의 언어가 이 패러다임의 영향을 받았습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;객체 기반(객체 지향 프로그래밍) : 프로그램은 상호작용하는 객체의 집합으로 구성되어 있습니다. 주로 1970년대와 1980년대 유행하였으며, Simula 67, Smalltalk, C++ 등의 언어가 이 패러다임의 영향을 받았습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동시 수행(분산 프로그래밍 패러다임) : 여러 개의 부프로그램이 동시적으로 수행되는 것을 중시합니다. 프로그램은 다중 스레드, 동히과, 통신 등의 기능을 가지고 있습니다. Fork-join, Ada-CSP, Linda 등의 언어가 이 패러다임의 영향을 받았습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수형 프로그래밍 패러다임 : 프로그램은 함수 정의의 집합으로 구성되어 있습니다. LISP, ML, Miranda, Haskel 등의 언어가 이 패러다임의 영향을 받았습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;논리 프로그래밍 패러다임 :  프로그램은 정리(Theorem)라는 해결 원리의 집합으로 구성되어 있습니다. 명확한 의미 체계와, 많은 암시적인 병렬 처리가 특징입니다. Prolog, Parlog, GHC 등의 언어가 이 패러다임의 영향을 받았습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 객체 지향 프로그래밍을 왜 사용하는 것일까요? 다음과 같은 이유가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현실 세계의 문제를 자연스럽게 모델링할 수 있음 (여러 자치적인 요소, 시뮬레이션 시스템)&lt;/li&gt;
  &lt;li&gt;모듈성 (데이터와 프로시저로 구분됨, 문제를 세부 문제로 나눌 수 있음, 정보 은닉)&lt;/li&gt;
  &lt;li&gt;소프트웨어의 재사용성 증가 (상속, 유용한 클래스 라이브러리)&lt;/li&gt;
  &lt;li&gt;병행 (각 객체를 병렬로 실행 가능)&lt;/li&gt;
  &lt;li&gt;단지 새로운 프로그래밍 패러다임이라서!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍이란 개념은 SIMULA 67에서 처음 시작되었습니다. 그러나 완전한 객체 지향 프로그래밍은 1980년 Smalltalk가 만들어지고 나서야 개발되었습니다. 그 때 정립된 객체 지향 프로그래밍은 프로그램이 객체들의 협동적인 집합으로 구성된 구현 방법으로, 각각의 객체는 어떤 클래스의 인스턴스를 나타내고, 그 클래스는 모두 상속 관계를 통해 결합되는 클래스 계층 구조의 구성원으로 정의됩니다.&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍의 패러다임은,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 클래스를 원하는지 결정하기&lt;/li&gt;
  &lt;li&gt;각각의 클래스에 대해 전체 동작의 집합을 제공하기&lt;/li&gt;
  &lt;li&gt;상속을 사용하여 명시적으로 공통점을 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;추상 데이터 타입(Abstract Data Type)&lt;/span&gt;은 11장에서도 다루었지만, 캡슐화와 정보 은닉을 모두 지원하는 데이터 구조입니다.&lt;/p&gt;

&lt;p&gt;데이터와 이것을 조작하는 코드가 함께 정의되고, 각각의 데이터는 연관된 코드와 분리되거나 별도로 접근할 수 없는 것이 캡슐화입니다. 그리고 데이터는 코드 내에 캡슐화되고, 지역화된 프로시저의 집합만 데이터를 직접 조작할 수 있습니다. 캡슐화는 소프트웨어 구성 요소 간의 상호 의존성을 줄여, 시스템의 신뢰성과 수정 가능성을 보장하기 때문에 중요합니다.&lt;/p&gt;

&lt;p&gt;정보 은닉은 프로그램의 구현 및 내부 표현을 고려하면 안 된다는 원칙입니다. 캡슐화는 결국 &lt;strong&gt;방법(How)&lt;/strong&gt;보다 &lt;strong&gt;무엇(What)&lt;/strong&gt;을 강조하는 것입니다. 캡슐화는 프로시저 추상화(서브루틴)과 데이터 추상화(추상 데이터 타입)으로 구분할 수 있습니다.&lt;/p&gt;

&lt;p&gt;추상화는 결국 사람들이 자신이 뭘 하고 있는지 생각하는 데 도움이 되고, 캡슐화는 제한된 노력으로 프로그램의 변경을 신뢰할 수 있게 만듭니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가령 스택을 C 언어와 같은 일반적인 방법으로 구현한 것과, 추상 데이터 타입으로 구현한 것을 비교해봅시다. 오른쪽 같은 경우에는 프로그래머가 스택을 사용하기 위해서 스택이 정의된 배열인 stack과 가장 위를 나타내는 변수인 top을 파악해야 합니다. 또한, 스택의 연산을 수행하기 위해 push, pop, sub1, sub2… 등의 프로시저를 모두 파악하고 있어야 합니다. 그러나 왼쪽과 같이 추상 데이터 타입으로 스택을 구현한다면, 스택의 인터페이스인 push와 pop에 대해서만 신경을 쓰면 되고, 스택을 구현하는 데이터인 stack, top이나 프로시저에 대해 신경을 쓸 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 객체와 메시지 전송에 대해 알아보겠습니다. &lt;span style=&quot;color:red&quot;&gt;객체(Object)&lt;/span&gt;란, 사적 데이터(Private data)와 메소드를 가진 엔티티(Entity)입니다. 객체는 상태라는 인스턴스 변수와 메소드라는 일련의 작업으로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;데이터는 객체로부터 얻을 수 있는데, 객체에게 메시지를 보냄으로써 간접적으로 프로시저를 호출하여 얻습니다. 객체 또한 정적 바인딩과 동적 바인딩으로 구분할 수 있습니다. 객체 지향 프로그래밍의 모든 행동은 객체 간의 메시지 전송에서 비롯되며, 메시지의 선택기는 작업의 종류를 지정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간단한 C++ 코드를 보면서 지난 슬라이드에서 배운 내용을 확인해보겠습니다. 먼저 Person이라는 클래스가 있고, Student 클래스는 Person 클래스로부터 상속을 받았습니다. 두 클래스 모두 사적 데이터(Private data)는 없고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getData()&lt;/code&gt;라는 메소드 하나씩만 보유하고 있습니다.&lt;/p&gt;

&lt;p&gt;main() 함수를 확인해보면, Student 클래스의 객체인 s는 정적으로 메모리에 바인딩 되었습니다. 또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s.getData()&lt;/code&gt;라는 메시지를 통해 s의 메소드를 호출하고 있습니다. Person 클래스의 객체인 p는 포인터를 이용하여 동적으로 메모리에 바인딩하고 있습니다. 이 때, Person 클래스의 객체에 Student의 객체를 할당하지만, Student가 Person의 서브 클래스이기 때문에 이러한 문법은 허용됩니다. p는 포인터 객체이기 때문에 p에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getData()&lt;/code&gt;를 호출할 때는 -&amp;gt;를 이용하여 호출합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 전통적인 프로그래밍과 객체 지향 프로그래밍을 비교해보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 전통적인 프로그래밍은, 데이터와 독립적인 프로시저에 의해 구성되어 있습니다. 함수의 값은 각각의 호출에 대해 정확한 인수를 가져야만 완전히 결정됩니다. 또한, 일반적으로 프로시저는 특정 타입의 데이터에만 적용됩니다.&lt;/p&gt;

&lt;p&gt;그에 반해 객체 지향 프로그래밍은 데이터와 프로시저의 묶음인 객체로 구성되어 있습니다. 객체에 대한 연산이 반환되는 값은 상태와 인수, 그리고 호출 기록에 따라 달라질 수 있습니다. 실행할 올바른 프로시저를 찾는 것은 언어 지원 시스템에서 처리됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 언어에서의 추상 데이터 타입은 일반적으로 &lt;span style=&quot;color:red&quot;&gt;클래스(Class)&lt;/span&gt;라고 불립니다. 클래스는 new나 create와 같은 명령을 통해 객체를 만들 수 있는 템플릿으로써, 구조(인스턴스 변스), 동작(메소드), 그리고 상속(부모)의 명세와 같은 것들을 포함합니다. 객체는 인스턴스화를 통해 클래스에서 생성되는데, 특정 클래스의 객체를 해당 클래스의 인스턴스라고 합니다.&lt;/p&gt;

&lt;p&gt;클래스는 두 가지 종류의 변수를 갖고 있는데, 클래스의 모든 인스턴스에서 값을 공유하는 클래스 변수와 각각의 객체에 별도로 공간이 할당되는 인스턴스 변수가 있습니다. 또한 클래스가 객체인 경우, 클래스에는 메타 클래스라는 클래스가 있어야 합니다. 대표적으로 Python에서는 클래스 자체가 객체가 될 수 있는데, type이라는 명령어를 이용하여 메타 클래스를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 슬라이드에서는 클래스 구성의 예시를 나타내고 있습니다. point라는 클래스에서 인스턴스 변수와 메소드를 정의합니다. 그 후, 이 클래스를 이용한 객체를 생성하는 것은 p1과 p2 처럼 객체 생성 명령어를 사용하여 point 클래스의 객체를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 클래스가 다른 클래스의 상위 클래스인 클래스 간의 관계를 &lt;span style=&quot;color:red&quot;&gt;상속(Inheritance)&lt;/span&gt;이라고 합니다. 상속은 객체 지향 프로그래밍에서 소프트웨어 재사용을 지원합니다. 기반 클래스에서 상태 구조와 명령을 상속하는 기능을 통해, 프로그래머는 기존 객체의 요소 뿐만이 아니라, 기반 클래스의 구성 요소를 수정하고, 추가하여 새로운 객체를 정의할 수 있습니다. 그로 인해 기반 클래스를 토대로 새로운 문제에 맞게 프로그램 조직화 및 전문화가 가능해집니다.&lt;/p&gt;

&lt;p&gt;상속의 구조를 예시로 들면 슬라이드와 같습니다. 포유류라는 기반 클래스를 상속받아 사람과 코끼리는 하위 클래스를 새로 정의하였습니다. 이 들은 분명 다른 클래스이지만 포유류의 특성을 모두 갖고 있습니다. 또한 사람의 하위 클래스로써 학생과 배우라는 직업을 기준으로 분류가 가능하며, 이를 토대로 철수, 영희와 같은 객체를 생성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;구체적으로 상속의 예시를 들어보겠습니다. 먼저 기반 클래스는 year, mon, day라는 인스턴스 변수를 가지고 있는 Date라는 클래스입니다. 이 클래스의 객체는 1993년 9월 10일과 같이 날짜를 표현할 수 있습니다. Date 클래스를 상속받아 Time과 Holiday라는 서브 클래스가 정의되었습니다. Time 클래스에서는 hour, min, sec라는 인스턴스 변수가 새로 정의되어, 기반 클래스가 가지고 있던 인스턴스 변수를 포함해 총 6개의 인스턴스 변수를 갖게 되었습니다. 이로 인해 날짜와 시간을 함께 표시할 수 있는 클래스로 정의되었습니다.&lt;/p&gt;

&lt;p&gt;Holiday 클래스는 name과 country라는 새로운 인스턴스 변수가 정의되었습니다. 이를 토대로, 기반 클래스에서 상속받은 날짜에 국가와 명절 이름을 같이 표기할 수 있는 클래스가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍과 관련된 개념을 보여주는 데이터 구조입니다. 클래스에서는 인스턴스 변수의 개수, 이름 등과 같은 다양한 내용을 저장하고 있습니다. 이 중 메소드 사전(Method Dictionary)라는 것이 있는데, 만약 현재 클래스에서 정의된 메소드라면 이 메소드 사전을 통해 접근하게 됩니다. 만약 기반 클래스에서 정의된 부분이라면 기반 클래스의 메소드를 참조하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클래스는 기반 클래스로부터 인스턴스 변수와 메소드를 상속받습니다. 상속받은 클래스를 주어진 문제에 전문화하기 위해서는 새로운 인스턴스 변수와 새로운 메소드를 정의하는 방법이 있습니다. 또는, 클래스의 변수나 메소드를 재정의할 수도 있습니다. 만약 여러 단계를 걸쳐 상속을 받았다면, 메소드를 호출할 때 어디서 정의된 메소드를 사용할 것인지를 결정해야 합니다. 일반적으로는 가장 가까이 있는 기반 클래스의 메소드를 사용하지만, 때에 따라 다른 메소드를 사용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;상속 구조는 계측정 상속, 위임(Deligation)에 의한 상속, 그리고 다중 상속이 있습니다. 계층적 상속은 클래스가 단일 기반 클래스에서만 상속받는 것을 말합니다. 가장 널리 사용되는 상속으로써 Smalltalk에서 제안된 방법입니다. 간단하고 효율적이지만, 표현력이 제한적이라는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;위임에 의한 상속은 각각의 객체가 처리할 메시지를 처리할 객체를 직접 선택하는 것입니다. 예를 들어, A 클래스에서 create()라는 메소드를 호출하는데, 이 메소드는 다른 클래스에서 정의된 메소드입니다. 이렇게 보면 일반적인 상속과 무엇이 다른가 싶겠지만, 직접적으로 “is-a” 관계가 아닌 경우(ex. 이전 슬라이드의 포유류 - 사람) 위임을 사용하는 것이 바람직합니다. 즉, 두 클래스 간의 종속성을 확립할 필요가 없거나, 그렇게 하면 문제가 생길 경우 위임을 사용한다고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로 다중 상속은, 클래스가 둘 이상의 기반 클래스로부터 상속을 받는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다중 상속에서는 클래스가 모든 기반 클래스로부터 변수와 메소드를 상속받습니다. 만약 상속받은 변수나 메소드에서 충돌이 있는 경우, 클래스 우선 순위 목록을 이용하여 상속의 우선 순위를 결정합니다. 일반적으로 깊이가 더 깊은 클래스를 우선적으로 상속받습니다. (Depth-first-up-to-join)&lt;/p&gt;

&lt;p&gt;상속의 장점으로는 더 나은 개념을 모델링할 수 있다는 것입니다. 오른쪽 그림과 같이 일상적인 것을 직접 모델링할 수 있고, 계층적 모델링을 통해 프로그램을 더 쉽게 이해할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Factorization이라는 단어는 번역하기 참 애매한 단어인데, 공학에서 사용할 때는 보통 인수분해로 해석합니다. 다만 뒤에 나온 설명하고 뭔가 어울리지 않아서 애매하네요. 일단 여기에서는 한 번만 기술하고 필요할 때 재사용하는 장점으로 설명되어 있습니다.&lt;/p&gt;

&lt;p&gt;다음으로는 디자인의 단계적인 개선을 통해 하향식 설계 및 검증에 유용하다는 장점이 있습니다. 마지막으로, 상속은 객체 지향 프로그래밍에서 다형성을 지원하도록 도와줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다중 상속의 예시는 다음과 같습니다. 학생과 배우라는 클래스는 사람이라는 기반 클래스로부터 파생된 클래스입니다. 그런데 학생 클래스는 일을 해라() 라는 메소드가 공부한다고 구현되어 있고, 배우 클래스의 일을해라() 라는 메소드는 TV에 나온다라고 구현이 되어 있습니다. 학생 배우라는 클래스는 학생과 배우로부터 상속받은 클래스입니다. 이 때, 일을해라()라는 메소드는 학생 클래스와 배우 클래스에 모두 존재하는 메소드입니다. 그렇다면 학생 배우 클래스의 인스턴스 객체인 박은빈에서 일을해라()라는 메소드는 어떤 행동을 해야하는가?라는 문제가 발생합니다. 이러한 문제를 죽음의 다이아몬드(Deadly Diamond)라고 하며, C++는 다중 상속을 지원하기 때문에 이러한 문제가 발생하지만, Java는 다중 상속을 지원하지 않기 때문에 이러한 문제가 발생하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍 언어에서는 메시지를 메소드 정의에 언제 바인딩하는지에 따라 &lt;span style=&quot;color:red&quot;&gt;정적 메시지 바인딩(Static Message Binding)&lt;/span&gt;과 &lt;span style=&quot;color:red&quot;&gt;동적 메시지 바인딩(Dynamic Message Binding)&lt;/span&gt;으로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;정적 메시지 바인딩은 객체의 특정 메소드에 대한 메시지 바인딩이 컴파일 타임에 발생하는 것을 말합니다. 이것은 정적 유형 언어에서 사용하는 바인딩 방식입니다. 반대로 동적 메시지 바인딩은 특정 메소드에 대한 메시지 바인딩이 실행 시간에 발생하는 것을 말합니다. 이것은 다형성을 지원하는 강력한 메카니즘으로, 타입이 지정되지 않는 언어에서 사용됩니다.&lt;/p&gt;

&lt;p&gt;이것이 어떤 차이가 있는지는 슬라이드 아래쪽에 나와있습니다. 동적 메시지 바인딩의 경우에는 draw라는 메시지가 호출되었을 때, 이것이 어느 클래스 객체인지에 따라 어떤 메소드에 바인딩될지가 결정됩니다. 그러나 정적 메시지 바인딩의 경우에는 클래스가 shape 하나만 있고, 그 안에서 type에 따라 어떤 기능을 수행할지 달라지는 형태입니다.&lt;/p&gt;

&lt;p&gt;동적 바인딩이 정작 바인딩보다 우수한 점은, 소프트웨어 시스템이 개발과 유지보수 기간 동안 쉽게 확장될 수 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍에서 &lt;span style=&quot;color:red&quot;&gt;다형성(Polymorphism)&lt;/span&gt;이란 둘 이상의 타입, 또는 클래스에서 명령을 수행하는 능력을 말합니다. 다형성은 &lt;strong&gt;애드 혹 다형성(Ad hoc Polymorphism)&lt;/strong&gt;과 &lt;strong&gt;유니버셜 타형성(Universal Polymorphism)&lt;/strong&gt;으로 나뉩니다. 애드 혹 다형성은 강제 변환(Coercion)과 연산자 오버로딩(Operator Overloading)으로 구현됩니다. 유니버셜 다형성은 매개변수 다형성(Parametric Polymorphism)과 포함 다형성(Inclusion Polymorphism)으로 구현됩니다. 각각의 내용을 정리하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;강제 변환 : 연산자나 문맥을 통해 피연산자의 타입을 변경시키는 것&lt;/li&gt;
  &lt;li&gt;연산자 오버로딩 : 피연산자의 타입에 맞춰 같은 연산 기호가 다양한 의미에 대입되는 것&lt;/li&gt;
  &lt;li&gt;매개변수 다형성 : 클래스의 인스턴스 변수나 메소드의 매개변수 타입을 임의의 타입이 아니라 상황에 따라 다양한 타입으로 선언하는 것&lt;/li&gt;
  &lt;li&gt;포함 다형성 : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행하는 명령이 달라지는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍 언어는 다음과 같이 3가지 분류로 나눌 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체 기반 언어(Object-based Language) : 객체를 지원하는 모든 언어의 클래스&lt;/li&gt;
  &lt;li&gt;클래스 기반 언어(Class-based Language) : 모든 객체가 클래스에 속하도록 요구하는 하위 클래스&lt;/li&gt;
  &lt;li&gt;객체 지향 언어(Object-oriented Language) : 상속을 지원하기 위해 클래스가 필요한 하위 클래스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;객체 지향 프로그래밍 언어 중 기존 언어를 확장해 만든 언어는 C++, Objective C, Object Pascal, Object COBOL, CLOS 등이 있고, 처음부터 순수 객체 지향 언어로 디자인된 언어는 Eiffel, Simula, Smalltalk 등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림은 객체 지향 언어와 관련된 언어의 가계도를 나타낸 것입니다. 객체 지향 언어는 파란색으로 표시되어 있고, 객체 기반 언어는 녹색 문의로 표시가 되어 있습니다. 그 외의 언어는 객체 기반 언어나 객체 지향 언어는 아니지만, 그러한 언어들에게 영향을 준 언어들입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 언어에 대한 사례 연구로써 C++ 언어를 살펴보겠습니다. C++ 언어는 1980년 초, 벨 연구소에서 근무하던 Bjarne Stroustrup의 팀이 개발했습니다. C++ 언어는 C 언어를 기반으로 만들어졌는데, C 언어와 호환이 가능한 상위 언어를 목표로 개발되었기 때문에, C++ 컴파일러로도 C 언어로 개발된 프로그램의 컴파일이 가능합니다. C++ 언어는 객체 지향 개념과 클래스, 상속 등이 포함되어 있으며 제네릭 함수, 참조 타입과 같은 다른 고급 기능으로 C 언어를 확장하였습니다. C++ 언언은 가장 널리 사용되는 객체 지향 프로그래밍 언어 중 하나이며, 효율성과 C 언어와의 호환성을 강조하여 설계되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++에서 클래스와 접근 지정자는 데이터 추상화를 지원하고, 서브타입 다형성과 가상 함수를 통해 동적 바인딩을 지원합니다. 또한 이를 포함하여 다중 상속, 가상 기반 클래스 등으로 상속을 지원합니다. 마지막으로 템플릿 함수, 탬플릿 클래스, 그리고 연산자 오버로딩을 통해 다형성을 지원합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터 추상화의 관점에서 C 언어와 C++ 언어를 비교해보겠습니다. 두 코드 모두 스택을 구현한 프로그램 코드입니다. C 언어의 경우에는 스택 본체를 전역 변수 배열로 선언하고, 스택의 각 기능을 함수로 정의하였습니다. 그에 반해 C++ 언어의 경우에는 스택 클래스를 통해 스택의 각 기능을 구현한 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;눈여겨볼 부분은 스택에서 사용되는 변수의 가시성입니다. C 언어에서는 stack 배열과 top이 전역 변수로 선언되어 있기 때문에 main() 함수를 포함한 모든 함수에서 볼 수 있고, 조작이 가능합니다. 이러한 가능성은 프로그래머의 의도와 다르게 해당 변수의 값이 변동될 수 있으므로 프로그램의 신뢰성을 낮추는 문제점이 있습니다. 그에 반해 C++ 언어에서는 이 변수들이 private로 선언되어 있기 때문에, 클래스 내에서만 접근이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연산자 오버로딩은 동일한 기호나 함수 이름이 다른 의미로 사용될 수 있음을 말합니다. C++ 언어에서는 기존 클래스에서 정의된 연산자를 재정의할 수 있습니다. 예를 들어서, 이 슬라이드의 예제에서는 += 연산자를 재정의하고 있습니다. 재정의한 연산자는 두 개의 문자열을 이어붙이는 역할로 변경되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어는 접근 지정자를 통해 각 멤버의 접근을 제한합니다. private로 선언된 멤버는 선언된 클래스의 멤버 함수에서만 접근할 수 있습니다. protected로 선언된 멤버는 파생 클래스에서 접근할 수 있다는 차이점을 제외하면 private와 같습니다. public으로 선언된다면 모든 함수에서 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 상속에서도 접근 지정자를 도입할 수 있습니다. public으로 상속한 클래스는 일반 기반 클래스와 동일하지만, private로 상속한다면 기반 클래스의 멤버가 파생 클래스에서 모두 private로 처리됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;접근 지정자의 예시를 확인해보겠습니다. 왼쪽의 employee 클래스를 상속받은 manager 클래스가 있습니다. manager 클래스는 public으로 상속받았기 때문에 일반적인 상속이 발생합니다. 그런데, employee의 멤버 변수 중 list는 private로 선언되어 있기 때문에 manager 클래스에서 접근할 수 없습니다. protected와 public으로 선언된 나머지 멤버 변수들은 모두 접근이 가능합니다. 만약 manager에서 이 list 변수에 접근하고 싶다면, employee에서 list와 관련된 멤버 함수를 정의하고, 이 멤버 함수를 상속받아 간접적으로 접근하는 수밖에 없습니다.&lt;/p&gt;

&lt;p&gt;오른쪽의 클래스 A, B, C 예제를 확인해보겠습니다. 클래스 C는 클래스 A와 B를 상속받았습니다. 클래스 A와 B 모두 display라는 가상 함수를 가지고 있지만, 매개변수의 타입이 다르기 때문에 죽음의 다이아몬드 문제가 발생하지 않습니다. 따라서 정상적으로 클래스 C에서 이 둘을 각각 정의하여 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어에는 다양한 내장 라이브러리가 존재합니다. 이중 가장 많이 사용했던 것은 MFC 라이브러리인데, 제가 학부를 다닐 때만 해도 학부 실습 시간에 MFC 프로그래밍을 가르쳤습니다. 최근에는 잘 사용하지 않는다는 이유로 빠져있더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어에 대한 평가를 해보겠습니다. C++ 언어의 장점은 캡슐화 및 데이터 추상화 관점에서 신뢰성을 높이고, 구현에서 절차적 사양과 표현적 사항을 분리하는 것이 가능합니다. 또한 C++ 언어는 정적 바인딩이 사용되는지 동적 바인딩이 사용되는지를 명시할 수 있고, 동적 바인딩을 사용하는 경우에는 유연성을 증가시킬 수 있습니다. 또한 상속으로 인해 소프트웨어의 재사용성이 크게 증가합니다.&lt;/p&gt;

&lt;p&gt;단점에 대해 언급해보자면 우선 높은 실행 시간 비용 문제입니다. 장점에서 언급했던 동적 바인딩은 실행 시간에 발생하고, 메시지 전달이 Smalltalk에 비해 1.7배 정도 느리기 때문입니다. 또한 의도와 코드 사이에서 발생하는 의미상의 차이와 소프트웨어 시뮬레이션의 어려움이 있으며, 클래스 라이브러리가 굉장히 많기 때문에 이것을 모두 배우기 어렵다는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/32.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정리하자면, 객체 지향 프로그래밍의 요소는 객체, 클래스, 메소드, 메시지, 상속, 동적 바인딩, 다형성 등의 특징을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;객체 기반 언어에 클래스가 추가된 것이 클래스 기반 언어, 그리고 거기에 상속이 추가된 것이 객체 지향 언어입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/33.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어의 주요 개선사항 중 하나는 병렬 처리입니다. 최근 하드웨어는 다수의 CPU를 가지고 있기 때문에 병렬 처리를 수행할 수 있습니다. Java 언어에서는 Thread 클래스를 통해 병렬 처리를 지원하는데, C++도 마찬가지로 Thread, Async, OpenMP 등의 라이브러리를 통해 병렬처리 프로그래밍을 수행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/34.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;본 강의자료의 참고 문헌 목록입니다. 필요하신 분은 참고해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/012/35.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 강의자료에 많은 내용들은 An Introduction to Object-Oriented Programming를 많이 참고하였습니다.&lt;/p&gt;

&lt;p&gt;12장의 내용은 여기까지입니다. 지금까지 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">교토 여행기 (1)</title><link href="http://localhost:4000/travel/kyoto-1/" rel="alternate" type="text/html" title="교토 여행기 (1)" /><published>2023-10-06T00:00:00+09:00</published><updated>2023-10-06T00:00:00+09:00</updated><id>http://localhost:4000/travel/kyoto-1</id><content type="html" xml:base="http://localhost:4000/travel/kyoto-1/">&lt;p&gt;대학원생은 생각보다 여행할 시간이 많지 않습니다. 그래서 가급적이면 연휴를 활용해야 하는데, 이번에 마침 추석 연휴와 개천절이 연결되어 6일이라는 황금 연휴가 만들어졌습니다. 물론 연휴는 모두가 해외여행을 떠나고 싶어하는 기간이기 때문에 표값도 비싸고, 관광지에 사람이 바글바글 댈 것이라는 예상은 들었지만, 이 기회를 놓치기 너무 아까워서 여행계획을 세웠습니다. 이번에는 5박 6일이라는 약간 애매한 일정이 만들어졌는데, 교토와 그 근교를 둘러보면 적당한 기간일 것으로 생각되어 교토를 방문하기로 결정했습니다. 이 기간의 비행기값만 70만원 가까이 나왔지만, 눈물을 머금고 예약했습니다.&lt;/p&gt;

&lt;h2 id=&quot;교토까지-이동&quot;&gt;교토까지 이동&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/01.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오전 8시 비행기였기 때문에 새벽부터 집에서 나왔습니다. 이 때 안 사실인데, 의외로 김포공항은 새벽에 리무진 버스가 다니지 않습니다. 그래서 지하철이나 버스 같은 대중교통을 이용해야하는데, 첫 지하철이 5시 45분이었기 때문에 이걸 타고 가면 너무 늦을 것 같았습니다. 그래서 새벽 5시 쯤에 있는 시내버스를 타고 서울역에 간 다음, 서울역에서 공항철도를 타고 김포공항을 가기로 결정했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/02.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;무사히 시내버스를 탔는데, 버스에 타니 최근 오픈한 트릭컬 광고가 보이더라구요. 예전에 한창 광고하다가 다시 섭종한 것으로 아는데, 찾아보니 이 날부터 다시 서비스를 개시했다고 들었습니다. 이렇게 대대적으로 광고할 정도로 이번에는 꽤 큰 마음을 먹은 것 같습니다. 어떻게 될지 궁금하네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/03.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새벽의 서울역은 굉장히 을씨년스러운 분위기였습니다. 서울역 안쪽은 아주 밝아보이는데, 주변에 전부 어두워서 미묘한 분위기가 느껴지네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/04.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;열차 시간에 딱 맞게 도착해서 다행히 김포공항에 일찍 도착했습니다. 지난 번에 도쿄를 갔을 때도 김포공항으로 갔는데, 그 때는 사람이 굉장히 없어서 널널했습니다. 그런데 역시 명절 연휴라 그런지 사람이 아주 바글바글하더라구요. 김포가 이정도면 인천은 얼마나 심할지 상상이 되질 않네요. 체크인까지 시간도 김포치고 굉장히 오래 걸렸습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/05.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;체크인과 수하물을 맡기고 터미널 안으로 들어왔습니다. 어느덧 시간이 흘러 해가 밝아오네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/06.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 타고 갈 비행기입니다. 이번에도 역시 아시아나로 예약했어요. 딱히 아시아나를 좋아하는 것은 아닌데, LCC는 특가를 못잡으면 사실상 아시아나랑 크게 차이가 나지 않아서 그냥 아시아나로 예약하는게 마음이 편하더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/07.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비행기를 타고 이륙한 다음 한 컷을 찍어봤습니다. 제가 탄 자리가 날개 부분이라 그런지 정면에 날개가 눈에 들어오네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/08.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/09.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이륙하고 잠시 뒤에 기내식을 받았는데, 지난번 나고야를 갔을 때와 비교하면 상당히 초라합니다. 그 때는 메인 메뉴 뿐만 아니라 빵과 과일 같은 것도 같이 줬는데, 이번에는 달랑 메인 메뉴 하나네요. 메인 메뉴도 지난번과 비교하면 맛이 상당히 별로였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/10.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 진짜 지옥은 간사이 공항에서 발생했습니다. 공항이 어느 정도 혼잡할 것은 예상하고 있었지만, 생각보다 혼잡도가 정말 엄청났습니다. 간시아 공항에서 입국수속을 하는데만 1시간이 넘게 걸렸습니다. 이 대기시간이 어느 정도냐면, 탑승객들이 직접 수하물을 찾으면 다음 비행기의 수하물과 섞이기 때문에 사진처럼 직원들이 수하물을 전부 따로 빼놓을 정도입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/11.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어찌어찌 간사이 공항에 입국수속을 마쳤습니다만, 아직 지옥은 끝나지 않았습니다. 왜냐하면 여기서 교토로 가려면 특급열차 하루카를 타야하기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/12.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간사이 공항에서 하루카를 타기 위해서는 2층에 있는 간사이 공항역으로 가야합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/13.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 번째 지옥은 바로 여기서 발생합니다. 하루카는 현지에서 구매하는 것보다 한국에서 미리 e-티켓을 구매하는 것이 훨씬 저렴한데, e-티켓을 실제 하루카 티켓과 교환하려면 여기서 직접 교환해야하기 때문입니다. 기계는 꼴랑 4대인데, 여기에 간사이 공항으로 온 수많은 사람들이 티켓을 교환하려고 줄을 서 있습니다. 이걸 기다리는데 또 1시간이 걸립니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/14.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어찌어찌 표를 교환했습니다. 하루카는 기본적으로 자유석인데, 그 자리에서 지정석으로 바로 교환할 수도 있습니다. 자유석은 자리가 없을 수도 있기 때문에 시간만 맞으면 지정석으로 교환하는 것이 좋습니다. (추가요금이 없습니다!) 간사이 공항에서 교토까지는 1시간 30분 정도 걸리기 때문에 서서가면 꽤 고통스럽기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/15.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하루카는 듣던대로 열차가 헬로키티로 도장되어 있기 때문에 굉장히 눈에 띕니다. 지정석은 보통 열차 1~2번째 칸이고, 나머지는 자유석으로 운영됩니다.&lt;/p&gt;

&lt;h2 id=&quot;교토역&quot;&gt;교토역&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/16.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어찌어찌 간신히 교토 역에 도착했습니다. 간사이 공항에 도착한게 오전 10시쯤이었는데, 교토 역에 도착할 때 시간은 어느덧 2시를 향해 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/17.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/18.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;교토 역은 굉장히 많은 열차가 다니기 때문에 매우 혼잡합니다. 제가 탔던 하루카 뿐만이 아니라 대부분의 간사이권 JR선이 교토 역을 지나가기 때문에, 역 안내소에는 항상 사람이 많이 보였습니다. 교토 시에서는 교토 역을 하나의 문화공간으로 만드려고 하는지, 교토 역 안에는 무대를 포함한 여가시설이 상당히 많이 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/19.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 시간까지 기내식만 하나 달랑 먹었었기 때문에 상당히 배가 고픈 상태였습니다. 교토역에는 식당이 굉장히 많은데, 층 별로 다른 컨셉의 식당이 운영되고 있습니다. 교토 역 10층은 라멘 가게만 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;中村商店&quot;&gt;中村商店&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d9245.50718455093!2d135.75855603673068!3d34.98716461669761!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001096bbe7e9941%3A0x19754a58f5c66a71!2sNakamura%20Sh%C5%8Dten!5e0!3m2!1sko!2skr!4v1696574099537!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/20.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저는 그 중 &lt;strong&gt;中村商店(나카무라 쇼텐)&lt;/strong&gt;이라는 라면집에 방문했습니다. 일본 여행 커뮤니티에서 이 가게의 시오라면 스페셜이 굉장히 맛있다는 게시글을 봤거든요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/21.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시오라멘 스페셜은 그림처럼 굉장히 많은 차슈가 올라갑니다. 가격은 1480엔으로 싼 편은 아닙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/22.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;음식을 받아보니 역시 사진처럼 차슈가 풍성했습니다. 사진으로는 양이 그렇게 많아보이지 않은데, 먹고 나니 배가 엄청나게 부르더라구요. 예전에 먹어봤던 일본 라멘은 굉장히 짰었는데, 이 가게는 그렇게까지 짜지 않았기 때문에 괜찮았습니다. 다만 국물까지 다 먹기에는 역시 좀 짜더라구요.&lt;/p&gt;

&lt;h2 id=&quot;리가-로얄-호텔-교토&quot;&gt;리가 로얄 호텔 교토&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d9245.411720626038!2d135.75024130645645!3d34.98800990898098!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001089572eaf6db%3A0x469c370f6f1f1b0b!2z66as6rCAIOuhnOyWhCDtmLjthZQg6rWQ7Yag!5e0!3m2!1sko!2skr!4v1696575392946!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/23.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에 선택한 호텔은 교토 역 근처에 있는 &lt;strong&gt;리가 로얄 호텔 교토&lt;/strong&gt;입니다. 예전 포스트에서도 언급했듯이, 일본의 호텔은 방이 작은 경우가 많습니다. 그래서 일본 호텔을 예약할 때는 방 크기를 가장 먼저 보는데, 마침 이 호텔이 객실의 방 크기도 크고 역에서도 그렇게 멀지 않을 뿐만 아니라 가격도 나름 합리적이었기 때문에 이 곳을 선택했습니다. 나중에 알고보니 이 호텔은 5등분의 신부에서 주인공들이 묵었던 호텔이라고 하더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/24.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;교토 역에서 점심을 먹고 가니 체크인이 가능한 시간이라고 하길래 바로 체크인을 했습니다. 방 번호는 703호를 받았는데, 번호가 낮을수록 안쪽 객실이라 왔다갔다 하는게 불편했습니다. 지난 번 도쿄에서도 안쪽 객실을 줬었는데 운이 좋지 않네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/25.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;방의 크기는 22제곱미터라고 하는데, 들어가보니 역시 작지 않았습니다. 침대도 킹 사이즈라 혼자 뒹굴뒹굴 거리면서 잘 수 있었고, 캐리어를 놓을 곳도 따로 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/26.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;화장실에는 욕조도 있었습니다. 예전에는 욕조 유무를 크게 신경쓰지 않았는데, 한번 욕조의 맛을 알게되니까 그 다음부터는 꼭 욕조가 있는 곳을 찾게 되더라구요. 밤에 뜨거운 물에 피곤한 몸을 담그고 맥주 한잔 하면 그렇게 기분 좋을 수가 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/27.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원래 대부분의 호텔에서는 식수를 2병 제공해줍니다만, 이 호텔은 특이하기 식수 대신 플라스틱 병을 지급합니다. 뭐 일회용 쓰레기를 줄이기 위한 일이라고 하던데… 별로 마음에 들진 않네요. 층 마다 정수기가 있어서 이 플라스틱 병에 직접 물을 받아와야하는데, 저는 귀찮아서 결국 나중에 편의점에서 생수를 사먹었습니다. 게다가 저 물병은 중간에서 물이 새서 사용하기 불편했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/28.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어매니티는 4성급 호텔답게 있을 것은 다 있습니다. 일회용 칫솔/치약, 면도기 같은 것은 다 있고 매일 아침 방 청소 때 다시 보충해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/29.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 호텔의 특이한 점은 관내복으로 유카타를 제공해준다는 것입니다. 대부분의 호텔은 샤워 가운을 제공해주는데, 샤워 가운은 입고 자기 조금 불편했거든요. 유카타는 일반 옷이랑 비슷한 재질이라 입고 자기 편리해보였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/30.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;호텔의 경치는 뭐… 크게 기대는 안했습니다. 어차피 도심 한가운데라 일반적인 빌딩뷰입니다.&lt;/p&gt;

&lt;h2 id=&quot;기요미즈데라청수사&quot;&gt;기요미즈데라(청수사)&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d13074.403988183287!2d135.75665747027304!3d34.991657794048834!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e3!4m5!1s0x6001089572eaf6db%3A0x469c370f6f1f1b0b!2z66as6rCAIOuhnOyWhCDtmLjthZQg6rWQ7YagIDHnlarlnLAgVGFpbWF0c3VjaG8sIFNoaW1vZ3lvIFdhcmQsIEt5b3RvLCA2MDAtODIzNyDsnbzrs7g!3m2!1d34.986385299999995!2d135.75269509999998!4m5!1s0x600108d385dcfb07%3A0x62af658650c434ba!2z7J2867O4IOq1kO2GoOu2gCDqtZDthqDsi5wg7Z6I6rCA7Iuc7JW866eI6rWsIOq4sOyalOuvuOymiCAxIOyhsOuplCDquLDsmpTrr7jspojrjbDrnbw!3m2!1d34.9948561!2d135.7850463!5e0!3m2!1sko!2skr!4v1696576661356!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;새벽부터 거의 한 숨도 못자고 긴 거리를 이동하고 나니 굉장히 피곤했습니다. 하지만 짧은 여행 기간 동안 하나라도 더 구경해야하니 호텔에 간단하게 짐을 풀고 바로 나왔습니다. 첫 날에는 간단하게 기요미즈데라(청수사)와 그 주변 관광지를 둘러볼 계획입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/31.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역시 문화재의 도시 답게 호텔에서 버스 정류장으로 가는 길에도 뭔가 유적같은 것이 눈에 들어오네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/32.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이곳이 시내 버스 정류장입니다. 보통 해외 여행할 때 버스보다는 지하철을 선호하는데, 교토는 지하철 노선이 굉장히 부실해서 대부분의 관광지는 버스를 이용해야만 이동할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/33.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 탈 버스는 206번 버스입니다. 버스비는 거리에 상관없이 230엔이고, 한 시간에 4대 정도가 다닙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/34.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;206번 버스를 타고 기요미즈데라로 가기 위해서는 고조자카 역에서 내리면 됩니다. 버스 안내판에 한글로도 나오기 때문에 쉽게 알 수 있습니다. 지도상으로는 기요미즈데라까지 거리가 크게 멀어보이지 않았는데, 교통 체증 때문인지 40분 정도나 걸렸습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/35.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기요미즈데라는 버스 정류장에서도 거리가 꽤 멀기 때문에 15분 정도 추가로 걸어가야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/36.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역시 교토의 대표 관광지 답게 입구에서부터 사람들이 굉장히 많이 보였습니다. 도쿄의 아사쿠사처럼, 여기도 기요미즈데라까지 가는 길에 기념품을 파는 가게가 쭉 늘어져 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/37.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/38.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/39.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 그 긴 길을 따라 올라가도 끝이 아니라 계단을 올라가야 하더라구요. 벌써부터 조금 지치기 시작했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/40.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/41.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/42.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기요미즈데라 입구에도 이것저것 많긴 했는데, 핵심 지역으로 이동하려고 하니 역시 입장료를 받네요. 입장료는 400엔입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/43.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기요미즈데라 안쪽은 지대가 더 높아서, 이렇게 경치를 감상할 수 있게 되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/44.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이곳이 본당인 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/45.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일본 애니에서 보던 곳입니다. 한국의 약수터처럼 생겼는데, 저 물을 마시는게 아니라 저 물을 받아서 입을 씻는 거라고 하더라구요. 국자가 마치 약수터 국자처럼 생겨서 한국인들은 혼동할 수도 있을 것 같습니다. (그래서인지 마시지 말라는 경고문도 붙어있었습니다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/46.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/47.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기요미즈데라에서 가장 유명한 무대입니다. 무대 건너편에 이렇게 무대를 향해 사진을 찍을 수 있게 되어있는데, 이 모습이 참 아름답더라구요. 괜히 유명한게 아니다라는 느낌이 들었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/48.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지나가다보니 이렇게 불상에 천 조각을 두른 모습이 보였습니다. 이 때는 기요미즈데라의 특이한 모습인줄 알았는데, 나중에 보니 교토 전체에서 이런 문화가 있는 것 같더라구요. 무슨 의미가 있는지는 잘 모르겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/49.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;슬슬 다 보고 돌아가려는 찰나 굉장히 재밌는 모습을 봤습니다. 천장에서 떨어지는 물을 받아 마시는 곳 같은데, 생각해보니 내청코 애니메이션에서 봤던 기억이 나네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/50.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이름 모를 탑도 눈에 들어왔습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/51.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;안에 조그만 호수도 있었는데, 이 호수 안에 물고기가 살고 있더라구요. 일본에서 봤던 대부분의 호수에서는 다 물고기가 살고 있었는데, 원래 이렇게 물고기가 많이 사는건지 아니면 일부러 관광객을 위해 풀어놓은 건지는 잘 모르겠습니다. 호수라기보다는 물 웅덩이에 가까운 크기라 자연발생하지는 않았을 것 같은데 말이죠.&lt;/p&gt;

&lt;h2 id=&quot;야사카-신사&quot;&gt;야사카 신사&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d6536.593918314576!2d135.7759182469149!3d34.99927077990646!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x600108d385dcfb07%3A0x62af658650c434ba!2z7J2867O4IEt5b3RvLCBLeW90bywgSGlnYXNoaXlhbWEgV2FyZCwgS2l5b21penUsIDEtY2jFjW1l4oiSMjk0IOq4sOyalOuvuOymiOuNsOudvA!3m2!1d34.9948561!2d135.7850463!4m5!1s0x60010879a010eca9%3A0xc77ac89d5a241ae9!2z7JW87IKs7Lm0IOyLoOyCrCA2MjUgR2lvbm1hY2hpIEtpdGFnYXdhLCBIaWdhc2hpeWFtYSBXYXJkLCBLeW90bywgNjA1LTAwNzMg7J2867O4!3m2!1d35.0036559!2d135.7785534!5e0!3m2!1sko!2skr!4v1696579261243!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/52.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기요미즈데라 다음에는 근처에 있는 야사카 신사로 갔습니다. 버스를 타고 가기에는 애매한 거리라 산책할 겸 걷기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/53.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 시간대에 살짝 보슬비가 내렸는데, 그래서 그런지 하늘이 어둑어둑하네요. 사진의 분위기가 영 안좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/54.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가는 길에 너무 목이 말라 자판기에서 음료수를 하나 뽑아먹었습니다. 이로하스 모모가 그렇게 맛있다고 소문이 나서 한 번 마셔봤는데, 진짜 맛있더라구요! 뭔가 물인데 복숭아의 달콤한 맛도 은은히 나서 앞으로 이것만 마셔야겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/55.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자판기 근처에서 본 탑입니다. 이 탑의 이름이 분명 있을진데 구글 지도에도 나오지 않아서 못찾겠네요… 혹시 아시는 분이 있다면 댓글로 알려주시면 감사하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/56.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;야사카 신사의 입구입니다. 듣기로는 저녁부터 신사 내의 등이 켜진다는데, 아직 시간이 애매해서 불이 켜지진 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/57.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이곳이 신사 본당인 것 같습니다. 천장에 3줄로 달린 흰 색이 바로 등입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/58.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;신사 구석에 보니 조그만 물줄기가 흐르는 곳이 보였습니다. 전 이런 미니멀한 감성(?)이 좋더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/59.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다리가 아파서 의자에 앉아 조금 쉬고 있었는데, 날씨가 흐려서 그런지 생각보다 일찍 불이 켜졌습니다. 불이 켜진 김에 한바퀴 둘러보고 다른 곳으로 이동해야겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/60.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여긴 신당 안에 말 조형이 2개 있더라구요. 무슨 의미일까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/61.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;야사카 신사에서 볼 거리는 이게 전부입니다. 생각보다 크지 않아서 금방 둘러볼 수 있더라구요. 신사 뒤쪽에는 공원도 있던데, 거기까지 둘러보기는 다리도 아프고 귀찮아서 그냥 이 정도만 보고 기온 거리로 이동하기로 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;기온-거리&quot;&gt;기온 거리&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m28!1m12!1m3!1d3268.120738331706!2d135.77532427640185!3d35.00368261689486!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!4m13!3e2!4m5!1s0x60010879a010eca9%3A0xc77ac89d5a241ae9!2z7J2867O4IOq1kO2GoOu2gCDqtZDthqDsi5wg7Z6I6rCA7Iuc7JW866eI6rWsIOq4sOyYqOuniOy5mCDquLDtg4DqsIDsmYAg7JW87IKs7Lm0IOyLoOyCrA!3m2!1d35.0036559!2d135.7785534!4m5!1s0x600108c3c1c67b67%3A0xdcb04aa1398efb4!2z6riw7Jio!3m2!1d35.003781599999996!2d135.777245!5e0!3m2!1sko!2skr!4v1696580207419!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/62.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;야사카 신사로 바로 나오면 기온 거리가 보입니다. 기온 거리는 교토의 전통 시장이라고 합니다. 다만 전통시장이라고 보기에는 현대식 가게들이 많이 들어와 있어서 그렇게까지 볼만한 곳은 아닌 것 같았습니다. 저렇게 전등 같은 것을 달아놓은 것만 빼면 그냥 상점가인데요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/63.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기온 거리 한쪽에는 이렇게 강이 흐르고 있었습니다. 배도 고프고, 이 날 볼만한 것은 다 본 것 같아서 이자카야나 가기로 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;이자카야-안지&quot;&gt;이자카야 안지&lt;/h2&gt;

&lt;center&gt;&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3268.164431494135!2d135.76307997640163!3d35.002588766953856!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x6001089671e1cbeb%3A0x500a8bd33f0887ae!2sAnji!5e0!3m2!1sko!2skr!4v1696581645781!5m2!1sko!2skr&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/64.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뭘 먹을까 하다가 첫날에는 회가 먹고 싶어져서 회를 파는 곳을 찾아봤습니다. 주변에 있는 이자카야 중에 이 곳이 가장 평점이 높길래 찾아가봤어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/65.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메뉴판이 밖에 이렇게 나와있긴 한데, 필기체라 알아보기도 힘들고 알아보더라도 생선 이름인 것 같아서 의미를 잘 모르겠더라구요. 뭐 그래도 교토니까 영어 메뉴판 정도는 있지 않을까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/66.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다행히 영어 메뉴판도 있었고, 주문 방식은 QR 코드를 통해 스마트폰으로 주문하는 방식이라 그렇게 어렵지 않았습니다. 먼저 생맥주 大자를 시켜봤습니다. 가격이 만원 좀 넘긴 했는데, 이거 한 잔만 마셔도 될 정도로 엄청 크더라구요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/67.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 먼저 시킨건 사시미 메뉴입니다. 5종의 생선이 2점씩 나오는 메뉴인데, 가격이 만 오천원 정도더라구요. 플레이팅을 감안해도 가격이 상당히 비쌌습니다. 서울에서 회 한접시에 2~3만원 정도 하지 않나요? 맛있긴 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/68.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 시켜본 메뉴는 고등어 초밥입니다. 예전부터 고등어 초밥을 먹어보고 싶었는데, 한국에서 고등어 초밥을 파는 곳이 흔하지 않다보니 지금까지 못먹어봤거든요. 나중에 알고보니 고등어 초밥이 교토의 특산물 중 하나라고 합니다.&lt;/p&gt;

&lt;p&gt;고등어 초밥은 생고등어를 올려서 먹는게 아니라, 고등어를 올린 다음 불로 살짝 구워서 주더라구요. 맛은 짭짤한 고등어 구이 맛이 났습니다. 가격이 만원 정도였는데, 4피스에 만원이면 조금 비싼 감이 있긴 합니다.&lt;/p&gt;

&lt;h2 id=&quot;호텔로-복귀&quot;&gt;호텔로 복귀&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/69.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이자카야 안지에서 약 4천엔 정도 나왔습니다. 귀가할 때는 지하철 가라스마선을 타고 교토역으로 돌아왔습니다. 교토역에서 호텔로 가는 길에 관광객들이 뭘 찍고 있길래 뭔가 보니 교토 타워가 보이더라구요. 모습이 이쁘길래 저도 한 번 찍어봤습니다. 생각해보니 일본은 도시마다 저런 타워가 하나씩 있는 것 같네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Travel/017/70.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;맥주를 많이 마시긴 했는데 술 한잔으로는 부족해서 편의점에서 술과 안주를 사서 들어갔습니다. 사진에는 잘 안보이는데, 편의점에서 파는 푸딩과 조각 케익이 엄청 맛있었습니다.&lt;/p&gt;

&lt;p&gt;이렇게 교토에서 첫 날이 끝났습니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="travel" /><category term="kyoto" /><summary type="html">대학원생은 생각보다 여행할 시간이 많지 않습니다. 그래서 가급적이면 연휴를 활용해야 하는데, 이번에 마침 추석 연휴와 개천절이 연결되어 6일이라는 황금 연휴가 만들어졌습니다. 물론 연휴는 모두가 해외여행을 떠나고 싶어하는 기간이기 때문에 표값도 비싸고, 관광지에 사람이 바글바글 댈 것이라는 예상은 들었지만, 이 기회를 놓치기 너무 아까워서 여행계획을 세웠습니다. 이번에는 5박 6일이라는 약간 애매한 일정이 만들어졌는데, 교토와 그 근교를 둘러보면 적당한 기간일 것으로 생각되어 교토를 방문하기로 결정했습니다. 이 기간의 비행기값만 70만원 가까이 나왔지만, 눈물을 머금고 예약했습니다.</summary></entry><entry><title type="html">Abstract Data Types and Encapsulation Constructs</title><link href="http://localhost:4000/pl/abstract-data-types-and-encapsulation-constructs/" rel="alternate" type="text/html" title="Abstract Data Types and Encapsulation Constructs" /><published>2023-09-22T00:00:00+09:00</published><updated>2023-09-22T00:00:00+09:00</updated><id>http://localhost:4000/pl/abstract-data-types-and-encapsulation-constructs</id><content type="html" xml:base="http://localhost:4000/pl/abstract-data-types-and-encapsulation-constructs/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;11장의 주제는 추상 데이터 타입과 캡슐화 구조입니다. 프로그래밍을 어렵게 만드는 것은 데이터의 컴퓨터 표현이 부자연스럽기 때문입니다. 추상화는 프로그래밍의 복잡성에 맞서는 무기로, 추상화의 목적은 프로그래밍 프로세스를 단순화하는 것입니다. 프로그래머가 필수 속성에 집중하고, 하위 속성을 무시할 수 있도록 하기 때문에 효과적인 무기입니다.&lt;/p&gt;

&lt;p&gt;데이터 추상화의 두 가지 주요 기능은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;관련 작업으로 데이터 객체를 캡슐화하기&lt;/li&gt;
  &lt;li&gt;(중요한) 정보를 숨기기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 &lt;span style=&quot;color:red&quot;&gt;추상화(Abstraction)&lt;/span&gt;의 개념은 프로세스나 객체의 일부 범주가 해당 속성의 부분집합으로만 표현될 수 있다는 것입니다. 이것은 다른 모든 속성이 추상화되거나 숨겨져 있다는 카테고리의 필수 속성입니다. 쉽게 말하면, 추상화는 중요한 속성만을 포함하는 객체의 표현이라고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;추상화는 프로그래밍의 복잡성에 맞서는 무기입니다. 추상화의 목적은 프로그래밍 과정을 단순화하는 것으로, 프로그래머가 필수적인 속성에만 집중하고, 나머지 속성은 무시할 수 있도록 하기 때문입니다.&lt;/p&gt;

&lt;p&gt;추상화의 개념 자체는 간단하지만, 프로그래밍 언어가 이것을 지원하도록 설계되기 전까지는 추상화를 사용하는 것이 편리하지 않았습니다. 언어에서 추상화를 위해 지원하는 것 중 대표적인 것은 &lt;strong&gt;추상 데이터 타입(Abstract Data Type)&lt;/strong&gt;이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현대 프로그래밍 언어에서 제공하는 추상화는 &lt;strong&gt;프로세스 추상화(Process Abstraction)&lt;/strong&gt;와 &lt;strong&gt;데이터 추상화(Data Abstraction)&lt;/strong&gt;가 있습니다. 먼저 프로세스 추상화는, 수행 방법을 명시하지 않고 일부 프로세스가 수행되도록 프로그램이 실행될 수 있도록 하는 방법입니다. 이 개념은 프로그래밍 언어 설계에서 가장 오래된 개념 중 하나입니다. (약 1940년대부터 대중화가 시작) 예를 들어, 9장에서 배운 부프로그램은 호출하는 프로그램에서 프로세스가 어떻게 동작하는지에 관해서 상세하게 지정할 필요가 없습니다. 따라서 모든 부프로그램은 프로세스 추상화입니다. 예를 들어, 프로그램이 어떤 데이터를 정렬하려고 할 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SORT_INT(LIST, LENGTH)&lt;/code&gt;와 같이 호출할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 이러한 호출은 SORT_LIST의 알고리즘이 명시되지 않은 정렬 프로세스의 추상화입니다. 따라서 이 부프로그램의 호출은 호출된 부프로그램에서 구현된 알고리즘과 독립적입니다. 이 부프로그램의 필수 속성은 정렬할 배열의 이름, 원소의 타입, 그리고 배열의 길이입니다. SORT_INT의 알고리즘이 버블 정렬인지, 퀵 정렬인지는 상관이 없습니다.&lt;/p&gt;

&lt;p&gt;데이터 추상화는 표현 및 구현 세부사항을 프로그래메에 의해 숨기는 것을 말합니다. 이렇게 설명하면 프로세스 추상화와 매우 비슷하게 들리겠지만, 실제로 데이터 추상화와 프로세스 추상화는 매우 연관되어 있습니다. 왜냐하면 프로세스 추상화의 광범위한 사용은 결국 데이터 추상화를 이끌어내기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 장에서는 데이터 추상화에 대해서만 더 집중적으로 논의해보겠습니다. 데이터 추상화는 프로그래밍 방법론의 개념 중 하나인데, 프로세스 추상화보다 훨씬 늦게 발견되었습니다. 이것은 COBOL과 함께 Data-oriented Programming이 화두가 되었던 1960년대에 시작되었습니다. 데이터 추상화를 위한 동기는 프로세스 추상화가 만들어진 동기와 비슷합니다. 즉, 크고 복잡한 프로그램을 더 잘 다룰 수 있도록 복잡성에 대항하기 위한 방법 중 하나입니다.&lt;/p&gt;

&lt;p&gt;대표적인 데이터 추상화의 구현으로써 &lt;span style=&quot;color:red&quot;&gt;추상 데이터 타입(Abstract Data Type)&lt;/span&gt;이 있습니다. 추상 데이터 타입은 레코드 타입의 데이터 구조이지만, 데이터를 다루는 부프로그램을 포함하고 있습니다. 구문적으로 따졌을 때, 추상 데이터 타입은 한 개의 특별한 데이터 타입과, 그 데이터의 표현 및 연산을 제공하는 부프로그램을 포함합니다. 접근 제어를 이용하여 불필요한 세부 사항들은 외부로부터 숨길 수 있습니다. 추상 데이터 타입을 사용하는 프로그램 단위는, 그 타입의 변수를 선언할 수 있지만 어떻게 구현되었는지는 숨겨집니다. 추상 데이터 타입의 인스턴스(Instance)를 &lt;strong&gt;객체(Object)&lt;/strong&gt;라고 부릅니다.&lt;/p&gt;

&lt;p&gt;먼저, 추상 데이터 타입으로써 부동 소수점을 알아보겠습니다. 프로그램에 내장된 데이터 타입은 전부 추상 데이터 타입입니다. 예를 들어, 대부분의 언어는 한 가지 이상의 부동 소수점 데이터 타입을 가지고 있습니다. 부동 소수점 데이터 타입은 일반적으로 실수의 값을 저장하는데 사용됩니다. 실제로 부동 소수점 데이터 타입은 부동 소수점 데이터에 대한 변수를 생성하는 수단을 제공합니다. 그리고, 그 유형의 객체를 조작하기 위한 산술 연산(+, *, -, /)을 제공합니다.&lt;/p&gt;

&lt;p&gt;그러나, 6장에서 데이터 타입에 대해 구체적으로 배우기 전까지는 이러한 데이터 타입이 어떻게 구성되어 있는지 모르거나 관심이 없었을 겁니다. 즉, 메모리 셀에서 부동 소수점 데이터가 실제로 어떻게 저장되어 있는지는 사용자로부터 숨겨지고, 사용자가 부동 소수점 객체의 표현을 직접 수정할 수 없습니다. 따라서 이것은 데이터 추상화의 중요한 개념인 &lt;strong&gt;정보 은폐(Information Hiding)&lt;/strong&gt;라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부동 소수점 타입에서는 정보 은폐로 인해, 사용자가 사용 가능한 유일한 작업은 시스템 내에서 제공하는 작업들 뿐입니다. 게다가, 부동 소수점 데이터 타입에 대한 새 작업을 생성할 수 없습니다. 이것으로 인해, 부동 소수점 데이터 타입은 특정 형식으로 고정되지 않고, 어느 정도 자유로운 데이터 표현 방법을 가질 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 표현의 장점은, 기계마다 다른 방법으로 부동 소수점 타입을 표현하더라도 쉽게 프로그램을 이식할 수 있다는 것입니다. 예를 들어, IEEE 704 표준 부동 소수점 표현이 1980년대에 정립되었는데, 그 전에는 컴퓨터 구조마다 부동 소수점 타입을 조금씩 다르게 표현했습니다. 그러나 부동 소수점 타입을 사용하는 프로그램이 여러 컴퓨터 구조에 이식되는 것에 문제가 없었습니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;사용자 정의 추상 데이터 타입(User-defined Asbtract Data Type)&lt;/span&gt;은 일반적인 추상 데이터 타입으로써 다음 두 가지 조건을 만족하는 데이터 타입을 말합니다.&lt;/p&gt;

&lt;p&gt;첫 번째 조건은 타입의 선언과 타입의 객체에 수행되는 작업이 단일 구문 단위(그룹, 컴파일 유닛)로 포함된다는 것입니다. &lt;strong&gt;(캡슐화)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 번째 조건은 타입 객체의 표현은 그 타입을 사용하는 프로그램 단위로부터 숨겨지고, 이러한 객체에 직접적으로 수행 가능한 연산은 타입의 정의에서 제공하는 연산 뿐이라는 것입니다. &lt;strong&gt;(정보 숨김)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이렇게 표현과 연산을 단일 구문 단위로 패키징하면 다음과 같은 장점이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;캡슐화에 의한 지역적 수정 : 이러한 타입을 사용하는 프로그램 단위는 표현의 세부사항을 볼 수 없으므로, 표현의 방법에 의존하지 않습니다. 게다가 표현 방법은 해당 타입을 사용하는 프로그램 단위에 영향을 주지 않고, 언제든지 변경할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정보 은폐로 인한 신뢰성 향상 : 프로그램 단위는 의도적으로, 또는 우연히 표현의 일부를 직접 변경할 수 없으므로, 해당 객체의 &lt;strong&gt;무결성(Integrity)&lt;/strong&gt;이 향상됩니다. 객체는 오로지 제공하는 연산을 통해서만 변경할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;무결성으로 인한 정보 은폐의 대표적인 장점 중 하나는 신뢰성이 증가한다는 것입니다. 또 다른 장점은 프로그래머가 프로그램을 작성하거 읽을 때 유의해야할 코드의 범위와 개수가 줄어든다는 것입니다. 특히, 추상 데이터 타입 내에서 정의된 변수의 값은 제한된 영역에서만 변화될 수 있기 때문에 코드를 이해하기 쉽고, 의도치 않게 그 값이 변경되는 사태를 막을 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 추상 데이터 타입에 있는 데이터를 Public과 같은 공용으로 명세하고, 그 데이터 대한 접근 방법을 제공하는 것은 추상 데이터 타입의 원리를 위반하는 것이므로 주의하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어서, 스택(Stack)에 대한 추상 데이터 타입을 살펴보겠습니다. 스택에서 허용된 연산은 다음과 같이 정의되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;create(stack) : 스택 객체를 생성한다.&lt;/li&gt;
  &lt;li&gt;destroy(stack) : 스택을 위한 기억공간을 해제한다.&lt;/li&gt;
  &lt;li&gt;empty(stack) : 스택이 비어있으면 true, 그렇지 않으면 false를 반환한다.&lt;/li&gt;
  &lt;li&gt;push(stack, element) : 스택에 element 원소를 추가한다.&lt;/li&gt;
  &lt;li&gt;pop(stack) : 스택 가장 위의 있는 원소를 제거한다.&lt;/li&gt;
  &lt;li&gt;top(stack) : 스택 가장 위의 있는 원소를 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 이러한 기능들만 만족하면, 내부 구현이 배열로 구성되었던 연결 리스트로 구성되었던 전혀 신경쓸 필요가 없습니다. 이렇게 데이터 추상화의 목표는 데이터 객체를 하나하나 표현하는 것이 아니라, 추상적인 속성에만 의존하여 프로그램을 작성할 수 있는 기능을 제공하는 것입니다. 게다가, 나중에 스택의 구현 내용을 수정하더라도, 각각의 기능의 프로토타입이 변경되지 않는다면 스택 객체를 사용한 코드를 변경할 필요가 없다는 것도 장점입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 추상 데이터 타입을 설계할 때 무엇을 고려해야 할까요? 언어에서 추상 데이터 타입을 정의하기 위해서는 타입 선언과 그 타입의 객체에서 가능한 연산을 구현하는 부프로그램을 같이 설계해야 합니다. 또한 추상화를 사용하는 다른 프로그램 단위가 타입 이름과 부프로그램 헤더(프로토타입)를 볼 수 있어야 합니다. 물론 타입의 표현은 은폐되어야 합니다.&lt;/p&gt;

&lt;p&gt;타입에 대한 정의와 함께 주어지는 연산 외에도, 일반적인 연산들이 추상 데이터 타입 객체에 제공되어야 합니다. 이러한 연산은 대표적으로 &lt;strong&gt;배정(Assignment)&lt;/strong&gt;, &lt;strong&gt;동치(Equality)&lt;/strong&gt; 비교가 있습니다. 만약 객체 내의 변수가 있다면, 그 변수를 외부에서 직접 수정하는 것은 최대한 지양되어야 합니다. 대신, 객체 내의 연산을 통해 간접적으로 객체 내의 변수를 조절할 수 있어야 합니다. 동치 비교 또한 두 개의 객체가 같은지, 다른지는 ==와 같은 일반적인 연산 대신 객체 내에 정의된 연산으로 비교가 가능해야 합니다.&lt;/p&gt;

&lt;p&gt;또한 추상 데이터 타입의 캡슐화 요구 사항은 두 가지 방법으로 충족할 수 있습니다. 첫 번째 방법은 단일 데이터 타입과 그 연산을 사용자가 직접 정의할 수 있도록 제공하는 것입니다. Pascal과 Smalltalk, C++이 이러한 방법을 사용합니다. 두 번째 방법은 많은 객체를 정의할 수 잇는 일반화된 캡슐화 구조를 제공하는 것입니다. 이러한 각각의 객체는 외부에 선택적으로 보일 수 있도록 지정할 수 있습니다. Modula-2와 Ada 같은 언어가 이러한 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;추상 데이터 타입을 설계할 때 고려해야 할 것들을 정리하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;추상적일 수 있는 타입의 종류를 어떻게 제한할 것인가?&lt;/li&gt;
  &lt;li&gt;추상 데이터 타입이 제네릭, 또는 매개변수화 될 수 있는가?&lt;/li&gt;
  &lt;li&gt;지역 이름과 비지역 이름 간의 충돌을 방지하기 위해 가져온 타입을 어떻게 한정할 것인가? (접근 제어)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면 각각의 언어에서 추상 데이터 타입을 어떻게 정의하고 있는지 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;가장 먼저 살펴볼 언어는 SIMULA 67입니다. SIMULA 67 언어는 완전한 추상 데이터 타입을 위한 지원은 없지만, 데이터 추상화의 개념이 처음 시작된 언어입니다. 캡슐화의 관점에서 SIMULA 67의 클래스 정의는 타입에 대한 템플릿(Template)입니다. 클래스의 인스턴스는 사용자 프로그램의 요청에 따라 동적으로 생성되며, 포인터 변수로만 참조가 가능합니다.&lt;/p&gt;

&lt;p&gt;클래스 정의의 구문 형식은 인스턴스 생성 시, 클래스 변수 초기화를 위해 클래스 인스턴스 코드 부분이 한 번만 실행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SIMULA 67이 데이터 추상화를 위해 기여한 점은 클래스 구조를 통해 데이터를 선언하는 것과 이를 다루는 프로시저를 구문적으로 캡슐화 했다는 것입니다. 즉, 슬라이드에 나온 것처럼 슬라이드의 정의에서 변수와 부프로그램을 클래스 내에 선언하는 것입니다.&lt;/p&gt;

&lt;p&gt;정보 은폐 관점에서 보자면, SIMULA 67의 클래스에서 선언된 변수는 클래스 객체를 할당하는 다른 프로그램 단위에서 숨겨지지 않습니다. 즉, 클래스의 부프로그램에서 접근하거나, 아니면 이름을 통해 직접 접근할 수 있습니다. 따라서 정보 은폐가 완벽하게 제공되지 않는다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 Modula-2 언어에서의 추상 데이터 타입에 대해 알아보겠습니다. Modula-2는 추상 데이터 타입의 표현을 숨기는 기능을 포함한 데이터 추상화를 지원합니다.&lt;/p&gt;

&lt;p&gt;Modula-2 언어에서 데이터 추상화 기능을 제공하는 프로그램 단위는 &lt;strong&gt;모듈(Module)&lt;/strong&gt;입니다. 모듈은 다른 프로그램 단위에서 접근할 수 있는 타입, 객체 및 부프로그램의 정의를 모두 포함할 수 있습니다.&lt;/p&gt;

&lt;p&gt;모듈의 정의에서는, 클라이언트 장치에서 부프로그램의 헤더뿐만 아니라 타입 및 객체의 최소한의 부분 사양을 볼 수 있습니다. 또한, 모듈의 인터페이스를 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;모듈의 구현에서는, 해당 정의 모듈에서 부분적으로만 정의된 모든 타입의 완전한 정의가 이루어집니다. 또한 해당 정의 모듈에 헤더가 나타나는 부프로그램의 전체적인 정의도 포함해야 합니다. 이러한 모듈은 별도로 컴파일이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 모듈의 정의에서 표현이 포함되어 있다면, 그 타입은 &lt;strong&gt;투명(Transparent)&lt;/strong&gt;하다고 하며, 그 표현을 가져오는 모듈에서는 숨겨지지 않습니다.&lt;/p&gt;

&lt;p&gt;그러나 모듈의 정의에서 표현이 포함되어 있지 않고, 구현 모듈에 표현이 포함된다면 그 유형은 &lt;strong&gt;불투명(Opaque)&lt;/strong&gt;하다고 합니다. 추상 데이터 타입은 당연히 불투명해야하지만, Modula-2 언어에서는 포인터 타입만 불투명할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제 Modula-2의 코드를 보고 이것이 무슨 의미인지 알아보겠습니다. 이것은 Modula-2 언어로 스택을 구현한 프로그램입니다. 스택 모듈의 이름은 stackmod로 정의되어 있습니다. 모듈은 정의 모듈(Definition Module)과 구현 모듈(Implementation Module)로 나뉘어 있는데, 정의 모듈에는 타입과 프로시저의 헤더가 선언되어 있고, 구현 모듈에 상세한 구현 내용이 작성되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 다른 모듈에서 이전 슬라이드에서 정의한 stackmod 모듈을 사용하고 싶다면, FROM ~ IMPORT 명령어를 이용하여 stackmod 모듈의 프로시저를 하나하나 호출해줘야 합니다.&lt;/p&gt;

&lt;p&gt;클라이언트에서 모듈의 프로시저를 호출할 때는 2가지 방법이 있습니다. 명시적으로 어떤 모듈의 프로시저인지 나타내는 방법과, 그냥 프로시저의 이름만을 호출하는 경우입니다. 만약 프로시저 이름의 중복이 없다면 그냥 프로시저의 이름만 호출해도 사용이 가능하지만, 만약 다른 모듈에서 같은 이름의 프로시저가 있다면 모듈의 이름을 반드시 명시해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 살펴볼 언어는 Ada입니다. Ada는 추상 데이터 타입을 완벽하게 지원하는 최초의 언어입니다.&lt;/p&gt;

&lt;p&gt;Ada 언어의 캡슐화 구성 요소나 모듈은 &lt;strong&gt;패키지(Package)&lt;/strong&gt;라고 부릅니다. 패키지는 &lt;strong&gt;명세 패키지(Specification Package)&lt;/strong&gt;와 &lt;strong&gt;몸체 패키지(Body Package)&lt;/strong&gt; 두 부분으로 구성되는데, 각각을 그냥 패키지라고 부르기도 합니다. 모든 패키지가 몸체 패키지를 갖고 있는 것은 아니고, 만약 패키지 앞에 body 로 시작하는 명령어를 입력하면 컴파일러는 이 패키지를 몸체 패키지로 인식합니다. 명세 패키지와 몸체 패키지는 서로 별도로 컴파일이 가능한데, 이 때는 반드시 명세 패키지를 먼저 컴파일해야 합니다. 또한 명세 패키지만 컴파일 된다면, 몸체 패키지를 컴파일하지 않아도 클라이언트 코드를 컴파일할 수 있습니다.&lt;/p&gt;

&lt;p&gt;명세 패키지에는 두 개의 섹션이 있습니다. 한 섹션은 외부에서 볼 수 있게 완전히 공개되고, private로 정의된 섹션은 외부에서 볼 수 없기 감춰집니다. 이 때, private는 반드시 명세 패키지의 마지막 부분에 작성해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Modula-2에서 보여드렸던 스택 코드를 Ada 언어로 구현한 코드입니다. 이전과 어떠한 차이가 있는지 같이 알아보겠습니다. 먼저, Modula-2 언어에서는 보이는 부분과 보이지 않는 부분을 별도의 모듈을 사용해서 구현했으나, Ada 언어는 하나의 패키지에서 보이는 부분과 보이지 않는 부분이 모두 나타나 있습니다. 대신, 그 구분을 private를 이용하여 나타냈습니다.&lt;/p&gt;

&lt;p&gt;패키지 첫 줄에는 limited private가 있습니다. 이것은 STACKTYPE 패키지가 &lt;strong&gt;제한된 전용 타입(Limited Private Type)&lt;/strong&gt;이라는 의미로, 이러한 타입의 객체에서 내장된 연산이 없다는 의미입니다. 예를 들어서, 생성자와 같이 미리 정의되는 배정 연산이나 비교 연산 같은 것이 없다는 것입니다. 스택에서 이러한 연산은 거의 사용되지 않기 때문에 여기에서는 limited private가 사용되었습니다.&lt;/p&gt;

&lt;p&gt;몸체 패키지에서는 스택의 각 함수와 프로시저가 구현되어 있습니다. 첫 줄에서 with / use 명령어가 사용되는데, with TEXT_IO은 텍스트 입출력을 위한 함수를 제공하는 외부 패키지를 볼 수 있게 만드는 것이고, use는 TEXT_IO를 참조할 때 명시적으로 참조하지 않게 만드는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제로 이 패키지를 사용하는 클라이언트에서는 마찬가지로 with / use 명령어를 이용하여 STACKPACK과 TEXT_IO를 가져옵니다. 나머지 코드의 부분은 직접 스택 패키지를 사용하는 예제를 나타낸 것이므로 별도의 설명이 필요하지 않을 것 같습니다.&lt;/p&gt;

&lt;p&gt;데이터 추상화의 관점에서 Modula-2와 Ada 언어를 비교해보겠습니다. Modula-2 언어는 포인터로만 불투명 내보내기를 제한하였지만, Ada의 추상 데이터 타입은 그렇지 않기 때문에 더 유연하다는 장점이 있습니다. 그러나, Modula-2의 설계는 모듈의 요소를 선택적으로 가져올 수 있기 때문에 패키지의 일부만 필요한 경우에는 Ada 언어보다 낫다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 유명한 언어 중 하나인 C++ 언어의 추상 데이터 타입에 대해 알아보겠습니다. C++은 C 언어에서 객체 지향 프로그래밍을 지원하는 기능이 추가된 언어이며, 그렇기 때문에 당연히 데이터 추상화도 지원합니다.&lt;/p&gt;

&lt;p&gt;C++의 클래스는 데이터 타입에 대한 템플릿이기 때문에, 여러 번 인스턴스화할 수 있습니다. 클래스에서 정의된 데이터는 데이터 멤버(또는 인스턴스 변수)라고 부르고, 클래스에서 정의된 함수는 멤버 함수(또는 메소드)라고 부릅니다. 데이터 멤버와 멤버 함수는 클래스와 인스턴스에 나타나는데, 클래스의 멤버는 클래스와 관련이 있고, 인스턴스 멤버는 클래스 인스턴스와 관련이 있습니다. 여기서는 클래스의 인스턴스 멤버만 고려하겠습니다.&lt;/p&gt;

&lt;p&gt;클래스의 모든 인스턴스는 멤버 함수를 공유하지만, 각각의 인스턴스는 자신의 데이터 멤버를 갖습니다. 클래스 인스턴스는 객체라고도 불립니다.&lt;/p&gt;

&lt;p&gt;클래스 인스턴스는 정적, 스택 동적, 힙 동적일 수 있습니다. 클래스 인스턴스가 만약 정적이나 스택 동적이라면 직접 참조할 수 있지만, 힙 동적이라면 포인터를 통해 참조됩니다. 정적이나 스택 동적인 경우는 객체 선언을 통해 생성되는 경우를 말하며, 힙 동적인 경우에는 new 연산자에 의해 생성되는 경우를 말합니다. 만약 클래스 인스턴스가 스택 동적일지라도, 클래스는 힙 동적 테이터를 참조하는 멤버 데이터를 포함할 수 있습니다.&lt;/p&gt;

&lt;p&gt;클래스 멤버 함수는 두 가지 방법으로 정의될 수 있습니다. 클래스 정의에서 헤더만 작성하고 클래스 외부에서 몸체 부분을 정의할 수도 있고, 또는 헤더에서 완전히 모든 것을 구현하는 인라인 함수(Inlined Function)가 있습니다. 인라인 함수의 장점은 일반적인 부프로그램에서의 호출과 복귀 과정을 거치지 않는다는 장점이 있습니다. 대신 클래스 정의 인터페이스가 복잡해지기 때문에, 인라인 함수는 일반적으로 실행 시간 효율성이 매우 중요한 상황에서만 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 클래스는 보이는 요소와 숨겨진 요소를 모두 포함할 수 있습니다. 이것은 접근 지정자를 표시하는 것으로 구별합니다. private 접근 지정자는 외부로부터 은폐되는 요소를 의미하며, public은 외부로부터 볼 수 있는 요소를 의미합니다. protected는 외부로부터는 은폐되지만, 상속받은 서브 클래스에는 보이는 요소를 의미합니다.&lt;/p&gt;

&lt;p&gt;또한 C++ 언어에는 &lt;strong&gt;생성자(Constructor)&lt;/strong&gt;와 &lt;strong&gt;소멸자(Destructor)&lt;/strong&gt;가 존재합니다. 생성자는 객체 생성 프로세스에서 매개변수를 초기화하고 제공하는데 사용합니다. 생성자는 클래스 타입의 인스턴스가 생성될 때 묵시적으로 호출되며, 클래스와 동일한 이름을 갖습니다. 생성자는 중복으로 만들 수 있지만, 각각의 생성자는 매개변수가 달라야 합니다. 소멸자는 생성자와 마찬가지로 클래스 타입 인스턴스의 수명이 끝날 때 묵시적으로 호출됩니다. 생성자와 소멸자는 모두 반환 타입을 갖지 않고, return 명령어를 사용하지도 않습니다. 또한, 프로그래머가 명시적으로 생성자와 소멸자를 호출하는 것도 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전에 나왔던 스택 예제를 C++의 클래스로 구현한 모습입니다. 먼저 Stack 클래스의 객체는 스택 동적이지만, 힙 동적 데이터를 참조하는 포인터 변수인 *stack_ptr을 포함합니다. Stack 클래스의 데이터 멤버 3개는 모두 private로 선언되어서 외부로부터 숨겨져 있습니다. 또한 Stack 클래스는 생성자, 소멸자, 그리고 4개의 멤버 함수를 가지고 있습니다. 이 예제에서는 모든 선언에 구현이 포함되어있기 때문에, 인라인 함수로써 취급됩니다. 현재 Stack 클래스는 생성자에서 항상 100개의 크기를 가지는 배열을 생성하지만, 동적인 크기를 갖는 배열로 변경하려면 생성자에 매개변수를 추가하여 그 크기만큼 배열을 생성하는 생성자로 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 Java 언어에서의 추상 데이터 타입을 살펴보겠습니다. Jva에서의 추상 데이터 타입 지원은 C++ 언어와 매우 유사합니다. 그러나 C++ 언어와는 다음과 같은 여러 가지 차이점이 있습니다.&lt;/p&gt;

&lt;p&gt;첫째로, Java의 모든 사용자 정의 데이터 타입은 클래스입니다. C++ 언어는 C 언어의 상위호환이기 때문에, 클래스가 아니라 함수와 같은 프로시저도 선언이 가능한 것과 대조적입니다. 또한, Java는 구조체(Structure)를 지원하지 않습니다. Java에서 모든 객체는 힙에서 할당되고, 참조 변수를 통해 접근할 수 있습니다. 게다가, Java 언어의 메소드 몸체는 반드시 헤더와 함께 나타나야 합니다. 따라서 Java의 추상 데이터 타입은 단일 구문 단위로 선언되고 정의됩니다.&lt;/p&gt;

&lt;p&gt;또한 Java 언어에서는 &lt;strong&gt;쓰레기 수집기(Garbage Collector)&lt;/strong&gt;가 있기 때문에 C++ 언어와 달리 소멸자가 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/011/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 추상 데이터 타입을 매개변수화하는 것에 대해 알아보겠습니다. 이것은 때때로 매우 편리한데, 이전의 예제인 스택을 여러 개의 스칼라 데이터 타입에 사용할 필요가 있는 경우, 각각의 데이터 타입에 대해 별도의 스택 추상화를 작성할 필요가 없기 때문입니다. 만약 임의의 스칼라 타입 원소를 저장할 수 있는 하나의 스택 추상 데이터 타입을 설계할 수 있다면, 프로그램의 재사용을 통해 전체 코드의 길이를 압축할 수 있습니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 나온 코드는 Ada 언어에서의 &lt;strong&gt;제네릭 패키지(Generic Package)&lt;/strong&gt;입니다. 이전에 나왔던 스택 코드를 다양한 스칼라 데이터 타입에 대해 사용할 수 있게 수정한 버전입니다. 주요한 점은 MAX_SIZE를 통해 스택의 크기를 조절할 수 있고, 데이터 타입이 ELEMENT_TYPE 으로 바뀌었다는 것입니다. 스택 객체를 생성하는 부분을 보면, 앞의 숫자를 통해 스택의 크기를 정의하고 뒷쪽의 자료형을 통해 원하는 자료형으로 생성하는 모습을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 추상 데이터 타입 매개변수화는 정적 타입 언어만의 고려사항입니다. 왜냐하면 Ruby나 Python과 같은 동적 타입 언어에서는 이러한 매개변수화를 사용하지 않고도 임의의 스칼라 데이터를 저장할 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;11장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Implementing Subprograms</title><link href="http://localhost:4000/pl/implementing-subprograms/" rel="alternate" type="text/html" title="Implementing Subprograms" /><published>2023-09-18T00:00:00+09:00</published><updated>2023-09-18T00:00:00+09:00</updated><id>http://localhost:4000/pl/implementing-subprograms</id><content type="html" xml:base="http://localhost:4000/pl/implementing-subprograms/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10장의 주제는 부프로그램의 구현입니다. 이번 장을 한 문단으로 요약하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“이 장의 목적은 주요 명령형 언어에서 부프로그램을 구현하는 방법을 알아보는 것입니다. 토론은 독자에게 그러한 언어가 어떻게 “작동”하는지에 대한 통찰력을 제공합니다. 부프로그램 구현의 어려움이 증가하는 이유는 재귀에 대한 지원과 비지역 변수 접근에 대한 지원을 포함해야 하기 때문입니다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램의 호출과 반환 연산을 합쳐서 &lt;span style=&quot;color:red&quot;&gt;부프로그램 연결(Subprogram Linkage)&lt;/span&gt;이라고 합니다. 부프로그램의 구현 방법은 부프로그램 연결의 의미를 기반으로 해야 합니다.&lt;/p&gt;

&lt;p&gt;대부분의 언어에서 부프로그램 호출에는 많은 동작이 수행됩니다. 특히 중요한 부분은 바로 지난 장에서 다루었던 매개변수 전달 방법입니다. 만약 지역 변수가 정적 변수가 아니라면, 부프로그램을 호출할 때 부프로그램에서 선언된 지역 변수를 위한 기억 공간을 할당해야 하고, 그 기억 공간에 지역 변수를 바인딩 하고, 호출된 부프로그램의 실행 상태를 저장해야 합니다.&lt;/p&gt;

&lt;p&gt;또한 부프로그램을 호출하는 과정에서 프로그램의 제어권을 부프로그램으로 전달해야 하고, 부프로그램의 수행이 종료되면 그 제어권을 다시 적당한 장소로 제어권을 반환하는 과정도 마련해야 합니다. 만약 해당 프로그래밍 언어가 중첩된 부프로그램을 지원한다면, 호출된 부프로그램에 비지역 변수에 접근할 수 있는 방안도 마련해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램 반환에 필요한 과정은 호출에 요구되는 과정보다는 덜 복잡합니다. 부프로그램이 out mode이거나 inout mode이고 Pass by Copy로 구현되는 매개변수를 가진다면, 반환 과정의 첫 번째는 관련된 형식 매개변수의 지역 값을 실 매개변수로 옮겨주는 것입니다. 다음으로는 부프로그램의 지역 변수에 사용된 기억 공간을 해제하고, 비지역 참조에 사용되는 메커니즘을 해제합니다. 마지막으로, 제어권을 호출한 프로그램에게 다시 반환합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 매우 &lt;strong&gt;간단한&lt;/strong&gt; 부프로그램을 구현해봅시다. 여기서 간단하다는 뜻은 중첩 부프로그램이 없고, 모든 지역 변수가 정적이라는 것을 의미합니다. 초기 Fortran 버전이 바로 이런 부프로그램을 갖는 언어입니다. 초기 Fortran 언어에서는 부프로그램이 재귀적으로 사용될 수 없었고, Fortran 77에서 비지역 변수에 대한 모든 참조는 COMMON을 통해 이루어졌습니다. 또한 부프로그램에 선언된 변수는 정적으로 할당되었습니다.&lt;/p&gt;

&lt;p&gt;Fortran 77에서 부프로그램 호출은 이러한 과정을 갖고 있었습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;현재 프로그램 단위의 실행 상태를 저장&lt;/li&gt;
  &lt;li&gt;매개변수 전달 과정을 수행&lt;/li&gt;
  &lt;li&gt;반환 주소를 호출된 프로그램에게 전달&lt;/li&gt;
  &lt;li&gt;제어권을 호출된 프로그램에 전달&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 77에서 부프로그램 반환은 이러한 과정을 갖고 있었습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pass by Value Result 매개변수나 out mode 매개변수가 사용된다면, 해당 매개변수의 현재 값을 실 매개변수로 전달&lt;/li&gt;
  &lt;li&gt;부프로그램이 함수인 경우, 함수 (반환)값을 호출자가 접근할 수 있는 위치로 이동&lt;/li&gt;
  &lt;li&gt;호출자의 실행 상태를 복구&lt;/li&gt;
  &lt;li&gt;제어권을 호출자에게 전달&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 호출 및 반환 과정에는 다음에 대한 저장 공간이 필요합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;호출자의 상태 정보&lt;/li&gt;
  &lt;li&gt;매개변수&lt;/li&gt;
  &lt;li&gt;반환 주소&lt;/li&gt;
  &lt;li&gt;함수의 반환값&lt;/li&gt;
  &lt;li&gt;(필요한 경우) 부프로그램에서 사용되는 임시 기억 장소&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그런데 호출 과정과 반환 과정을 호출자와 호출된 부프로그램에게 분배하는 것이 문제입니다. 다행히 간단한 부프로그램의 경우, 이것을 분배하는 것이 쉬운 편입니다. 호출에서의 과정은 1을 제외하고 호출자에서 수행되어야 합니다. 실행 상태를 저장하는 것은 호출자에서 저장할 수도 있고, 호출된 부프로그램에서 저장할 수도 있습니다. 반환에서는 두 번째 과정을 제외하고는 호출된 부프로그램에서 수행해야 합니다. 두 번째 과정은 마찬가지로 호출자에서 수행할 수도 있고, 호출된 부프로그램에서 수행할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 77과 같은 간단한 부프로그램은 각각 고정된 크기의 두 부분으로 구성됩니다. 하나는 부프로그램을 위한 정적인 실제 코드이고 나머지 하나는 지역 변수와 호출/반환 작업을 하기 위핸 데이터 영역입니다. 간단한 부프로그램의 경우 둘 다 고정된 크기를 갖습니다.&lt;/p&gt;

&lt;p&gt;부프로그램에서 코드가 아닌 부분은 부프로그램의 활성화(즉, 실행)에 관련된 부분이기 때문에 활성화 레코드(Activation Record)라고 합니다. Fortran 77의 경우에는 재귀를 지원하지 않기 때문에, 한번에 하나의 활성 부프로그램만 있을 수 있습니다. 따라서 부프로그램의 활성화 레코드는 단지 하나만 존재합니다. 게다가 간단한 부프로그램에서 활성화 레코드는 고정 크기이기 때문에, 정적으로 할당할 수 있습니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 나온 그림은 주프로그램(Main)과 두 개의 부프로그램 A, B로 이루어진 프로그램을 나타냅니다. 이러한 프로그램 구성은 컴파일러에 의해 전부 만들어지는 것은 아닙니다. 만약 독립적으로 컴파일이 수행되었다면 3개의 프로그램 단위는 각각 다른 날에 컴파일 되었을 수도 있습니다. 각각의 프로그램 단위가 컴파일 될 때, 외부 부프로그램의 참조 리스트와 더불어 기계어 코드가 파일에 작성됩니다. 따라서 슬라이드에 나온 그림은 운영체제의 일부인 &lt;strong&gt;링커(Linker)&lt;/strong&gt;에 의해 통합됩니다. 링커가 주프로그램을 위해 호출되었을 때, 링커는 주프로그램에 참조된 부프로그램을 포함한 파일을 찾고, 그 파일들을 메모리에 적재합니다. 그 후, 링커는 주프로그램에 있는 부프로그램 호출의 목적지 주소를 부프로그램의 진입 주소로 설정합니다. 이러한 과정을 모든 부프로그램에 대해서 동일한 작업을 실시합니다.&lt;/p&gt;

&lt;p&gt;이 과정을 슬라이드에 나온 구조에 빗대서 설명하면, 링커는 Main을 위해 호출된 후 부프로그램 A, B의 기계어 코드 프로그램과 활성화 레코드를 찾아 Main의 코드와 함께 메모리에 적재합니다. 그런 다음 A, B에 대한 호출과 A, B, Main에서 라이브러리 부프로그램에 대한 호출의 목적지 주소를 &lt;strong&gt;패치(Patch)&lt;/strong&gt;합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 스택 동적 지역 변수를 갖는 언어의 부프로그램을 구현하는 방법을 알아보겠습니다. 스택 동적 지역 변수의 가장 중요한 장점 중 하나는 재귀적 부프로그램을 지원한다는 것입니다. ALGOL과 그로부터 영향을 받은 언어들에서의 부프로그램 연결은 다음과 같은 이유로 간단한 부프로그램의 연결보다 훨씬 복잡합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;매개변수를 전달하는 방법이 두 가지 이상입니다. 예를 들어, Modula-2에서는 Pass by Value와 Pass by Reference를 지원합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부프로그램에 선언된 변수가 동적으로 할당되는 경우가 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;재귀는 여러 개의 부프로그램이 동시에 활성화될 수 있는 가능성을 추가합니다. 그렇기 때문에 활성화 레코드에는 여러 개의 인스턴스가 필요합니다. 각각의 활성화에는 반환 주소와 함께 형식 매개변수와 동적으로 할당된 지역 변수의 복사본이 필요합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ALGOL과 그와 유사한 언어들에서는 정적 범위를 사용하여 비지역 변수에 대한 접근을 제공합니다. 이러한 비지역 변수에 대한 지원은 연결 과정의 일부로 들어가야만 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로시저를 활성화하기 위해서는 프로시저에 대한 활성화 레코드 인스턴스를 동적으로 생성해야 합니다. 호출 및 반환 체계에서 마지막으로 호출된 부프로그램이 첫 번째로 종료되기 때문에 활성화 레코드 인스턴스는 스택으로 구현하는 것이 합리적입니다. 이 스택은 실행 시간(Run-time) 시스템의 일부이기 때문에 &lt;strong&gt;실행 시간 스택(Run-time Stack)&lt;/strong&gt;이라고 부릅니다. 부프로그램이 재귀적이든, 그렇지 않든 모든 프로시저의 활성화는 스택에 활성화 레코드 인스턴스를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다행히 대부분의 언어에서 주어진 부프로그램의 활성화 레코드 형식은 컴파일 시간에 알려집니다. 게다가, 대부분의 지역 데이터는 고정 크기이므로 활성화 레코드의 크기 또한 컴파일 시간에 알 수 있습니다. 그러나, Ada와 같이 지역 배역의 크기가 실 매개변수의 값에 영향을 받는 언어는 크기가 동적으로 정해질 수 있습니다. 그렇기 때문에 스택 동적 변수를 갖는 언어에서는 활성화 레코드가 동적으로 생성됩니다. 활성화 레코드의 형식은 활성화 레코드 인스턴스의 템플릿입니다. (지역 변수, 매개변수, 동적 링크, 반환 주소)&lt;/p&gt;

&lt;p&gt;지역 변수는 활성화 레코드 내의 저장소로 바인딩됩니다. 정적 링크(=정적 범위 포인터)는 비지역 변수에 대한 접근에 사용되는 링크로써, 정적으로 상위에 있는 활성화 레코드 인스턴스를 가리킵니다. 동적 링크는 당연히 동적으로 상위에 있는 활성화 레코드 인스턴스를 가리킵니다. 그렇다면 동적 링크는 정적 영역을 갖는 언어에서 필요하지 않나 싶겠지만, 정적 영역을 갖는 경우 이 링크는 프로시저의 실행이 완료될 때 현재 활성화 레코드 인스턴스를 제거하는데 사용되고, 또 실행 시간 오류가 발생할 때 추적(Traceback) 정보를 제공하기 위해 사용됩니다. 동적 영역 언어라면 당연히 동적으로 비지역 변수에 접근하기 위해 사용됩니다.&lt;/p&gt;

&lt;p&gt;반환 주소는 코드 세그먼트와 오프셋으로 이루어져 있으며, 실 매개변수는 호출자가 제공하는 값이나 주소를 통해 접근합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 예제를 통해 스택 동적 변수를 갖는 부프로그램이 어떤 활성화 레코드를 갖는지 알아보겠습니다. 왼쪽의 코드는 Pascal 언어로 만들어진 프로시저입니다. 가장 먼저 프로시저의 매개변수를 확인해 보면, total은 var로 선언되었기 때문에 Pass by Reference 매개변수이고, part라는 변수는 그렇지 않기 때문에 Pass by Value 입니다. 따라서 두 개의 매개변수가 스택에 쌓일 때, part는 그 값이, total은 그 주소가 저장된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그 이후에는 프로시저 내에서 발생하는 지역 변수가 스택에 쌓입니다. 교재와는 순서가 좀 다른데, 교재에서는 list[1]부터 list[5]까지 쌓인 후 sum의 변수가 스택에 저장되었지만, 여기서는 그 반대로 저장이 되었습니다. 다만 그 순서는 크게 중요하지 않은 것 같습니다. 다음으로 반환 주소와 정적 링크, 동적 링크가 차례로 저장되는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;지난 장에서, 부프로그램이 호출될 때부터 실행이 끝날 때 활성 상태라는 것을 배웠습니다. 따라서 부프로그램의 실행이 끝난 이후에는 활성화 레코드가 더 이상 의미가 없습니다. 따라서 그 이후에는 활성화 레코드가 해제됩니다.&lt;/p&gt;

&lt;p&gt;또한 예제와 같이 매개변수 항상 스택에 전달되는 것은 아닙니다. RISC에서 동작하는 컴파일러 중 일부분은 매개변수를 레지스터에 전달하기도 합니다. 왜냐하면 RISC는 CISC보다 더 많은 레지스터를 갖고 있기 때문입니다. 그러나 여기에서 그것까지는 고려하지 않고, 매개변수는 항상 스택에 저장된다고 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 본격적으로 재귀가 없고, 비지역 변수에 대한 참조가 없는 예제에서 활성화 레코드를 만들어보겠습니다.&lt;/p&gt;

&lt;p&gt;역시 코드는 왼쪽과 같이 주어졌습니다. 간단하게 보시면, MAIN_1 주프로그램에서 부프로그램 B를 호출하고, 부프로그램 B에서는 부프로그램 A를 호출합니다. 그리고 부프로그램 A에서는 C를 호출합니다. 구조상으로 부프로그램 C는 부프로그램 A 안에 있네요. 이 상황에서, 슬라이드와 같이 지점 1, 2, 3에서 각각 활성화 레코드를 그려보겠습니다.&lt;/p&gt;

&lt;p&gt;지점 1에서는 프로시저 MAIN_1과 B가 활성화되어있는 상태입니다. 따라서 활성화 레코드에는 MAIN_1과 B만 있어야 합니다. 따라서 가장 아래에는 MAIN_1에서 선언된 지역 변수인 P가 스택 가장 아래에 위치합니다. 그 다음에 스택에 쌓이는 것은 프로시저 B의 매개변수 R입니다. 다음으로는 프로시저 B의 지역 변수인 S, T가 스택에 쌓입니다. 그 후, 반환 주소, 정적 링크, 동적 링크가 차례대로 스택에 쌓이게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 지점 2에서의 스택 상황을 확인해보겠습니다. 지점 2에서는 프로시저 B가 프로시저 A를 호출한 상황입니다. 이 때 활성화된 프로시저는 MAIN_1, B, A 입니다. 따라서, 활성화 레코드에는 이전에 쌓였던 MAIN_1와 B의 데이터가 그대로 남아있습니다. 여기에 프로시저 A의 활성화 레코드가 그 위에 쌓이게 됩니다. 가장 먼저 프로시저 A의 매개변수인 X가 쌓이고, 그 위로 프로시저 A의 지역 변수인 Y, 그 위에는 반환 주소와 정적 링크, 동적 링크 순서대로 스택에 쌓이게 됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로 지점 3에서의 스택 상황을 확인하겠습니다. 이 때 활성화된 프로시저는 MAIN_1, B, A, C입니다. 따라서 활성화 레코드에는 이전에 쌓였던 MAIN_1, B, A의 데이터가 그대로 남아있습니다. 여기에 프로시저 C의 활성화 레코드가 그 위에 쌓이게 됩니다. 가장 먼저 프로시저 C의 매개변수인 Q가 쌓입니다. 그러나 프로시저 C의 지역 변수는 없기 때문에 그 다음에는 바로 반환 주소와 정적 링크, 동적 링크 순서대로 스택에 쌓이게 됩니다.&lt;/p&gt;

&lt;p&gt;이 예제에서 지점 1 -&amp;gt; 2 -&amp;gt; 3의 스택이 계속 쌓이기만 하는 것을 보고 “활성화 레코드는 스택에 계속 쌓이기만 하는구나”라고 착각을 하실 수도 있는데, 이것은 그러한 이유 때문이 아닙니다. 이 예제에서 지점 3에 도달할 때까지 비활성화되는 프로시저가 없기 때문에 스택에 계속 쌓이기만 하는 것입니다. 만약 지점 2에서 3으로 갈 때 프로시저 A가 비활성화된다면, 지점 3에서 A의 활성화 레코드는 스택에서 해제되고, 그 자리에 프로시저 C의 활성화 레코드가 위치하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 활성화 레코드에서 특정 시간에 스택에 존재하는 동적 링크의 모음을 &lt;span style=&quot;color:red&quot;&gt;동적 체인(Dynamic Chain)&lt;/span&gt;, 또는 호출 체인(Call Chain)이라고 합니다. 동적 체인은 실행이 현재 위치(활성화 레코드 스택의 꼭대기에 있는 부프로그램의 위치)에 어떻게 도달했는지에 대한 동적 기록을 나타냅니다.&lt;/p&gt;

&lt;p&gt;지역 변수에 대한 참조는 코드에서 활성화 레코드의 시작 지점으로부터 오프셋으로 나타내는데, 이것을 &lt;span style=&quot;color:red&quot;&gt;지역 오프셋(Local Offset)&lt;/span&gt;이라고 합니다. 활성화 레코드에 있는 변수의 지역 오프셋은 활성화 레코드와 관련된 부프로그램에서 선언된 변수의 순서, 타입, 크기를 사용하여 컴파일 시간에 결정됩니다.&lt;/p&gt;

&lt;p&gt;다음은 재귀를 사용하여 팩토리얼(Factorial)을 계산하는 프로그램에 대해 활성화 레코드 스택을 구해보겠습니다. 먼저, 코드의 구조를 살펴보면 TEST라는 주프로그램에서 FACTORIAL 이라는 함수를 호출합니다. FACTORIAL 함수에서는 특정 조건에 다다를 때까지 계속 자기 자신을 호출하는 구조입니다. 이 예제는 이전과 달리 하나의 함수를 계속 호출하는 구조이기 때문에 활성화 레코드의 포멧은 동일합니다. (슬라이드의 오른쪽 그림) FACTORIAL 함수는 지역 변수가 없지만, 반환 값이 있기 때문에 함수 값이 활성화 레코드에 추가됩니다. 이러한 구조에서, 지점 1, 2, 3에서의 활성화 레코드 스택이 어떻게 나오는지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 이 그림들은 각각 첫 번째, 두 번째, 세 번째 호출이 되었을 때 지점 1에서의 활성화 레코드 스택을 나타낸 이미지입니다. 왜 동일한 지점의 활성화 레코드 스택이 3개 나오냐면, 주프로그램 TEST에서 FACTORIAL(3)으로 호출했기 때문에 이 함수가 3번 호출되기 때문입니다. 따라서 FACTORIAL 함수가 3번 호출될 동안 스택에서는 아무것도 해제되지 않고 계속 쌓이기만 합니다.&lt;/p&gt;

&lt;p&gt;스택 맨 아래에는 당연히 주프로그램 TEST의 지역 변수인 VALUE가 저장되어 있고, 그 위에는 FACTORIAL 함수의 활성화 레코드가 쌓입니다. 이 때, 반환 주소는 첫 번째, 두 번째, 세 번째가 모두 달라집니다. 첫 번째 FACTORIAL 함수의 반환 주소는 주프로그램인 TEST가 되지만, 두 번째 FACTORIAL 함수의 반환 주소는 첫 번째 호출한 FACTORIAL 함수가 됩니다. 마찬가지로 세 번째 FACTORIAL 함수의 반환 주소는 두 번째 FACTORIAL 함수가 됩니다. 이미지 상으로 두 번째와 세 번째의 반환 주소가 동일해보이지만, 의미상으로는 다르다는 것을 주의해주세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림의 4~6은 첫 번째, 두 번째, 세 번째 호출이 되었을 때 지점 2에서의 활성화 레코드 스택을 나타낸 이미지입니다. 지점 2는 특이하게 마지막에 호출된 FACTORIAL 함수에서 가장 먼저 도달합니다. 그렇기 때문에 첫 번째로 지점 2에 도착할 때 활성화 레코드 스택은 3개의 FACTORIAL 함수의 활성화 레코드가 쌓인 상태입니다. 지점 1에서는 세 번째 호출까지 함수 값을 알 수 없었지만, 지점 2는 END 시점이기 때문에 이 지점에서 함수 값 또한 1로 계산이 끝난 상황입니다.&lt;/p&gt;

&lt;p&gt;두 번째 도착하는 지점 2에서는 세 번째 호출된 FACTORIAL이 종료된 상황이기 때문에 활성화 레코드 스택에서 제거되었습니다. 이 때도 FACTORIAL의 함수 값이 계산된 상황이므로 함수 값에 2가 저장됩니다. 마찬가지로 세 번째 도착하는 지점 2에서는 두 번째 호출된 FACTORIAL이 종료된 상황이기 때문에 활성화 레코드 스택에서 제거되었습니다. 물론 FACTORIAL의 함수 값이 계산 가능한 지점이므로 함수 값에 6이 저장됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로 VALUE의 값을 출력하는 지점 3에서는 모든 FACTORIAL 함수가 종료된 시점이므로 TEST의 지역 변수인 VALUE만 남아있게 되는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C 언어 기반이 아닌 정적 영역 언어는 스택 동적 지역 변수를 사용할 때 부프로그램이 중첩되는 것을 허용하기도 합니다. 이러한 언어의 대표적인 예시는 Ada, Python, JavaScript 등이 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 이전 슬라이드에서 보았듯이, 비지역으로 접근할 수 있는 모든 변수는 활성화 레코드 스택에 존재합니다. 여기서 중첩된 부프로그램을 갖는 정적 영역 언어에서 비지역 변수를 참조하기 위해서는 두 단계의 과정이 필요합니다. 첫 번째 단계는 스택에서 그 변수가 할당된 활성화 레코드를 찾는 것입니다. 두 번째 단계는 변수의 지역 오프셋을 사용하여 변수에 접근하는 것입니다.&lt;/p&gt;

&lt;p&gt;하지만 원하는 변수를 갖고 있는 정확한 활성화 레코드를 찾는 것은 어렵습니다. 지정된 부프로그램에서는 정적으로 상위 범위에 선언된 변수만 비지역으로 접근할 수 있습니다. 그런데 모든 정적 상위에 있는 활성화 레코드는 중첩된 프로시저에 의해 해당 인스턴스의 변수가 참조될 때 스택에 항상 존재합니다. 즉, 모든 정적 상위 부프로그램이 활성화일 때만 프로시저를 호출할 수 있습니다. 만약 어떤 특정한 정적 상위 프로그램이 활성화 상태가 아니라면, 그 지역 변수는 기억 공간에 바인딩되지 않았을 것이기 때문에 접근을 허용하는 것의 무의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비지역 참조에서 올바른 선언은 영역을 살펴볼 때 가장 먼저 발견되는 것입니다. (즉, 가장 가깝게 중첩된 첫 번째 선언) 따라서 비지역 참조를 지원하기 위해서는 스택에서 해당 정적 상위에 해당하는 모든 활성화 레코드를 찾을 수 있어야 합니다. 이것을 구현하는 방법은 &lt;span style=&quot;color:red&quot;&gt;정적 체인(Static Chain)&lt;/span&gt;과 &lt;span style=&quot;color:red&quot;&gt;디스플레이(Display)&lt;/span&gt;라는 것이 있습니다. 이제부터 이 두 가지 방법에 대해 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;중첩 부프로그램이 가능한 언어에서 정적 영역을 구현하는 가장 일반적인 방법은 정적 체인입니다. 이 방법에서는 정적 링크라고 불리는 새로운 포인터가 활성화 레코드에 추가됩니다. 정적 링크는 비지역 변수에 접근하기 위해 사용되며, 정적 체인은 활성화 레코드를 연결하는 정적 링크의 체인입니다. 예를 들어, 어떤 프로시저 P가 실행되는 중에, P로 인해 생성된 활성화 레코드의 정적 링크는 P의 정적 상위 프로그램의 활성화 레코드를 가리킵니다. 따라서 정적 체인은 정적인 부모 프로그램을 시작으로, 실행 중인 부프로그램의 모든 정적 상위 프로그램을 연결합니다.&lt;/p&gt;

&lt;p&gt;만약 비지역 변수에 대한 참조가 발생한다면, 그 변수를 포함하는 정적 상위 프로그램의 활성화 레코드를 찾을 때까지 정적 체인을 탐색함으로써 찾을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 이렇게 영역이 중첩되는 것은 컴파일 시간에 알려지기 때문에 컴파일러는 이러한 참조가 지역이 아니라는 것 뿐만 아니라, 실제로 비지역 개체를 포함하는 활성화 레코드에 도달하는 데 필요한 정적 체인의 길이도 알 수 있습니다. 그러한 길이를 &lt;strong&gt;정적 깊이(Static Depth)&lt;/strong&gt;라고 합니다. 정적 깊이는 정적 영역이 가장 바깥쪽 영역으로부터 얼마나 깊게 중첩되어 있는지를 나타내는 정수값입니다.&lt;/p&gt;

&lt;p&gt;변수 X의 비지역 참조를 위한 정확한 활성화 레코드에 도착하는데 필요한 체인의 길이를 &lt;strong&gt;중첩 깊이(Nesting Depth)&lt;/strong&gt;라고 합니다. 중첩 깊이는 X를 참조하는 부프로그램의 정적 깊이와 X가 선언된 부프로그램의 정적 깊이의 차이입니다. 중첩 깊이를 &lt;strong&gt;체인 오프셋(Chain Offset)&lt;/strong&gt;이라고도 부릅니다. 실제로 참조할 때는 정수 순서쌍 (체인 오프셋, 지역 오프셋)으로 표시됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 슬라이드에 나온 코드에서는 A - B - C 순서로 중첩이 되어 있습니다. 먼저 각 프로시저의 정적 깊이를 계산해보면, 가장 바깥에 있는 A는 0, B는 1, C는 2로 계산할 수 있습니다. 만약 프로시저 C에서 프로시저 A에 있는 비지역 변수를 참조하고 싶다면 중첩 깊이를 계산해야 하는데, 이 때의 중첩 깊이는 C의 정적 깊이(2) - A의 정적 깊이(0) = 2가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 좀더 복잡한 프로그램을 가지고 참조를 위한 깊이를 계산해 보겠습니다. 이 프로그램은 MAIN_2라는 주프로그램에서 부프로그램 BIGSUB를 호출하고, BIGSUB는 SUB2 부프로그램을 호출합니다. SUB2는 SUB3 부프로그램을 호출하고, SUB3은 SUB1 부프로그램을 호출합니다. 그러나 프로그램의 구조는 호출과 일치하지 않음을 주의해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;먼저 SUB1의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A := B + C;&lt;/code&gt; 지점에서 A, B, C를 접근하기 위한 중첩 깊이를 계산해보겠습니다. A는 SUB1 내에서 정의되어 있기 때문에 당연히 0이 됩니다. B와 C는 바로 위의 BIGSUB에서 정의되어 있기 때문에 1이 됨을 쉽게 계산할 수 있습니다. 그리고 이들의 지역 오프셋을 계산하기 위해서는 활성화 레코드를 먼저 계산해야 합니다. 활성화 레코드를 계산하는 방법은 이전에 설명했기 때문에 생략하겠습니다. 활성화 레코드의 0, 1, 2는 각각 동적 링크, 정적 링크, 반환 주소를 저장하기 때문에 지역 변수는 그 다음부터 저장됩니다. BIGSUB는 A, B, C 순서대로 저장되었기 때문에 각각 3, 4, 5에 저장됨을 알 수 있습니다. 따라서 A의 참조쌍은 (0, 3), B의 참조쌍은 (1, 4), C의 참조쌍은 (1, 5)가 됨을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;마찬가지로 SUB3의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E := B + A;&lt;/code&gt; 지점에서 E, B, A의 참조쌍을 계산해보겠습니다. E는 SUB3의 지역 변수이기 때문에 중첩 깊이가 0이 됩니다. B는 SUB2의 B를 참조하기 때문에 중첩 깊이가 1이 됩니다. A는 BIGSUB의 A를 참조하기 때문에 중첩 깊이가 2가 됩니다. 이제 지역 오프셋을 계산해보면, SUB3은 지역 변수로 C, E를 갖고 있습니다. 따라서 C의 지역 오프셋이 3, E의 지역 오프셋이 4가 됩니다. SUB2는 지역 변수로 B, E를 가지고 있으므로 B의 지역 오프셋은 3, BIGSUB는 지역 변수로 A, B, C를 가지고 있기 때문에 지역 오프셋은 3이 됩니다. 따라서 E의 참조쌍은 (0, 4), B는 (1, 3), A는 (2, 3)이 됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로 SUB2의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A := D + E;&lt;/code&gt; 지점에서 A, D, E의 참조쌍을 계산해보겠습니다. A는 BIGSUB의 A를 참조하므로 참조쌍이 (1, 3)이 됩니다. 그런데 D는 SUB2의 상위 프로시저인 BIGSUB에 선언되어 있지 않고, 그보다 상위 프로시저인 MAIN_2에도 선언되어 있지 않습니다. 따라서 D는 선언되어 있지 않은 변수이므로 Error가 발생합니다. E는 SUB2의 지역 변수이므로 (0, 4)가 됨을 쉽게 계산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전 슬라이드에 제시된 프로그램의 구조를 토대로 활성화 레코드를 나타낸 모습입니다. 이 그림의 핵심은 정적 링크과 동적 링크가 어떻게 연결되어 있는지 입니다. 정적 링크는 프로그램 구조상으로 자신의 상위 프로시저를 가리킵니다. 예를 들어, BIGSUB의 정적 링크는 MAIN_2를 가리키고, SUB2의 정적 링크는 BIGSUB를 가리키는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;동적 링크는 자신을 호출한 프로시저를 가리킵니다. 예를 들어, SUB1의 동적 링크는 SUB3을 가리키고, SUB3의 동적 링크는 SUB2를 가리킵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면, 프로그램 실행 중에 정적 체인이 어떻게 유지되는 것일까요? 정적 체인은 부프로그램이 호출되거나 반환될 때마다 변경되므로, 그 때마다 수정되어야 합니다. 부프로그램이 종료될 때는 해당 부프로그램의 활성화 레코드가 스택에서 제거되는데, 그 활성화 레코드가 가리키는 포인터는, 활성화 레코드가 제거될 때 같이 해제되므로 신경을 쓸 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;그러나 새로운 부프로그램이 호출될 때는 문제가 복잡해집니다. 정확한 자신의 상위 프로시저를 컴파일 시간에 알 수 있다고 하더라도, 호출 시에는 그 상위 프로시저의 활성화 레코드가 스택 어디에 있을지는 모르기 때문입니다. 이 문제를 해결하는데는 두 가지 방법이 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;첫 번째 방법은 실행 시간에 상위 영역의 첫 번째 항목을 찾을 때까지 동적 체인의 활성화 레코드를 탐색하는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;두 번째 방법은 컴파일 시간에 호출자와 호출된 프로그램을 선언한 프로시저 사이의 중첩 깊이를 계산하고, 호출이 발생할 때, 호출된 프로시저의 활성화 레코드의 정적 링크를 호출자의 정적 체인에서 컴파일러 시간에 계산된 중첩 깊이와 동일한 링크 수 만큼 이동하여 결정하는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두 번째 방법에 대해 좀 더 자세히 설명하자면, 이전 슬라이드의 스택 상황에서 SUB3이 SUB1을 호출하는 때를 생각해봅시다. 컴파일러는 SUB3의 중첩 깊이가 SUB1을 선언한 프로시저인 BIGSUB의 2단계 안쪽이라는 것을 알 수 있습니다. 따라서 SUB3이 SUB1을 호출할 때, 활성화 레코드에서 정적 체인의 두 번째 링크가 가리키는 활성화 레코드를 가리키도록 설정하는 것입니다. (SUB3 -&amp;gt; SUB2 -&amp;gt; BIGSUB) 따라서 SUB1의 활성화 레코드에서 정적 링크는 BIGSUB를 가리키도록 설정되는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정적 체인의 단점은 비지역 변수에 참조하는 비용이 지역 변수의 참조보다 크다는 것입니다. 비지역 변수를 참조할 때마다 해당 변수가 선언이 된 영역을 찾기 위해서 정적 체인의 링크를 따라가야합니다. 해당 비지역 변수가 현재 위치에서 멀면 멀 수록 그 링크를 많이 따라가야 합니다. 다행히 실제 그렇게까지 먼 비지역 변수를 참조하는 경우는 드물지만, 정적 체인의 진짜 단점은 &lt;strong&gt;시간이 중요한 프로그램(Time Critical Program)&lt;/strong&gt;을 작업하는 경우 프로그래머가 비지역 변수를 참조할 때 그 비용을 추정하는 것이 어렵다는 것입니다. 왜냐하면 각각의 참조의 비용은 중첩 깊이에 따라 달라지기 때문입니다. 코드가 수정될 때마다 중첩의 깊이가 변화할 수 있고, 그로 인해 코드를 변경하기 전과 변경한 후의 시간이 얼마나 차이가 날지 계산하기 어려워지는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;정적 체인의 대안 중 하나는 &lt;strong&gt;디스플레이(Display)&lt;/strong&gt;입니다. 이 방법은 정적 링크를 활성화 레코드에 저장하지 않고, 디스플레이라는 단일 배열에 저장합니다. 특정 시간에서 디스플레이의 내용은 접근 가능한 활성화 레코드 인스턴스의 주소 목록입니다. 이것은 각각의 활성 범위에 대해 하나씩 나타나며, 중첩된 순서대로 표시됩니다.&lt;/p&gt;

&lt;p&gt;비지역 변수의 참조 쌍은 (디스플레이 오프셋, 지역 오프셋)으로 표현합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디스플레이에 저장된 활성화 레코드에 대한 링크는 디스플레이 오프셋이라는 정적으로 계산된 값을 사용하여 찾습니다. 활성화 레코드 내의 지역 오프셋은 정적 체인에서와 동일한 용도로 사용됩니다. 일반적으로 디스플레이에서 $k$라는 위치에 있는 포인터는 정적 깊이가 $k$인 프로시저에 대한 활성화 레코드를 가리킵니다.&lt;/p&gt;

&lt;p&gt;만약 새로운 프로시저가 호출되거나 기존의 프로시저가 종료될 때 디스플레이를 수정해야 한다면 다음과 같은 과정이 발생합니다. 정적 길이가 $k$인 프로시저 P의 호출이 발생할 때, 새 활성화 레코드에 디스플레이 $k$ 위치에 있는 포인터 복사본을 저장합니다. 그리고 디스플레이에서 $k$ 위치에 P의 활성화 레코드에 대한 링크를 배치합니다. 프로시저 종료 시, 종료된 부프로그램의 활성화 레코드에 저장된 포인터가 디스플레이에 다시 배치됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디스플레이를 이해하기 위해 예제를 하나 풀어보겠습니다. 프로시저 Q가 프로시저 P를 호출하는 상황이라고 가정해봅시다. Psd를 P의 정적 깊이, Qsd를 Q의 정적 깊이라고 정의하겠습니다. 그렇다면 가능한 경우는 1) Qsd = Psd, 2) Qsd &amp;lt; Psd, 3) Qsd &amp;gt; Psd 이렇게 3가지가 나오게 됩니다.&lt;/p&gt;

&lt;p&gt;프로그램 구조는 슬라이드 왼쪽에 나와있는 것으로 가정하겠습니다. 먼저 SUB2에서 SUB1을 호출할 때, 이 두 프로시저는 같은 정적 깊이를 갖는 경우입니다. 그렇다면 디스플레이 0번째 인덱스는 정적 깊이가 0인 MAIN_3을 가리키게 되고, 1번째 인덱스는 정적 깊이가 1인 BIGSUB를 가리키게 됩니다. SUB1을 호출하기 전에는 2번째 인덱스는 정적 깊이가 2인 SUB2를 가리키고 있습니다. 그런데 이 상황에서 SUB1을 호출한다면, SUB1은 SUB2와 마찬가지로 정적 깊이가 2이므로, 디스플레이의 2번째 인덱스가 SUB1을 가리키도록 수정됩니다.&lt;/p&gt;

&lt;p&gt;두 번째는 SUB2가 SUB3을 호출하는 상황을 확인해보겠습니다. 이 경우에는 SUB3의 정적 깊이가 SUB2보다 깊은 경우입니다. 이 경우는 너무 간단합니다. 그냥 디스플레이의 다음 인덱스가 새로 호출된 SUB3을 가리키도록 설정하면 끝나기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 프로그램 구조를 조금 바꾸었습니다. 호출 순서는 MAIN_4 -&amp;gt; BIGSUB -&amp;gt; SUB2 -&amp;gt; SUB3 -&amp;gt; SUB1 -&amp;gt; SUB4 입니다. SUB3이 호출될 때 까지는 이전의 상황과 마찬가지이므로 전혀 문제가 없습니다. 문제는 SUB1이 호출될 때부터 시작됩니다. SUB1은 SUB3보다 정적 깊이가 낮은 프로시저입니다. 따라서 디스플레이의 2번째 인덱스는 SUB1을 가리키게 됩니다. 문제는 2번째 인덱스가 스택의 가장 윗부분을 가리키게 된다는 것입니다. 따라서 디스플레이의 3번째 인덱스가 SUB3을 가리키고 있을 지라도, 컴파일러는 이것을 비활성된 것으로 인식합니다.&lt;/p&gt;

&lt;p&gt;이후에 SUB4가 호출될 때는 이전과 동일합니다. SUB4는 SUB1보다 정적 깊이가 깊은 곳에 위치해있기 때문에, 디스플레이의 3번째 인덱스가 SUB4를 가리키게 설정하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 SUB1만 호출되고 끝나는 상황이라고 가정해봅시다. 이전 슬라이드에서는 SUB1이 호출될 때 문제가 생겼었지만, 결국 SUB4로 인해 최종 디스플레이 배열은 문제가 없이 생성되었습니다. 그러나 이제는 SUB1이 선언되고 끝났기 때문에, 디스플레이의 3번째 인덱스가 SUB3을 가리키고 있음에도 이것이 활성화되지 않는 문제가 발생합니다. 하지만 정적 영역 언어를 기준으로 보았을 때, SUB1에서 SUB3의 지역 변수를 참조할 수 없으니 이것은 옮게 된 비활성화입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그럼 디스플레이를 구현하는 방법이 어떻게 되는지 알아보겠습니다. 먼저 디스플레이 배열의 크기를 정하는 것은 간단합니다. 컴파일러가 부프로그램에 대한 최대 정적 깊이를 알 수 있기 때문입니다. 따라서 디스플레이 배열은 실행 시간에 정적 배열로 메모리에 저장됩니다. 만약 컴퓨터가 메모리 위치에 따른 간접 주소 지정을 하는 경우, 비지역 접근은 지역 접근보다 메모리 사이클이 한 단계 증가합니다. 만약 디스플레이 배열을 레지스터에 위치시킨다면 추가적인 메모리 사이클이 필요하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정적 체인과 디스플레이를 비교해보겠습니다. 속도 면에서 보자면, 정적 수준이 한 단계 차이가 나는 경우 정적 체인이 디스플레이보다 빠릅니다. 왜냐하면 디스플레이가 레지스터에 저장되는 경우가 아니라면 간접 주소 지정을 통해 접근을 하게 되는데, 이 경우 비지역 변수에 대한 참조 과정이 한 단계 증가하기 때문입니다.&lt;/p&gt;

&lt;p&gt;그러나 두 단계 이상의 정적 수준에 있는 비지역 변수에 대한 참조는 정적 체인보다 빠릅니다. 정적 체인은 정적 수준의 깊이가 증가할수록 속도가 느려지지만, 디스플레이는 모든 단계의 비지역 변수 참조 속도가 동일하기 때문입니다.&lt;/p&gt;

&lt;p&gt;전체적으로 비교하자면, 정적 수준이 깊은 비지역 변수에 대한 참조가 많은 경우에는 디스플레이가 더 좋고, 그렇지 않은 경우에는 정적 체인이 더 좋습니다. 그리고 사실 일반적으로 정적 수준이 깊은 비지역 변수를 참조하는 일은 생각보다 많지 않기 때문에, 정적 체인이 더 좋다고 말할 수 있습니다. 사실 일반적인 정적 중첩은 3보다 작습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5장에서 C 기반 언어들은 &lt;span style=&quot;color:red&quot;&gt;블록(Block)&lt;/span&gt;라는 지역 영역을 선언할 수 있다고 배웠습니다. 블록은 &lt;strong&gt;복합문(Compound Statement)&lt;/strong&gt;과 &lt;strong&gt;데이터 정의(Data Declaration)&lt;/strong&gt;이 결합된 구조입니다. 여기에서는 블록의 구현 방법에 대해서만 논의하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;첫 번째 구현 방법은 블록을 매개변수가 없는 부프로그램으로 취급을 하는 것입니다. 이 경우 직전에 배운 정적 체인이나 디스플레이를 이용하여 간단하게 구현할 수 있습니다. 물론 블록을 부프로그램으로 취급을 하게 되면 그 만큼 정적 중첩이 더 많이 쌓이고, 그로 인해 디스플레이의 경우에는 배열의 사이즈가 커지는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;두 번째 방법은 블록 변수에 필요한 공간을 활성화 레코드에 같이 할당하는 것입니다. 이것은 블록 변수를 위해 요구되는 기억 장소가 정적으로 계산될 수 있기 때문에 사용할 수 있는 방법입니다. 이 방법을 사용할 경우, 일반적으로 블록 변수를 지역 변수 다음 위치에 배치합니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 나온 코드에서는 b, g가 차지하는 영역과 a, f가 차지하는 영역이 서로 중복되어 있습니다. 이것은 a, b, c를 가지고 있는 블록은 f, g가 있는 블록 시점에서는 이미 종료되었기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로는 동적 영역을 구현하는 방법에 대해 알아보겠습니다. 동적 영역을 구현하는 방법은 크게 &lt;strong&gt;깊은 접근(Deep Access)&lt;/strong&gt;과 &lt;strong&gt;얕은 접근(Shallow Access)&lt;/strong&gt;이 있습니다. 주의할 점은 이것들이 이전에 배웠던 깊은 바인딩과 얕은 바인딩과는 전혀 다른 이야기라는 것입니다.&lt;/p&gt;

&lt;p&gt;동적 영역에서 지역 변수가 스택 동적 변수이고 활성화 레코드에 포함되어 있다면, 비지역 변수의 참조는 가장 최근에 활성화된 부프로그램부터 시작해서 현재 활성화 중인 다른 부프로그램의 활성화 레코드를 탐색하면서 해결할 수 있습니다. 이 개념은 정적 체인 대신 동적 체인을 사용한다는 것만 제외하면 정적 영역에서 비지역 변수에 접근하는 것과 유사합니다. 동적 체인은 활성화된 역순으로 스택을 탐험하는데, 스택의 가장 위부터 아래로 탐색해나가기 때문에 이 방법을 깊은 접근이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;정적 영역과는 달리, 동적 영역 언어에서는 접근에 필요한 체인의 길이를 컴파일 타임에 결정할 수 있는 방법이 없습니다. 그렇기 때문에 동적 영역 언어는 정적 영역 언어보다 속도가 느립니다. 게다가 정적 영역 언어에서는 변수의 이름을 저장하지 않고 값만 저장해도 상관이 없었지만, 동적 영역 언어를 구현할 때는 활성화 레코드에 검색을 위해 변수 이름을 저장해두어야 합니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 나온 코드 예제는 가장 최근에 활성화된 부프로그램인 C에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x := u + v;&lt;/code&gt; 명령어를 수행하려고 합니다. 이 때, 변수 x는 C의 지역 변수이기 때문에 탐색이 필요 없습니다. 그러나 u와 v는 C의 지역 변수가 아니기 때문에 활성화 레코드를 탐색해야 합니다. 활성화 레코드 스택을 보면 C 이전에 활성화된 부프로그램은 B입니다. B에 u와 v가 저장되어 있는지 확인해야 하는데, 이것을 위해서는 변수 이름을 비교해보아야 합니다. B에도 u와 v가 없으니 계속 링크를 타고 올라가야 하고, 변수의 이름을 비교해보면서 u와 v를 찾는 과정을 반복합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/010/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 동적 영역을 구현하는 두 번째 방법인 얕은 접근입니다. 얕은 접근 방법에서는 부프로그램의 지역 변수가 활성화 레코드에 포함되어 있지 않습니다. 이 방법은 전체 프로그램에서 각각의 변수에 따라 개별적인 스택을 갖습니다. 만약 부프로그램이 활성화될 때 새로운 이름의 변수가 선언된다면, 그 이름으로 새로운 스택이 생성됩니다. 만약 기존에 있는 변수라면, 부프로그램의 이름에 해당하는 셀이 그 값과 함께 스택에 추가됩니다. 동적 영역 언어에서 비지역 변수에 접근할 때는 가장 최근에 활성화된 부프로그램의 변수를 가지게 되는데, 얕은 접근의 구조상 각 변수의 스택에 가장 위에 있는 셀은 가장 최근에 활성화된 부프로그램의 변수입니다. 즉, 비지역 변수에 접근할 때는 항상 스택의 맨 위에 있는 셀을 참조하면 됩니다.&lt;/p&gt;

&lt;p&gt;얕은 접근 방법은 그 구조에서 예상할 수 있다시피 비지역 변수에 대한 참조는 매우 빠릅니다. 그러나 부프로그램에 진입하거나 종료할 때마다 변수에 대한 스택이 변동되므로, 스택을 유지하는 비용이 크다는 단점이 있습니다. 슬라이드에 나온 스택 그림은 이전 슬라이드에서의 깊은 접근에서 다루었던 예제 코드와 동일한 코드를 사용했을 때를 나타낸 모습입니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 나와있지 않지만 얕은 접근이 구현 방법은 이것 말고도 있습니다. 예를 들어, SNOBOL 언어는 변수에 이름에 하나의 장소를 할당하는 중앙 테이블을 사용하고 있습니다. 각각의 항목은 변수가 현재 어느 부프로그램에 바인딩이 되어 있는지 활성(Active) 비트를 가지고 있습니다. 변수에 접근할 때는 중앙 테이블의 오프셋을 이용합니다. 이 오프셋은 정적이기 때문에 접근이 빠르다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;또한 각 변수의 최신 값만 저장하는 단일 셀을 가지는 테이블을 구현하는 방법도 있습니다. 이 방법은 최소한의 오버헤드만 가진다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;동적 영역 언어를 구현할 때 깊은 접근과 얕은 접근 중 어느 방법을 사용할 지는 부프로그램 호출과 비지역 변수를 참조를 어느 정도로 하는 지에 따라 달려 있습니다. 깊은 접근 방법은 부프로그램이 호출되거나 해제될 때 속도가 빠르지만, 참조에 대한 비용이 크고, 얕은 접근 방법은 그 반대로 참조는 효율적이지만, 부프로그램이 호출되거나 해제될 때 비효율적입니다.&lt;/p&gt;

&lt;p&gt;10장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Subprograms</title><link href="http://localhost:4000/pl/subprograms/" rel="alternate" type="text/html" title="Subprograms" /><published>2023-09-14T00:00:00+09:00</published><updated>2023-09-14T00:00:00+09:00</updated><id>http://localhost:4000/pl/subprograms</id><content type="html" xml:base="http://localhost:4000/pl/subprograms/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;9장의 주제는 부프로그램입니다. 다룰 내용은 부프로그램의 매개변수 전달 방법, 지역 참조 환경, 중복 부프로그램 등이 있습니다. 여기서는 부프로그램에 대해서만 알아보고, 부프로그램을 구현하는 방법은 다음 장에서 자세히 다룰 예정입니다. 이번 장의 핵심 문구는 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“부프로그램은 프로그램의 기본 요소이므로 프로그래밍 언어 설계에서 가장 중요한 개념 중 하나입니다”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로그래밍 언어에 포함되는 기본적인 두 개의 추상화는 프로세스 추상화와 데이터 추상화입니다. 데이터 추상화는 11장에서 다룰 예정이고, 이번 장에서 다룰 부프로그램이 바로 프로세스 추상화에 해당합니다.&lt;/p&gt;

&lt;p&gt;부프로그램의 개념은 배비지(Babbage)의 해석기관에서 유래했습니다. 해석기관은 프로그램이 다양한 장소에서 명령어의 묶음을 재사용하는 능력이 있었는데, 현대 프로그래밍 언어에서는 이를 부프로그램으로 구현하였습니다. 이러한 재사용은 메모리 공간과 코딩 시간을 절약하는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;해당 명령어의 묶음을 &lt;strong&gt;호출(Call)&lt;/strong&gt;하는 명령어를 통해 프로그램에 명령어의 묶음을 배치하는 것은 곧 추상화로 볼 수 있습니다. 왜냐하면 명령어 묶음의 세부 사항이 부프로그램으 호출하는 문장 하나로 대치되기 때문입니다.&lt;/p&gt;

&lt;p&gt;프로시저와 매크로는 비슷하면서도 차이가 있는데, 매크로는 함수 호출이나 반환과 같은 오버헤드가 발생하지 않지만 프로그램 길이가 길어질 수 있는 문제가 있습니다. 짧은 코드라면 매크로가 유리하지만, 긴 코드라면 프로시저를 이용하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 부프로그램의 기초부터 알아보겠습니다. 일반적인 부프로그램의 특성은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각각의 부프로그램은 단일 진입점을 갖는다.&lt;/li&gt;
  &lt;li&gt;호출 프로그램 단위는 호출된 부프로그램이 실행되는 동안 일시중지된다. 즉, 주어진 시간 동안 실행 중인 부프로그램은 1개만 존재한다.&lt;/li&gt;
  &lt;li&gt;부프로그램 실행이 종료되면 제어가 항상 호출한 프로그램으로 돌아간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 가정은 &lt;strong&gt;코루틴(Coroutine)&lt;/strong&gt;과 &lt;strong&gt;동시성(Concurrency)&lt;/strong&gt;에서 예외가 있습니다만, 이것은 해당 장에서 구체적으로 다루겠습니다.&lt;/p&gt;

&lt;p&gt;부프로그램의 정의는 부프로그램 추상화의 인터페이스와 동작을 서술하는 것입니다. &lt;strong&gt;부프로그램 호출(Subprogram Call)&lt;/strong&gt;은 부프로그램이 실행되도록 명시적으로 요청하는 것이고, 부프로그램이 호출된 후 실행을 시작했지만 아직 끝나지 않은 경우에는 &lt;strong&gt;활성화(Actice)&lt;/strong&gt;되었다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;부프로그램 헤더(Subprogram Header)&lt;/strong&gt;는 첫 줄에 선언되는 부프로그램의 정의입니다. 이것은 부프로그램 이름과 함께 매개변수 목록을 지정하는데 사용합니다.&lt;/p&gt;

&lt;p&gt;Fortran 언어에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUBROUTINE&lt;/code&gt; 이라는 명령어를 사용하여 헤더를 정의하고, Ada 언어에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;procedure ~ is&lt;/code&gt; 명령어를 이용하여 헤더를 정의합니다. 함수는 값을 반환하고 프로시저는 명령어를 실행하는 차이가 있지만, C 언어는 함수(Function)라는 한 종류의 부프로그램만 있습니다. 대신 헤더를 보고 그 함수가 값을 반환하는지 안하는지를 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램이 데이터에 접근할 수 있는 방법은 두 가지가 있습니다. 하나는 비지역 변수로의 직접적인 접근과, 나머지 하나는 함수의 매개변수를 통해 접근하는 방법입니다. 비지역 변수를 통한 접근은 프로그램의 신뢰성을 감소시키기 때문에 매개변수를 통해 데이터를 전달하는 방법이 권장됩니다.&lt;/p&gt;

&lt;p&gt;어떤 상황에서는 부프로그램의 매개변수로 데이터가 아닌 계산이 전달되는 것이 편리합니다. 이런 경우에는 계산을 구현하는 부프로그램의 이름이 매개변수로 사용됩니다. 이것은 나중에 9.6절에서 더 자세히 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;매개변수는 &lt;strong&gt;형식 매개변수(Formal Parameter)&lt;/strong&gt;와 &lt;strong&gt;실 매개변수(Actual Parameter)&lt;/strong&gt;로 나눌 수 있습니다. 형식 매개변수는 부프로그램 머리부에서 선언되는 매개변수입니다. 이 변수는 일반적인 의미의 변수가 아니기 때문에 독립 변수로 간주됩니다. 이런 변수들은 보통 부프로그램이 호출될 때만 기억장소에 바인딩되고, 이 바인딩도 다른 프로그램 변수를 통해 이루어집니다. 부프로그램의 형식 매개변수에 바인딩되는 부프로그램 호출의 매개변수를 실 매개변수라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;매개변수를 전달할 때, 매개변수의 위치에 따라 실 매개변수를 형식 매개변수에 바인딩하는 방법을 &lt;strong&gt;위치 매개변수(Positional Parameter)&lt;/strong&gt;라고 합니다. 매개변수 리스트가 짧은 경우에는 이 방법이 효율적이고 안전한 방법입니다,&lt;/p&gt;

&lt;p&gt;만약 매개변수 리스트가 길다면 프로그래머는 매개변수를 작성하는 도중 오류를 범할 가능성이 높습니다. 이 문제를 해결하는 방법은 &lt;strong&gt;키워드 매개변수(Keyworkd Parameter)&lt;/strong&gt;를 이용하는 것입니다. 키워드 매개변수에서는 실 매개변수가 바인딩될 형식 매개변수의 이름을 함께 호출하는 방식으로 지정합니다. 예를 들어, 슬라이드에 나온 것처럼 Ada 언어에서 LENGTH =&amp;gt; MY_LENGTH와 같이 형식 매개변수 LENGTH에 실 매개변수 MY_LENGTH를 직접 지정해주는 방식입니다. 이 방법의 단점은 프로그래머가 부프로그램의 형식 매개변수의 이름을 반드시 알고 있어야 한다는 것입니다.&lt;/p&gt;

&lt;p&gt;C++ 언어나 Ada에서는 형식 매개변수가 &lt;strong&gt;기본값(Default Value)&lt;/strong&gt;을 가질 수 있습니다. 기본값은 부프로그램을 호출할 때 실 매개변수가 전달되지 않는 경우 사용됩니다. 예를 들어, 슬라이드의 코드와 같이 EXEMPTION의 기본값은 정수 1로 설정되어 있습니다. 만약 이 부프로그램을 호출할 때, 이 매개변수가 생략된다면 자동으로 1이 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;형식 매개변수의 기본값을 지원하지 않는 경우, 호출의 실 매개변수의 수는 반드시 부프로그램 헤더에서 정의한 형식 매개변수의 수와 일치해야 합니다. 그러나 C 언어는 이것이 필수가 아닙니다. 예를 들어, C 언어의 printf 함수는 가변 개수의 매개변수를 허용하기 때문에 임의의 개수의 항목을 출력합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램은 &lt;span style=&quot;color:red&quot;&gt;프로시저(Procedure)&lt;/span&gt;와 &lt;span style=&quot;color:red&quot;&gt;함수(Function)&lt;/span&gt;로 나눌 수 있습니다. 이 둘의 가장 큰 차이는 반환값이 있느냐 없느냐의 여부입니다. 프로시저는 값을 반환하지 않지만, 함수는 값을 반환합니다. 이 두 역할이 명백하게 구분되어 있는 언어도 있지만, C 언어는 함수 한 가지만 존재하는 대신 함수에 반환값을 설정하지 않아서 프로시저처럼 사용할 수 있게 구현되어 있습니다.&lt;/p&gt;

&lt;p&gt;프로시저는 매개변수화된 계산을 정의하는 명령문의 모음입니다. 프로시저는 값을 반환하지 않기 때문에 호출자에게 결과를 전달할 수 있는 방법이 매우 제한되는데, 대표적인 방법이 프로시저 내에서 보이는 변수를 변경하거나, 호출자에게 데이터 전달을 허용하는 형식 매개변수를 갖는다면 그것을 변경시키는 방법입니다.&lt;/p&gt;

&lt;p&gt;함수는 요구되는 실 매개변수와 함께 표현식에서 이름으로 나타남으로써 호출됩니다. 함수에 의해 생성된 값은 효율적으로 호출을 대체하면서 호출 코드로 반환됩니다. 함수를 통해 새로운 사용자 정의 연산을 정의할 수 있습니다. 예를 들어서, 어떤 언어가 지수 연산자를 갖지 않는다면 이를 수행하는 함수를 만들 수 있습니다. Fortran와 같은 언어에서는 지수 연산을 지원하기 때문에 굳이 이것을 함수로 구현할 필요가 없습니다. 대부분의 언어에서는 프로그래머가 새로운 함수를 정의함으로써 연산자를 중복하는 것을 허용하는데, 이것은 9.12 절에서 자세하게 다루겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램은 프로그래밍 언어에서 복잡한 구조를 갖고 있기 때문에 그만큼 설계에 고려할 사항이 많습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;매개변수의 전달 방법은 무엇을 사용할 것인가?&lt;/li&gt;
  &lt;li&gt;형식 매개변수의 타입과 실 매개변수의 타입에 대해 타입 검사를 수행할 것인가?&lt;/li&gt;
  &lt;li&gt;지역 변수는 정적으로 할당되는가, 동적으로 할당되는가?&lt;/li&gt;
  &lt;li&gt;매개변수로 전달된 부프로그램의 참조 환경은 무엇인가?&lt;/li&gt;
  &lt;li&gt;부프로그램을 매개변수로 전달할 수 있는 경우, 전달된 부프로그램에 대한 호출에서 매개변수 타입을 검사하는가?&lt;/li&gt;
  &lt;li&gt;부프로그램이 오버로딩 될 수 있는가?&lt;/li&gt;
  &lt;li&gt;부프로그램이 제네릭일 수 있는가?&lt;/li&gt;
  &lt;li&gt;부프로그램이 분리된 컴파일, 또는 독립적인 컴파일이 가능한가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램 내에서 선언된 변수를 &lt;span style=&quot;color:red&quot;&gt;지역 변수(Local Variable)&lt;/span&gt;이라고 합니다. 지역 변수에 대한 접근은 일반적으로 해당 변수가 선언된 부프로그램으로 제한됩니다. 5장에서 다룬대로, 지역 변수는 &lt;strong&gt;정적(Static)&lt;/strong&gt;이거나 &lt;strong&gt;스택 동적(Stack Dyanmic)&lt;/strong&gt;입니다. 지역 변수가 스택 동적이라면, 지역 변수는 부프로그램이 실행을 시작할 때 기억공간에 바인딩되고, 실행이 종료되면 저장소에서 해제됩니다.&lt;/p&gt;

&lt;p&gt;스택 동적 지역 변수의 장점은 유연성입니다. 특히, 재귀적 부프로그램을 만들기 위해서는 스택 동적 변수가 필수적입니다. 그 외의 장점은 활성 부프로그램에 있는 지역 변수의 기억 장소가 다른 모든 비활성 부프로그램의 지역 변수와 같은 공간을 공유하므로 저장공간을 아낄 수 있다는 것이지만, 기억공간이 충분히 늘어난 지금은 큰 장점이라고 보진 않습니다.&lt;/p&gt;

&lt;p&gt;스택 동적 지역 변수의 단점은 부프로그램이 호출될 때마다 지역 변수를 할당, 초기화, 해제하는 시간이 소모된다는 것입니다. 또한 간접 주소 방식을 통해 기억 공간에 접근하므로 접근 속도가 느리다는 단점이 있습니다. 또한 &lt;strong&gt;과거 민감형(History-sensitive)&lt;/strong&gt;이 아니므로 호출 사이에 지역 변수에 데이터 값을 유지할 수 없다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반대로 정적 지역 변수를 사용한다면 매우 효율적이라는 장점이 있습니다. 기본적으로 프로그램이 실행될 때 저장공간에 바인딩되기 때문에 할당이나 해제에 실행 시간 부담이 없고, 접근이 빠르며 과거 민감형 부프로그램을 허용한다는 것입니다. 그러나 재귀를 허용하지 않고 기억공간을 다른 비활성 부프로그램의 변수들과 공유할 수 없다는 단점도 있습니다.&lt;/p&gt;

&lt;p&gt;ALGOL 60과 그 후속 언어들에서 지역 변수는 기본적으로 스택 동적으로 구현되어 있습니다. 그러나 C 언어 같은 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt; 이라는 명령어를 이용하여 정적 변수로 선언할 수 있는 옵션을 제공합니다. Fortran 77의 경우에는 재귀가 없기 때문에 모든 지역 변수가 정적 지역 변수입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 이번 장에서 가장 중요한 매개변수 전달 방법에 대해 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;형식 매개변수는 3개의 의미적 모델 중 하나로 결정됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;형식 매개변수가 해당 실 매개변수로부터 데이터를 받는다. &lt;strong&gt;(in mode)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;형식 매개변수가 데이터를 실 매개변수에 전달한다. &lt;strong&gt;(out mode)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;형식 매개변수가 실 매개변수로부터 데이터를 받고, 반대로 데이터를 실 매개변수에 전달한다. &lt;strong&gt;(inout mode)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데이터 이동이 매개변수 전달에서 일어나는 방법은 두 가지 개념적인 모델이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실제 값이 물리적으로 이동된다.&lt;/li&gt;
  &lt;li&gt;접근 경로(포인터나 참조)가 이동한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세 가지의 기본 매개변수 전달 모드의 구현을 위해, 다양한 모델이 언어 설계자에 의해 개발되었습니다. 여기서 소개하는 것은 그 중 많이 고려되는 5가지의 매개변수 전달 모델을 소개합니다.&lt;/p&gt;

&lt;p&gt;첫 번째 모델은 매개변수를 값으로 전달하는 &lt;span style=&quot;color:red&quot;&gt;Pass by Value&lt;/span&gt; 입니다. Pass by Value에서 실 매개변수의 값은 해당 형식 매개변수를 초기화하는데 사용되며, 이 매개변수는 부프로그램에서 지역 변수로 간주됩니다. 따라서, Pass by Value는 in mode의 의미가 구현된 것으로 볼 수 있습니다. Pass by Value는 보통 데이터를 복사하는 것으로 구현합니다. 왜냐하면 Pass by Value에서 실 매개변수가 가지고 있는 값은 쓰기로부터 보호가 되어야 하기 때문입니다. 따라서 매개변수가 배열과 같이 큰 개체인 경우에는 이것을 기억공간에 복사하는데 많은 비용이 들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 번째 모델은 out mode의 의미를 구현한 &lt;span style=&quot;color:red&quot;&gt;Pass by Result&lt;/span&gt; 입니다. 매개변수가 전달될 때, 어떠한 값도 부프로그램에 전달되지 않습니다. 이 때 매개변수는 지억 변수로 작동하긴 하지만, 제어가 호출자에게 반환되기 직전에 그 값이 호출자의 실 매개변수에 전달됩니다. Pass by Result도 Pass by Value의 단점을 그대로 갖는데, 실 매개변수로 전달되는 것도 데이터가 복사되어 전달되는 것이기 때문에 추가적인 기억공간이 필요하다는 것입니다.&lt;/p&gt;

&lt;p&gt;그런데 Pass by Result는 실 매개변수의 충돌과 같은 추가적인 문제점도 가지고 있습니다. 예를 들어, 슬라이드의 코드와 같이 sub 라는 부프로그램은 x와 y라는 두 가지 형식 매개변수를 가지고 있습니다. 부프로그램 내에서 x에는 3, y에는 5가 배정됩니다. 그런데 main()에서 sub를 호출할 때 실 매개변수로 모두 p1이 들어갑니다. 이 때, 함수 호출이 끝나고 p1에는 어떤 값이 들어가야 할까요? 이 상황에서는 나중에 실 매개변수에 배정되는 것이 p1의 값이 됩니다. (즉, 실 매개변수에 값이 복사되는 순서)&lt;/p&gt;

&lt;p&gt;Pass by Result의 또 다른 문제는 구현자가 실 매개변수의 주소를 평가하기 위해 두 개의 다른 시점(호출 시, 복귀 시) 중에서 하나를 선택할 수 있다는 것입니다. 슬라이드 아래쪽에 있는 코드를 보면 list[index]의 주소가 부프로그램 중간에서 변경됩니다. 만약 주소가 부프로그램 진입 시 바인딩된다면 list[3]에 3이 반환될 것입니다. 그런데 반환 바로 전에 바인딩된다면 list[5]에 3이 반환될 것 입니다. 이것은 언어의 구현에 따라 다르기 때문에, 똑같이 Pass by Result를 선택한 언어 사이에도 이식하는 것을 어렵게 만듭니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;Pass by Value Result&lt;/span&gt;는 Pass by Value와 Pass by Result를 결합하여 inout mode를 구현한 것입니다. 실 매개변수의 값은 해당 형식 매개변수를 초기화하는데 사용되며, 그 후 지역 변수로써 사용됩니다. 또한 부프로그램 종료 시 형식 매개변수의 값이 실 매개변수로 다시 복사됩니다. 이 과정은 실 매개변수 -&amp;gt; 형식 매개변수의 복사와 형식 매개변수 -&amp;gt; 실 매개변수의 복사가 이루어지는 방식이기 때문에 &lt;strong&gt;Pass by Copy&lt;/strong&gt;라고 부르기도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;Pass by Reference&lt;/span&gt;는 또 다른 inout mode를 구현한 모델입니다. 그러나 이전 모델들처럼 데이터 값을 복사하는 것 대신에 접근 경로(일반적으로 주소)를 전송합니다. 따라서 부프로그램이 호출자의 실 매개변수에 접근하는 것을 허용합니다. Pass by Reference의 장점은 전달 과정이 시간과 기억공간적 관점에서 효율적이라는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러나 Pass by Reference에도 단점은 존재합니다. 첫 번째 단점은 형식 매개변수에 접근할 때 한 단계 더 많은 간접 주소를 사용하기 때문에 형식 매개변수에 접근할 때 더 느릴 수 있습니다. 두 번째 단점은 프로그래머의 실수로 인해 잘못된 값이 실 매개변수에 적용될 수 있습니다. 하지만 이 두 가지 단점보다 더 큰 세 번째 단점은 &lt;strong&gt;별칭(Alias)&lt;/strong&gt;를 만들 수 있다는 것입니다. 이것은 Pass by Reference가 부프로그램이 호출자에 접근 가능한 경로를 만들기 때문에 비지역 변수를 건드릴 수 있기 때문에 발생합니다. 별칭은 이전 장에서도 설명했었지만 프로그램의 가독성과 신뢰성에 악영향을 미치고, 프로그램 검증을 어렵게 만듭니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 제시된 코드를 통해 어떤 식으로 Pass by Reference에서 별칭이 만들어지는지 확인해 보겠습니다. 왼쪽의 코드에서는 global이 전역 변수로 선언되어있고, local이 smallsub의 형식 매개변수로 선언이 되어 있습니다. 그런데 smallsub를 호출할 때 실 매개변수로 global이 사용되었습니다. 따라서 smallsub 내에서 global과 local은 별칭이 되어 버립니다.&lt;/p&gt;

&lt;p&gt;오른쪽의 코드에서는 sub라는 부프로그램에서 first와 second라는 두 개의 형식 매개변수가 정의되었습니다. 그런데 어쩌다가 sub를 호출할 때 두 매개변수에 모두 실 매개변수로 total을 사용했습니다. 이 경우 sub의 first와 second는 별칭이 되어 버립니다.&lt;/p&gt;

&lt;p&gt;이러한 별칭 문제는 Pass by Reference가 아니라 Pass by Value Result를 사용하면 해결됩니다. 그러나 이 경우에는 별칭 말고도 다른 문제가 발생하기 때문에 설계자가 전달 방법을 신중하게 선택할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;마지막 모델은 &lt;span style=&quot;color:red&quot;&gt;Pass by Name&lt;/span&gt; 입니다. 이 방법도 Pass by Value Result나 Pass by Reference와 같은 inout mode를 구현한 모델입니다. 이 방법은 매개변수가 이름으로 전달될 때, 실 매개변수가 부프로그램에 나타나는 해당 모든 형식 매개변수를 그대로 대체합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지금까지 논의한 방법들은 부프로그램을 호출할 때 형식 매개변수의 값이나 주소에 바인딩되었는데, Pass by Name은 전혀 다른 방법을 사용하여 inout mode를 구현하였습니다. Pass by Name에서 형식 매개변수는 부프로그램 호출 시에 바인딩되지만, 값이나 주소의 실제 바인딩은 형식 매개변수에 값이 배정되거나 참조될 때까지 연기됩니다. (늦은 바인딩)&lt;/p&gt;

&lt;p&gt;Pass by Name의 구현은 매우 어려운데, 실 매개변수의 타입에 따라 구현 방법이 결정되기 때문입니다. 예를 들어, 변수를 전달할 때는 Pass by Reference와 같은 방법을 사용하고, 상수를 전달할 때는 Pass by Value와 같은 방법을 사용합니다. 배열을 전달할 때가 매우 골치아픈데, 이 때는 형식 매개변수를 참조할 때마다 변경될 수 있습니다. 예를 들어, 슬라이드 내에 있는 코드를 확인해봅시다. LIST는 2개의 원소가 있는 배열로 정의가 되었고, GLOBAL은 전역 변수입니다. SUB가 호출되기 전에 GLOBAL에는 1이 배정되므로 SUB가 호출될 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUB(LIST[1])&lt;/code&gt;이 됩니다. SUB 내의 첫 명령어인 PARAM 에 3을 대입하는 것은 당연히 LIST[1]에 배정됩니다. 그런데 그 다음 줄에는 GLOBAL의 값을 1 증가시키는 명령어가 있습니다. Pass by Name은 형식 매개변수가 참조될 때마다 변경되므로, 다음 줄의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PARAM := 5&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIST[2] := 5&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pass by Name에서 발생하는 또 다른 문제를 알아봅시다. 왼쪽 코드를 보시면 swap이라는 프로시저가 있습니다. 이 프로시저는 FIRST와 SECOND를 매개변수로 받아 두 개의 값을 서로 교환하는 작업을 수행합니다. 만약 오른쪽의 윗부분 예시처럼, KK, II라는 두 개의 정수가 매개변수로 들어온다면 문제없이 수행됩니다. 그런데 만약 그 아래의 코드처럼 I와 A[I]가 매개변수로 들어오면 어떻게 될까요? I에 A[I]값이 먼저 삽입되기 때문에, A[I]에 TEMP의 값이 들어가는 것이 아니라 A[A[I]]에 TEMP의 값이 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;Pass by Name은 높은 유연성을 가지지만, 그로 인해 프로세스 속도가 느리고, 구현이 어려우며, 프로그램의 가독성과 신뢰성을 낮추는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;Jensen’s Devices&lt;/span&gt;는 Pass by Name을 활용하여 하나의 프로시저를 다양한 목적으로 사용하기 위한 방법입니다. 식과 식에 나타나는 한 개 이상의 변수를 매개변수로 부프로그램에 전달하는데, 부프로그램에서 매개변수의 변수 중 하나가 변경될 때마다 해당 변경으로 인해 형식 매개변수의 값이 변경될 수 있습니다.&lt;/p&gt;

&lt;p&gt;Jensen’s Devices의 대표적인 예는 바로 합을 계산하는 프로시저입니다. 예제 코드에서 나온 SUM 프로시저는 ADDER, INDEX, LENGTH 3개의 매개변수를 받아 INDEX가 LENGTH에 도달할 때까지 TEMPSUM에 ADDER를 더합니다. 이 프로시저는 얼핏 보면 단순하지만, 매개변수에 따라 다양한 계산을 수행할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM(A, I, 100)&lt;/code&gt;으로 호출한 경우, 100 * A 계산을 수행&lt;/li&gt;
  &lt;li&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM(A[I], I, 100)&lt;/code&gt;으로 호출할 경우, 배열 A의 1부터 100까지의 합 계산을 수행&lt;/li&gt;
  &lt;li&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM(A[I] * A[I], I, 100)&lt;/code&gt;으로 호출할 경우, 배열 A 제곱의 1부터 100까지의 합 계산을 수행&lt;/li&gt;
  &lt;li&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM(A[I] * B[I], I, 100)&lt;/code&gt;으로 호출할 경우, 배열 A와 B의 곱을 1부터 100까지의 합 계산을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Jensen’s Devices의 아이디어는 식과 식에 사용된 하나 이상의 변수를 모두 서브루틴에 전달하는 것입니다. ALGOL 60이 대표적으로 Call by Name을 사용하는데, ALGOL 60은 Call by Name을 구현하기 위해 호출자의 참조 환경에서 실 매개변수를 평가하는 숨겨진 서브루틴을 전달하는 방법을 사용했습니다. 이러한 숨겨진 루틴을 일반적으로 &lt;strong&gt;Thunk&lt;/strong&gt;라고 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개별 변수의 값을 변경함으로써, 호출된 루틴은 내장된 표현식의 값을 의도적이고 체계적으로 변경할 수 있습니다. 이러한 장치는 합산 루틴을 작성하는 데 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 사실 Pass by Name을 이렇게 영리하게 사용하는 경우는 매우 드물며, 이러한 방법은 Pass by Name 아닌 다른 매개변수 전달로도 충분히 구현할 수 있습니다. 게다가, 형식 매개변수를 사용할 때마다 Thunk를 호출하는 비용이 엄청나다는 것이 입증되었기 때문에 ALGOL 68에서는 이러한 전달 방법이 삭제되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 주요 언어들에서 매개변수 전달 방법을 어떻게 사용하고 있는지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 Fortran 언어는 Fortran 77 이전까지 Pass by Reference를 사용하다가, Fortran 77부터는 Pass by Value Result를 사용하는 것으로 변경되었습니다. ALGOL 60은 이전 슬라이드에서도 언급했듯이, Pass by Name을 사용했습니다. SIMULA-67 또한 마찬가지로 Pass by Name을 사용했습니다.&lt;/p&gt;

&lt;p&gt;그러나 ALGOL 68과 C 언어부터는 Pass by Value를 사용하기 시작했습니다. 만약 매개변수를 변경할 필요가 있을 때는 포인터 타입을 사용함으로써 Pass by Reference와 같은 효과를 얻을 수 있습니다. 이 언어들의 특징은 형식 매개변수를 나열할 때, 매개변수의 이름 옆에 매개변수의 타입을 같이 선언하는 문법을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;ALGOL W의 경우에는 Pass by Result를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal 언어와 Modula-2 언어의 경우는 조금 특이한데, 기본적으로 Pass by Value로 매개변수를 전달하지만, var 이라는 예약어를 사용하여 형식 매개변수를 정의한다면 Pass by Reference로 전달합니다.&lt;/p&gt;

&lt;p&gt;Ada 언어는 이보다 더 특이하게 기술적으로 이 문제를 접근했습니다. Ada 언어는 매개변수 앞에 in/out/in out 예약어를 붙임으로써 매개변수가 전달되는 방법을 구분합니다. 각각 in mode / out mode / in out mode를 의미합니다.&lt;/p&gt;

&lt;p&gt;이전에는 실 매개변수의 타입이 형식 매개변수의 타입과 같은지 확인하는 절차가 따로 없었으나, 최근에는 이것을 검사하는 것이 소프트웨어의 신뢰성을 높인다고 알려져 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 77나 초창기 C 언어 같은 초기 프로그래밍 언어는 매개변수 타입 검사를 요구하지 않았습니다. 그러나 그 이후 개발된 Pascal, Modula-2, Fortran 90과 같은 언어들은 매개변수의 타입 검사를 실시합니다.&lt;/p&gt;

&lt;p&gt;ANSI C 언어는 조금 특이한 방식을 가지고 있습니다. 만약 함수를 선언할 때 형식 매개변수에 타입을 작성하지 않으면, 초창기 C 언어와 마찬가지로 타입 검사를 하지 않습니다. 물론 C 언어에 기반했기 때문에 프로그램 내에서 해당 형식 매개변수의 타입을 명세하기는 하지만, 그렇다고 실 매개변수와 타입이 같을 필요는 없습니다.&lt;/p&gt;

&lt;p&gt;만약 함수를 선언할 때 형식 매개변수의 타입을 작성하면 타입 검사를 수행합니다. 만약 타입 검사 후에 타입이 다르더라도, int - double과 같이 같은 숫자형 변수라면 강제 변환(Coercion)이 일어납니다. 만약 변환이 가능하지 않거나 매개변수의 개수가 틀리다면 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;C++ 언어(C99 포함)는 ANSI C와는 다른 방식으로 타입 검사를 피할 수 있습니다. 형식 매개변수를 선언할 때, 생략 기호(Ellipsis)를 사용하면 매개변수의 개수나 타입 검사를 피할 수 있습니다. 예를 들어, 교재에 나온 코드인 printf 함수의 경우 적어도 한 개의 매개변수가 필요합니다. 그 외에는 몇 개의 매개변수를 갖던 상관이 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 매개변수 전달 방법을 구현하는 방법에 대해 알아보겠습니다. ALGOL 60을 비롯한 그 후속 언어들에서는 실행 시간 스택(Run-time Stack)을 이용하여 매개변수를 연결하였습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Pass by Value에서 매개변수는 그 값이 스택에 복사됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pass by Result에서 매개변수는 실제 매개변수가 스택에 배치되고, 호출된 부프로그램이 종료할 때 부프로그램에서 사용된 형식 매개변수와 일치하는 실제 매개변수를 스택에서 검색하여 매칭됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pass by Value Result는 Pass by Value와 Pass by Result를 합친 것으로 구현합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pass by Reference는 실 매개변수의 타입에 관계 없이 그 주소가 스택에 배치되어야 합니다. 컴파일러는 호출된 부프로그램으로 제어권을 넘기기 전에 식을 평가하는 코드를 작성해야 합니다. 해당 식의 코드 결과가 스택이 배치되는 주소입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pass by Name은 이전 방법들과 구현 방법이 상이합니다. 크게 2가지 방법으로 나눌 수 있는데, 매개변수가 없는 프로시저로 구현하거나 실행 시간 상주 코드 세그먼트인 Thunk로 구현하는 것입니다. (후자의 경우가 훨씬 많이 사용됨)&lt;/p&gt;

&lt;p&gt;호출된 부프로그램의 Pass by Name 매개변수에 대한 모든 참조에 대해 Thunk를 호출해야 합니다.&lt;/p&gt;

&lt;p&gt;Thunk는 전달된 부프로그램이 선언된 부프로그램의 적절한 참조 환경에서 참조를 수행하고, 실 매개변수의 주소를 반환합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;매개변수 전달 방법을 선택하는데는 두 가지 고려사항이 있습니다. 하나는 효율성이고, 하나는 단방향 데이터 이동과 양방향 데이터 이동의 선택입니다. 현대 소프트웨어 공학(Software Engineerning)에서는 부프로그램 밖에 있는 데이터는 부프로그램 내에서 접근을 최소화하는 것을 지향하고 있습니다. 따라서 일반적으로는 in mode를 사용하는 것이 권장됩니다.&lt;/p&gt;

&lt;p&gt;그런데 이러한 원리와 상충되는 고려사항도 있습니다. 예를 들어, 크기가 큰 배열이 Pass by Value로 전달될 경우, 배열 전체가 실행 시간 스택에 들어가야 하는 문제가 있습니다. 이것은 시간적으로도, 공간적으로도 부담이 크기 때문에 배열은 Pass by Reference로 전달되는 경우가 있습니다. 따라서 Ada 언어나 C++ 언어는 이것을 사용자에게 선택하게끔 하고 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 부프로그램을 다른 부프로그램의 매개변수로 전달하는 방법에 대해 알아보겠습니다. 언뜻 보면 이 개념은 자연스럽고 당연한 것처럼 보이지만, 동작하는 과정은 복잡합니다. 단지 부프로그램의 코드만 전달하는 것으로도 구현은 가능하지만, 이렇게 구현하게 되면 2가지 문제점이 발생합니다.&lt;/p&gt;

&lt;p&gt;첫 번째 문제는 매개변수로 전달된 부프로그램의 매개변수 타입 검사 문제입니다. 두 번째 문제는 중첩된 부프로그램을 허용하는 경우 발생합니다. 바로 전달된 부프로그램을 실행시키기 위해 어떤 참조 환경이 사용되어야 하는가의 문제인데, 다음 슬라이드에서와 같이 세 가지 방법이 존재합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;첫 번째 참조 환경은 전달된 부프로그램을 실행시키는 호출문의 환경인 &lt;strong&gt;얕은 바인딩(Shallow Binding)&lt;/strong&gt;입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;두 번째 참조 환경은 전달된 부프로그램의 정의 환경인 &lt;strong&gt;깊은 바인딩(Deep Binding)&lt;/strong&gt;입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;세 번째 참조 환경은 부프로그램을 실 매개변수로 전달한 호출문의 환경인 &lt;strong&gt;애드혹 바인딩(Ad-hoc Binding)&lt;/strong&gt;입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 참조 환경의 차이를 알아보기 위해 슬라이드에 나와있는 코드를 확인해보겠습니다. 코드에서는 SUB1 -&amp;gt; SUB3 -&amp;gt; SUB4 -&amp;gt; SUB2 순서대로 프로시저가 호출됩니다. 주의할 것은, SUB3 내에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUB4(SUB2)&lt;/code&gt;와 같이 프로시저가 중첩되어 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;만약 얕은 바인딩이 사용된다면, SUB2 내에서 사용되는 변수 x는 SUB4의 변수에 바인딩됩니다. 따라서 이 경우 출력이 4가 나옵니다.&lt;/p&gt;

&lt;p&gt;만약 깊은 바인딩이 사용된다면, 구조적으로 상위에 있는 변수를 참조하므로 SUB1의 x에 바인딩됩니다. 따라서 이 경우 출력이 1이 나옵니다.&lt;/p&gt;

&lt;p&gt;만약 애드혹 바인딩이 사용된다면, 자신(SUB2)을 호출하기 직전에 정의되었던 x에 바인딩됩니다. 따라서 이 경우 직전에 정의된 SUB3의 x 값인 3이 출력됩니다.&lt;/p&gt;

&lt;p&gt;일반적으로 정적 바인딩을 가지는 언어는 텍스트의 위치만으로 쉽게 결정할 수 있는 깊은 바인딩을 사용하고, 동적 바인딩을 가지는 언어는 얕은 바인딩을 사용합니다. 애드혹 바인딩은 잘 사용되지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;오버로드된 부프로그램(Overloaded Subprogram)&lt;/span&gt;은 같은 참조 환경에서 다른 부프로그램들과 이름이 같은 부프로그램입니다. 주의할 점은, 이름은 같지만 매개변수의 개수나 순서, 타입, 반환 타입 등은 다른 부프로그램들과는 달라야 합니다. 오버로드된 부프로그램이 어떤 부프로그램인지는 실 매개변수의 리스트에 의해 결정되기 때문입니다.&lt;/p&gt;

&lt;p&gt;Ada 언어에서는 함수와 프로시저 모두 오버로드된 부프로그램을 허용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어의 함수는 매개변수의 개수나 타입이 고유하다면 오버로드가 가능합니다. 컴파일러는 매개변수의 타입으로 모호함을 해결하는데, 이 과정이 생각보다 복잡합니다. 특히, C++ 언어는 매개변수의 강제 변환을 허용하기 때문에 모호함을 해결하는 것이 매우 어렵습니다. 또한 기본 매개변수도 모호함을 일으키는 요소 중 하나입니다. 예를 들어, 슬라이드에 주어진 코드에서는 두 개의 fun() 함수가 존재합니다. 그런데 위의 fun() 함수는 기본 매개변수로 실수형 매개변수 b를 가지고 있습니다. 그런데 기본 매개변수는 함수를 호출할 때 생략하는 것이 가능하므로, 만약 함수를 호출할 때 fun()이라고 호출하면 기본 매개변수를 생략한 첫 번째 fun()을 호출한 것인지, 아니면 두 번째 fun()을 호출한 것인지 알 수가 없습니다. 따라서 이 경우 모호함을 일으켜 컴파일 오류를 발생시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;제네릭 부프로그램(Generic Subprogram)&lt;/span&gt;은 매개변수가 다른 값일 뿐만 아니라 다른 타입을 가질 수 있게 일반적인 타입으로 정의할 수 있습니다. 이것은 소프트웨어를 재사용할 수 있게끔 가능하게 만들어 생산성을 증가시키는 이점이 있습니다. 보통 제네릭 부프로그램은 객체 지향 프로그래밍 언어를 배울 때 &lt;strong&gt;다형성(Polymorphism)&lt;/strong&gt;을 언급하면서 같이 배우곤 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제네릭 부프로그램을 허용한다면 사용자 프로그램의 요청에 따라 컴파일러가 다양한 버전의 부프로그램을 자동적으로 구성합니다. 제네릭 단위는 단지 프로시저의 템플릿일 뿐, 컴파일러에 의해 코드가 생성되지 않습니다. 따라서 어떤 특정 타입으로 인스턴스화되지 않는 이상, 프로그램에 영향을 전혀 미치지 않습니다.&lt;/p&gt;

&lt;p&gt;슬라이드에 있는 코드는 GENERIC_SORT로 정의된 제네릭 부프로그램을 INTEGER_SORT라는 이름으로 인스턴스화하여 INTEGER 유형의 변수를 정렬하는 부프로그램으로 만든 예시입니다. 다만 예시로 나온 코드는 진짜 제네릭 부프로그램은 아닙니다.&lt;/p&gt;

&lt;p&gt;C++ 언어에서 제네릭 부프로그램은 Templete이라는 이름을 갖고, Java 언어에서는 &lt;T&gt;를 이용하여 표기합니다.&lt;/T&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran II에서와 같이, 규모가 큰 소프트웨어의 경우 프로그램의 일부만 컴파일하는 기능은 필수적입니다. 컴파일 할 수 있는 프로그램의 일부분을 &lt;strong&gt;컴파일 단위(Compilation Unit)&lt;/strong&gt;라고도 부릅니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;span style=&quot;color:red&quot;&gt;부분 컴파일(Separate Compilation)&lt;/span&gt;에 대해서 말하자면 부분 컴파일은 매개변수 타입 검사가 필요합니다.&lt;/p&gt;

&lt;p&gt;컴파일 단위끼리는 서로 다른 시간에 컴파일될 수 있지만, 만약 해당 컴파일 단위가 다른 컴파일 단위에 접근하거나 영향을 미치는 경우에는 해당 컴파일이 서로 독립적이지 않습니다.&lt;/p&gt;

&lt;p&gt;안정적으로 독립적인 컴파일을 수행하기 위해서는 컴파일러가 프로그램의 속성(변수, 타입, 인터페이스를 포함한 부프로그램)에 대한 정보에 접근할 수 있어야 합니다.&lt;/p&gt;

&lt;p&gt;Ada 언어에서는 컴파일러가 접근할 수 있는 라이브러리에 이러한 종류의 단위 인터페이스 정보를 유지함으로써 구현하였습니다.&lt;/p&gt;

&lt;p&gt;모든 컴파일은 해당 컴파일의 인터페이스 정보를 라이브러리에 배치하게 만듭니다.&lt;/p&gt;

&lt;p&gt;Ada, Modula-2, Fortran 90이 이러한 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/32.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;독립적인 컴파일(Independent Compilation)&lt;/span&gt;은 부분 컴파일과는 다르게 매개변수의 타입 검사를 필요로 하지 않습니다. 따라서 프로그램 유닛은 다른 프로그램 유닛에 대한 정보 없이 컴파일이 가능합니다.&lt;/p&gt;

&lt;p&gt;게다가 별도로 컴파일된 유닛간 인터페이스의 일관성을 확인하지도 않습니다.&lt;/p&gt;

&lt;p&gt;Fortran 77, C 언어가 이러한 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;다음으로는 함수의 설계 고려 사항에 대해 알아보겠습니다. 함수의 설계 고려 사항에는 다음과 같은 3가지 요소가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;부작용(Side Effect)이 허용되는가?&lt;/li&gt;
  &lt;li&gt;어떤 타입의 값이 반환되는가?&lt;/li&gt;
  &lt;li&gt;몇 개의 값이 반환될 수 있는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저 부작용에 대해 생각해봅시다. 5장에서 나왔던대로, 식에서 호출되는 함수의 부작용으로 인해 함수의 매개변수는 항상 in mode여야 합니다. 예를 들어, Ada 언어의 함수는 항상 in mode 형식 매개변수만 가질 수 있습니다. 이러한 제약은 함수가 매개변수에 의한 부작용, 또는 매개변수와 전역 변수의 별칭(Alias)에 의한 부작용이 발생하는 것을 효과적으로 방지합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/33.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러나 Pascal이나 C 언어에서 함수는 Pass by Value 또는 Pass by Reference 매개변수를 가질 수 있으므로 부작용이나 별칭을 발생시키는 함수를 허용합니다.&lt;/p&gt;

&lt;p&gt;두 번째 고려사항으로 넘어가면, 대부분의 명령형 언어는 해당 함수에서 반환할 수 있는 타입을 제한하고 있습니다. 몇몇 언어의 반환 타입 제한을 살펴보면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Fortran 77 : 함수는 구조화되지 않은 타입만 반환할 수 있음&lt;/li&gt;
  &lt;li&gt;Pascal, Modular-2 : 함수가 단순한 타입만 반환할 수 있음 (정수, 실수, 문자, 불리안, 포인터, 열거 타입)&lt;/li&gt;
  &lt;li&gt;C : 배열과 함수를 제외한 모든 타입이 함수에 의해 반환될 수 있음 (C++ 언어는 클래스도 반환 가능)&lt;/li&gt;
  &lt;li&gt;Ada (+ Python, Ruby) : 모든 타입을 반환할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세 번째 고려사항인 반환 값의 개수에 대해 논하자면, 대부분의 명령형 언어는 한 개의 값만 반환이 가능합니다. 그러나 Ruby, Lua, Python 같은 언어는 여러 개의 값이 반환되는 것을 허용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/34.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부프로그램 간에 필요한 소통의 대부분은 매개변수를 통해 수행할 수 있지만, 대부분의 언어는 외부 환경에서 변수에 접근하는 다른 방법을 제공합니다. 부프로그램의 비지역 변수는 부프로그램 내에서 볼 수 있지만, 지역적으로 선언되지 않은 변수입니다.&lt;/p&gt;

&lt;p&gt;만약 정적 영역 언어라면, 필요한 것보다 비지역 변수에 대한 더 많은 접근 방법을 제공합니다.&lt;/p&gt;

&lt;p&gt;그러나 동적 영역 언어라면, 부프로그램의 모든 지역 변수는 텍스트가 얼마나 가까이 있는지에 상관 없이, 실행중인 다른 부프로그램에서 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나, 이런 식으로 비지역 변수를 참조할 때는 정적으로 타입을 검사할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/35.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 언어는 COMMON이라는 명령어를 통해 전역 저장소 블록에 대한 접근 방법을 제공합니다. COMMON 블록은 블록 이름을 선언하는 첫 번째 COMMON 문이 컴파일러에 의해 발견될 때 생성됩니다. 그런데 만약 두 개의 부프로그램에 이름이 다른 동일한 데이터 블록이 포함될 수 있다는 문제가 존재합니다. 슬라이드에 나온 코드에서도 A/B가 차지하는 영역과 C/D/E가 차지하는 공간이 겹치는 문제점이 발생하였습니다. 이것과 비슷한 이유로, 동적 배열도 COMMON 블록에 넣을 수 없습니다. 따라서 COMMON 블록을 최대한 사용하지 않는 것이 바람직합니다.&lt;/p&gt;

&lt;p&gt;Modula-2와 Ada 언어는 접근이 필요한 외부 모듈을 지정할 수 있도록 데이터 공유의 대안적인 방법을 제공합니다. 모든 모듈은 접근이 필요한 다른 모듈을 정확하게 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/009/36.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C 언어는 다른 언어들과 다르게 전역 변수는 함수의 정의 외부에서 선언하여 생성할 수 있습니다. 또한 extern 문을 사용하여 다른 파일에 있는 전역 변수를 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 마지막으로 &lt;span style=&quot;color:red&quot;&gt;사용자 정의 연산자 오버로딩(User-defeind Overloaded Operator)&lt;/span&gt;에 대해 알아보겠습니다. Ada, C++, Python과 같은 언어에서는 매개변수의 타입이나 수, 반환 타입이 다르다면 사용자가 연산을 재정의할 수 있습니다.&lt;/p&gt;

&lt;p&gt;9장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Statement-Level Control Structures</title><link href="http://localhost:4000/pl/statement-level-control-structures/" rel="alternate" type="text/html" title="Statement-Level Control Structures" /><published>2023-09-08T00:00:00+09:00</published><updated>2023-09-08T00:00:00+09:00</updated><id>http://localhost:4000/pl/statement-level-control-structures</id><content type="html" xml:base="http://localhost:4000/pl/statement-level-control-structures/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8장의 주제는 문장 단계 제어 구조입니다. 프로그램의 제어 흐름, 또는 실행 순서는 여러 단계에서 검사할 수 있습니다. 프로그램에서 발생할 수 있는 제어 흐름은 다음과 같이 3가지로 나눌 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;식 내 제어 흐름 -&amp;gt; 연산자 우선순위 및 관련성&lt;/li&gt;
  &lt;li&gt;문장 간 제어 흐름 -&amp;gt; 문장 단계 제어 구조&lt;/li&gt;
  &lt;li&gt;유닛 간 제어 흐름 -&amp;gt; 프로시저 호출&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;식 내에서의 제어 흐름은 7장에서 다루었고, 이번 장에서는 프로그램 내의 문장들 사이에서 발생하는 제어 흐름에 대해 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;연산을 표현하기 위해서는 시퀀스, 선택 및 논리 반복문 절대적으로 필요하다는 이론적 결과가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령형 언어에서 연산은 식을 수행하고 결과 값을 변수에 할당하는 과정입니다. 그러나 결과 값은 배정문 만으로 얻기 힘들며, 일반적으로 제어문이 추가적으로 필요합니다. 명령형 언어에서 제어는 제어 흐름 경로 중에서 선택하는 것(조건문), 특정 문장을 반복적으로 실행하는 것(반복문)으로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;초기 프로그래밍 언어인 Fortran의 제어문은 기계의 명령어와 직접적으로 관련되어 있었습니다. 따라서 언어의 설계보다는 명령어 설계의 결과였습니다. 당시에는 프로그래밍의 어려움에 대해서 사람들이 체감하지 못했기 때문에 이것이 문제가 없다고 느꼈지만, 현대에서 이러한 제어문은 부적절하다고 판단하고 있습니다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어가 발전해오면서, 순서도로 표현할 수 있는 모든 알고리즘은 단 두 개의 제어문만으로 코딩이 가능하다는 것이 증명되었습니다. 하나는 if를 비롯한 조건문이고, 나머지 하나는 for를 비롯한 반복문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;많은 제어문은 작성력을 향상시킬 수 있습니다. 그러나 제어문의 수가 많아질수록 언어의 단순성은 낮아집니다. 그렇다면 단순성을 크게 떨어트리지 않고 작성력을 높이기 위해서는 언어를 얼마나 확장해야 할까요? 이 부분은 이렇다! 할 만한 정확한 정답을 찾기 힘듭니다. 제어문이 너무 적으면 단순한 제어문을 반복적으로 사용해야하기 때문에 오히려 가독성을 낮출 수 있습니다. (ex. switch 문의 부재 - if 문의 과도한 사용)&lt;/p&gt;

&lt;p&gt;순서도에서 선택문과 반복문은 슬라이드의 그림과 같이 표현합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 60 언어에서는 단일 문장으로 추상화할 수 있는 문장의 모음을 복합문으로, 복합문에 변수 선언이 포함된 것을 블록이라고 정의합니다. Pascal 언어는 ALGOL 60의 설계를 따라 복합문을 정의하지만, 블록을 허용하지는 않습니다. C 언어는 중괄호를 사용하여 복합문과 블록을 모두 무제한으로 허용하고 있습니다.&lt;/p&gt;

&lt;p&gt;복합문의 설계에는 단 한 가지 고려 사항이 있습니다. 바로 제어문이 여러 개의 진입점을 가질 수 있는가에 대해서입니다. 대부분의 컴퓨터과학자는 제어문이 여러 개의 진입점을 갖는 것은 복잡하므로 가독성이 떨어지는데 비해, 유연성이 그다지 늘어나지 않는다고 생각하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;선택문(Selection Statement)&lt;/span&gt;은 프로그램에서 두 개 이상의 실행 경로 가운데 하나를 선택할 수 있는 문장입니다. 선택문을 일반적으로 2방향 선택문과 다방향 선택문으로 나뉩니다.&lt;/p&gt;

&lt;p&gt;먼저 2방향 선택문부터 다뤄보도록 하겠습니다. 대부분 언어에서 2방향 선택문의 구조는 매우 유사하지만, 다음과 같은 설계 고려 사항에 따른 미묘한 차이가 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선택을 제어하는 식의 타입은 무엇인가? (대부분의 언어에서는 불리안 식, C 언어에서는 산술 표현식)&lt;/li&gt;
  &lt;li&gt;단일 명령문만 선택할 수 있습니까, 아니면 명령문의 그룹도 선택할 수 있습니까?&lt;/li&gt;
  &lt;li&gt;다른 선택자의 ‘then’ 문에 중첩된 선택자의 의미를 어떻게 지정해야 합니까?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모든 명령형 언어에는 &lt;strong&gt;단방향 선택기(Single-Way Selector)&lt;/strong&gt;가 포함되어 있는데, 대부분 양방향 선택기의 하위 형태로 구현되어 있습니다. 그러나 BASIC과 Fortran은 예외이므로, 이 부분을 잠시 짚고 넘어가겠습니다.&lt;/p&gt;

&lt;p&gt;Fortran 언어에서 If(불리안 식) 문에서는 단일 선택만 가능하고, 중첩이 허용되지 않습니다. 이것은 GOTO 문의 사용을 촉진합니다. 매우 단순하지만, 유연성이 부족하다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;복합문은 문장의 그룹을 조건부로 실행하기 위한 간단한 방법입니다, ALGOL 60 언어에서는 begin과 end를 통해 복합문의 그룹을 명세합니다.&lt;/p&gt;

&lt;p&gt;Fortran 77, 90을 포함하여 ALGOL 60의 영향을 받은 대부분의 언어는 복합문을 선택할 수 있는 단방향 선택기를 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;양방향 선택기(Two-Way Selector)&lt;/strong&gt;는 두 가지 제어 경로 중 하나를 선택하는 것을 허용하는 제어문입니다. ALGOL 60에서는 if-then-else를 이용하여 이것을 구현했습니다.&lt;/p&gt;

&lt;p&gt;또한 선택자를 중첩할 수도 있습니다. 그러니 중첩 선택자들 간에 모호함이 발생한다는 문제가 있습니다. 예를 들어, 슬라이드에 있는 코드처럼 if - if - then - else 문을 사용했을 때, else가 어떤 if 문에 대해 수행되는지가 문제입니다. (들여쓰기를 보고 첫 번째 if 문과 매칭되야 할 것으로 착각하실 수 있는데, Python 같은 특수한 언어를 제외하고 들여쓰기는 언어에 아무런 영향을 미치지 않습니다)&lt;/p&gt;

&lt;p&gt;대부분의 명령형 언어에서는 else 문이 가장 가까이 있고 짝이 없는 then 절과 짝을 이루도록 지정합니다.&lt;/p&gt;

&lt;p&gt;ALGOL 60 언어에서 if 문은 else 문이 then에 직접 연결될 수 없고, 반드시 복합문에 넣어야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;if 문의 마지막 절이 then이든 else이든 복합문이 아닌 경우, 전체 선택 구조의 끝을 표시하는 구문 요소가 없습니다. 만약 선택 구조의 끝을 나타내는 특수어를 사용한다면 중첩 선택문의 모호함을 해결하고, 가독성을 향상시킬 수 있습니다. Modula-2 언어에서는 END, Fortran 77에서는 END IF를 사용하여 if 문의 끝을 나타냅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;다중 선택기(Multiple Selector)&lt;/strong&gt;는 여러 개의 문장이나 문장 그룹 중 하나를 선택하는 제어문입니다. 선택기의 일반화 개념으로 이해하시면 됩니다. 다중 선택기의 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선택을 제어하는 문장의 형식과 타입은 무엇인가?&lt;/li&gt;
  &lt;li&gt;단일 명령문만 선택할 수 있습니까, 아니면 명령문의 그룹도 선택할 수 있습니까?&lt;/li&gt;
  &lt;li&gt;전체 구성이 구문 구조로 캡슐화되어야 합니까?&lt;/li&gt;
  &lt;li&gt;선택 가능한 단일 명령문만 포함하도록 구조를 통한 실행 흐름을 제한해야 합니까? (ex. switch - break)&lt;/li&gt;
  &lt;li&gt;만약 표현되지 않는 선택자 식의 값이 존재할 경우, 어떻게 처리할 것인가? (ex. 1, 2, 3 선택인데 조건식이 4가 나온 경우)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortran에서는 슬라이드의 코드와 같이 GOTO 문을 이용하여 다중 선택기를 사용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현대의 다중 선택기는 Case 문을 이용하고 있습니다. ALGOL-W 에서 다중 선택기의 구조는 캡슐화되어 있으며, 선택 가능한 단일 세그먼트를 제공합니다. 실행하는 문장은 조건식에 값에 의해 선택된 문장들입니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어에서 선택 가능한 세그먼트에는 라벨이 지정되어 있습니다. 조건식은 정수, 불리안, 문자와 같은 순서 타입(Ordinal Type)으로 구성되어 있습니다. 조건식이 수행되고 나서 값이 세그먼트의 상수와 비교됩니다. 상수 목록은 조건식과 동일한 타입이어야 하며, 목록들 간에 상호 베타적이지만 완전할 필요는 없습니다. (ex. 1, 2, 3 과 같이 겹치는 부분이 없어야 하며 상수 목록이 정수 전체를 포함할 필요는 없음)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C 언어에서 제어식과 상수식은 모두 정수 타입입니다. 또한 세그먼트 별로 암묵적인 분기를 지원하지 않습니다. (즉, 명시적으로 세그먼트 별로 break를 나타내야 정확하게 분기됩니다)&lt;/p&gt;

&lt;p&gt;만약 순서 타입이 아닌 불리안 식을 기반으로 선택을 하는 경우에는 중첩된 양방향 선택기를 사용하여 다중 선택기처럼 만들 수 있습니다. 예를 들어, Ada 언어나 Fortran 90 에서 불리안 식과 else if를 사용한 코드가 슬라이드에 나와 있습니다. (Python도 이와 비슷하게 구현됩니다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;반복문(Iterative Statement)&lt;/span&gt;은 명령어, 또는 명령어 모음이 여러 횟수만큼 실행되도록 하는 문장입니다. 반복문을 흔히 루프(Loop)라고도 부릅니다. 반복문은 반복적 구조보다는 재귀 같은 것을 통해 함수형 언어로 수행되는 경우가 많습니다. 처음 개발된 반복문은 배열에 포함된 데이터를 처리하기 위해 개발되었기 때문에, 배열과 직접적인 관련이 있습니다.&lt;/p&gt;

&lt;p&gt;반복문의 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;반복이 어떻게 제어되는가? (논리, 계수, 또는 그 두 가지의 혼합형)&lt;/li&gt;
  &lt;li&gt;제어 메커니즘이 루프 어느 부분에 위치해야 하는가? (앞부분, 뒷부분, 또는 사용자 마음대로)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 계수로 제어하는 반복문에 대해 알아보겠습니다. 이러한 반복문은 초기 값(Initial), 종료 값(Terminal), 단계 크기(Stepsize)로 구성되어 있습니다. (이것들을 루프 매개변수라고 부릅니다) 계수로 제어하는 반복문은 종종 기계 명령어에 의해 지원됩니다. 이 때 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;루프 변수의 유형과 범위는 무엇인가? (정수, 문자, 열거형, 부동 소수점 등)&lt;/li&gt;
  &lt;li&gt;루프 종료 시 루프 변수에는 어떤 값이 들어가는가?&lt;/li&gt;
  &lt;li&gt;루프 변수, 또는 루프 매개변수가 루프 내에서 변경되는 것이 허용되는가? 그렇다면 그 변경 사항이 루프 제어에 영향을 주는가?&lt;/li&gt;
  &lt;li&gt;반복의 완료 검사는 루프의 맨 위에서 이루어지는가, 맨 아래에서 이루어지는가?&lt;/li&gt;
  &lt;li&gt;루프 매개변수는 한 번만 평가되는가? 아니면 각 반복에 대해 매번 평가되는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran IV 언어에서 반복문은 DO를 이용하여 사용합니다. 루프 변수에 대한 검사는 반복문의 수행 후 발생하며(Post-test), 초기 값, 종료 값, 단계 크기 변수는 부호 없는 정수, 또는 양수 값을 갖는 단순 정수 변수로 제한됩니다.&lt;/p&gt;

&lt;p&gt;만약 루프가 정상적으로 종료한다면 루프 변수의 값은 정의되지 않으며, 만약 비정상으로 종료된다면 가장 최근에 할당된 값이 저장됩니다.&lt;/p&gt;

&lt;p&gt;루프 변수와 루프 매개변수는 루프 내부에서 변경할 수 없기 때문에 루프 매개변수를 두 번 이상 평가할 필요가 없습니다. (즉, 반복문이 실행되기 전에 몇 번 반복을 해야하는지 예측할 수 있음)&lt;/p&gt;

&lt;p&gt;또한 Fortran IV 에서 루프 내부는 단일 명령어만 사용이 가능하기 때문에, 명령어 집합을 반복하고 싶다면 GOTO 문을 활용해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 77과 90에서 DO 문은 많이 변경되었습니다.&lt;/p&gt;

&lt;p&gt;먼저 루프 변수에 대한 검사는 반복문의 수행 전 발생하며(Pretest), 루프 변수는 정수, 실수, 그리고 확장 실수 타입에 대해서도 가능합니다. 루프 매개변수는 표현식으로 나타내는 것이 허용되며, 양수 값과 음수 값을 모두 가질 수 있습니다.&lt;/p&gt;

&lt;p&gt;루프는 루프 매개변수가 아니라 반복 횟수에 따라 제어됩니다. 따라서 루프 내에서 루프 매개변수가 변경되더라도, 이것은 루프 제어에 영향을 미치지 않습니다. 즉, 반복 횟수는 사용자가 접근할 수 없는 내부 변수입니다.&lt;/p&gt;

&lt;p&gt;DO 반복문에 진입하는 것은 DO 문을 사용해서만 입력할 수 있습니다. (단일 진입 구조)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 60에서 반복문은 계수기와 불리안 식으로 루프를 제어할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 for의 모든 표현식은 루프 문의 모든 반복이나 실행에 대해 평가됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어에서 반복문은 비교적 간단한 계수기-제어 사전 검사 루프입니다. &lt;strong&gt;reverse&lt;/strong&gt;는 discrete_range의 범위를 역순으로 루프 변수에 할당한다는 의미이고, discrete_range는 1~10 이나 Monday~Friday와 같이 정수나 열거 타입의 부분 범위를 말합니다.&lt;/p&gt;

&lt;p&gt;Ada 언어의 가장 큰 특징은 루프 변수의 범위입니다. 루프 변수는 루프 안에서만 묵시적으로 선언되고, 루프 종료 후에는 무시됩니다. 예를 들어, 슬라이드에 나와 있는 코드에서 COUNT는 실수형 변수로 1.35가 할당됩니다. 그런데 for 문의 루프 변수의 이름도 동일하게 COUNT입니다. 이 상황에서, 처음 선언한 COUNT 변수는 for 문에 영향을 받지 않습니다. 즉, for 문이 끝나도 COUNT 변수에는 여전히 실수값 1.35가 저장됩니다. 또한 루프 변수에는 루프 내부의 값을 할당할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 가장 친근한 언어인 C 언어의 경우를 살펴보겠습니다. C 언어도 Ada 언어와 마찬가지로 사전 검사 계수 루프 구조입니다. C 언어의 for 문이 어떻게 구성되어 있는지는 다들 아실테니 생략하도록 하겠습니다. C 언어의 for 문은 두 번째 표현식의 값이 0이면 종료됩니다. 그리고 그 외에는 루프 내부의 명령어, 또는 명령어 집합이 실행됩니다.&lt;/p&gt;

&lt;p&gt;또한 C 언어 for 문의 루프 매개변수들은 모두 선택적입니다. 예를 들어, 두 번째 식을 생략한다면 무한 루프로써 간주되고, 첫 번째와 세 번째 식이 생략되면 루프 변수를 고려하지 않습니다. 먄악 첫 번째 식만 생략되면 단순히 초기화가 일어나지 않는다는 것을 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반복 제어가 불리안 식에 기반하는 반복문을 &lt;span style=&quot;color:red&quot;&gt;논리 제어 루프(Logically Controlled Loop)&lt;/span&gt;라고 합니다. 논리 제어 루프는 계수기 제어 루프보다 일반적입니다. 즉, 모든 계수기 제어 루프는 논리 제어 루프로 표현할 수 있지만, 그 반대는 불가능합니다. 논리 제어 루프에서의 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제어가 사전 검사(Pretest)인가 사후 검사(Post-test)인가?&lt;/li&gt;
  &lt;li&gt;논리 제어 루프가 계수기 제어 루프의 특별한 형식인가, 아니면 전혀 다른 문법을 가지는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어, Pascal, Modula-2, C 기반 언어들은 사전 검사와 사후 검사 논리 제어 루프를 모두 가지고 있습니다. 예를 들어, C 언어의 while 문은 사전 검사 논리 제어 루프이고, do-while 문은 사후 검사 논리 제어 루프입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상황에 따라서는 프로그래머 루프 제어를 위한 검사를 루프의 처음이나 마지막이 아닌 곳을 선택해야할 수도 있습니다. 몇몇 언어는 이러한 기능을 제공하는데, 이것을 &lt;span style=&quot;color:red&quot;&gt;사용자 지정 루프 제어(User-located Loop Control)&lt;/span&gt;라고 합니다. 구현 자체는 간단하지만, 역시 이전 루프문과 마찬가지로 설계 고려 사항이 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;조건 매커니즘이 탈출에 필수적이어야 하는가?&lt;/li&gt;
  &lt;li&gt;탈출할 때는 하나의 루프만 탈출해야 하는가, 아니면 포괄하는 루프를 모두 탈출해야 하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ada 언어에서는 루프문에 레이블을 붙일 수 있습니다. 따라서 루프문 내에서 특정 레이블 루프를 지정하여 탈출하는 것이 가능합니다.&lt;/p&gt;

&lt;p&gt;C 언어에서는 루프문에 레이블을 붙일 수 없기 때문에 무조건 가장 가까이 있는 루프문만을 지정할 수 있습니다. break를 통해 가장 가까이 있는 루프문을 탈출할 수 있으며, continue를 통해 루프문을 탈출하지 않고 현재 반복에서 나머지 명령어를 생략하는 방식이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자료구조에 기반한 반복문도 있습니다. 이 때 루프는 계수기나 불리안 식이 아니라 자료구조의 원소 수에 의해 제어됩니다.&lt;/p&gt;

&lt;p&gt;Java 언어에서는 배열의 값이나 Iteratable 인터페이스를 통해 구현된 객체를 통해 for 문을 제어할 수 있습니다. 예를 들어, 문자열을 포함하는 myList라는 이름의 ArrayList 컬렉션이 있는 경우, 조건문에 이를 나타내면 각 원소를 myElement로 설정하며 반복문을 수행합니다.&lt;/p&gt;

&lt;p&gt;C# 언어도 마찬가지로 문자열 자료형인 String을 이용하여 foreach 문을 제어하는 것이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;무조건 분기문(Unconditional Branch)&lt;/span&gt;는 실행 제어를 프로그램의 지정된 위치로 이동시킵니다.&lt;/p&gt;

&lt;p&gt;무조건 분기문의 대표적인 명령어는 바로 GOTO 문으로, 프로그램의 실행 흐름을 제어하는 가장 강력한 명령문이지만 이 힘으로 인해 사용을 위험하게 만듭니다. (큰 힘에는 큰 책임이 따른다…)&lt;/p&gt;

&lt;p&gt;명령어의 실행 순서가 작성된 순서와 거의 동일할 때 가독성이 가장 좋습니다. (일반적으로 위해서 아래) 따라서 이러한 무조건 분기문은 가독성을 매우 낮출 수 있습니다. 그러한 문제점으로 인해 Modula-2, Bliss, CLU 등과 같은 언어는 GOTO 문이 없이 설계되었습니다. (+ Java, Python, Ruby) 여담으로 GOTO 문의 위험성을 알린 사람이 바로 다익스트라 알고리즘으로 유명한 &lt;strong&gt;에드가 다익스트라(Edger Dijkstra)&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;그러나 현재 가장 많이 사용되는 언어들에는 GOTO 문이 포함되어 있습니다. (대표적으로 C 언어)&lt;/p&gt;

&lt;p&gt;반복문에서 다루었던 루프 탈출 명령어는 사실 일종의 GOTO 문입니다. 그러나 이들은 상당히 역할이 제한된 GOTO 문이므로 가독성에 악영향을 미치지 않고, 오히려 가독성을 향상시키기도 합니다. 왜냐하면 이것들을 사용하지 않는다면 이해하기가 더 어렵거나 부자연스러운 코드가 나타날 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;무조건 분기문을 사용하기 위해서는 어느 위치로 이동할지 표시할 수 있어야 합니다. 이 때 많은 언어들이 코드 앞에 레이블을 붙이는 것으로 해결합니다. ALGOL 60 언어나 C 언어는 식별자를 이용하여 레이블을 붙이고, Fortran 언어나 Pascal은 음이 아닌 상수 정수를 이용하여 나타냅니다. PL/I은 특이하게 변수를 이용한 레이블을 허용합니다.&lt;/p&gt;

&lt;p&gt;이러한 레이블을 허용하는 대부분의 언어에서는 레이블의 사용을 어느 정도 제한하고 있습니다. 만약 Pascal 언어에서 레이블은 변수처럼 정의되지만, 그것을 매개변수로 전달하거나, 저장하거나, 수정할 수 없습니다. 또한 Pascal에서의 GOTO 문은 실행이 시작되었고 아직 종료되지 않은 경우를 제외하고, 제어 구조의 복합문의 명령어를 대상으로 지정할 수 없습니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 슬라이드의 왼쪽에서는 GOTO 100을 지정했지만, 레이블 100을 포함하고 있는 while 문은 이미 실행이 종료되었기 때문에 불가능합니다. 오른쪽과 같이 실행은 되었으나 종료되지 않은 경우에만 지정이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;span style=&quot;color:red&quot;&gt;보호 명령(Guarded Command)&lt;/span&gt;에 대해 알아보겠습니다. 보호 명령은 동시성 프로그래밍(Concurrent Programming)을 위해 도입된 개념이며, 다익스트라가 선택문과 비슷한 구조로 만들었습니다. 보호 명령의 각 줄은 한 개의 불리안 식(보호)와 한 개의 명령어, 또는 명령어 묶음으로 구성됩니다.&lt;/p&gt;

&lt;p&gt;형태는 다중 선택문과 유사하지만, 이 표현식에 도달한다면 모든 불리안 식이 평가됩니다. 둘 이상의 식이 참인 경우, 해당 명령어 중 하나가 비결정적으로(=무작위로) 선택됩니다. 만약 참이 하나도 없다면 프로그램을 종료시키는 실행 시간 오류가 발생합니다. 이것은 프로그래머가 모든 가능성을 고려하도록 강요합니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 슬라이드에 나와 있는 것처럼 Ada 언어로 보호 명령을 구현한 코드를 보겠습니다. 만약 i = 0이고 j = 1이라면, 첫 번째와 세 번째 명령어 중 무작위가 선택되어 수행됩니다. 만약 i = j이고 i가 0이 아니면, 어떤 조건도 참이 아니기 때문에 실행 시간 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;보호 명령을 사용하면 프로그램을 좀 더 깔끔하게 작성할 수 있다는 장점이 있습니다. 예를 들어, 슬라이드 아래에 나와 있는 코드는 4개의 정수 q1, q2, q3, q4가 주어져 있을 때 이를 오름차순으로 정렬하는 코드입니다. 이것은 반복문이기 때문에 모든 불리안 식이 거짓이면 루프가 종료되는 방식입니다. 만약 이것을 보호 명령을 사용하지 않고 구현한다면 정렬 알고리즘을 사용해야 하는데, 이것은 상당히 많은 코드를 요구하는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/008/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 순서도는 보호 명령을 사용한 조건문과 반복문이 어떤 과정을 통해 수행되는지 나타내는 그림입니다. 조건문은 모든 불리안 식이 거짓이면 실행 시간 에러를 내고, 두 개 이상의 조건이 참이면 그 중 무작위로 선택하여 실행합니다. 반복문은 모든 불리안 식이 거짓이면 빠져나오고, 두 개 이상의 조건이 참이면 그 중 무작위로 선택하여 실행합니다. 물론 한 개의 조건만 참이면 그 명령어만 실행합니다.&lt;/p&gt;

&lt;p&gt;8장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Expressions and the Assignment Statement</title><link href="http://localhost:4000/pl/expressions-and-the-assignment-statement/" rel="alternate" type="text/html" title="Expressions and the Assignment Statement" /><published>2023-09-07T00:00:00+09:00</published><updated>2023-09-07T00:00:00+09:00</updated><id>http://localhost:4000/pl/expressions-and-the-assignment-statement</id><content type="html" xml:base="http://localhost:4000/pl/expressions-and-the-assignment-statement/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;7장의 주제는 식과 배정문입니다. 이번 장을 한 문장으로 요약하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“식의 연산자 수행 순서는 언어의 연관성 및 우선순위 규칙에 따라 결정됩니다. 폰 노이만 구조 환경에서 배정문은 가장 기본적인 문장입니다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 먼저 &lt;span style=&quot;color:red&quot;&gt;산술식(Arithmetic Expression)&lt;/span&gt;에 대해 알아보겠습니다. 프로그래밍 언어에서 수학의 산술식과 동일하게 표현하는 것은 고급 언어의 주요 목표 중 하나였습니다. 따라서 프로그래밍 언어에서의 산술식은 수학에서의 관례를 그대로 가져온 경우가 많습니다.&lt;/p&gt;

&lt;p&gt;따라서 연산자의 수행 순서는 수학에서의 그것과 거의 동일합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;식 하나에 서로 다른 우선순위 수준의 연산자가 수행되는 순서는 우선순위의 계층 구조로 평가합니다. 예를 들어, a + b * c에서 * 연산은 + 연산보다 높은 계층에 있기 때문에 먼저 계산합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단항 + 연산자를 &lt;strong&gt;항등 연산자(Identity Operator)&lt;/strong&gt;라고 부릅니다. 왜냐하면 피연산자에 대해 아무런 효과를 미치지 않기 때문입니다. A로 표시하나 +A로 표시하나 의미는 동일합니다. 단항 - 연산자는 피연산자의 부호를 변경합니다. 일반적으로 단항 연산자는 다른 연산자와 인접하는 것을 피하기 위해 소괄호를 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;명령형 언어의 연산자 우선순위 규칙은 거의 모두 동일합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;식에서 동일한 우선순위를 갖는 연산자가 여러 개 존재할 경우, 어떤 연산자가 먼저 수행될 것인지는 프로그래밍 언어의 &lt;span style=&quot;color:red&quot;&gt;결합 법칙(Associativity Rule)&lt;/span&gt;에 따릅니다. 프로그래밍 언어의 결합 법칙은 일반적으로 왼쪽에서 오른쪽 순서입니다. 예를 들어, A - B + C - D 식에서는 A - B가 가장 먼저 계산됩니다. 그러나 예외적인 경우도 있는데, C 언어에서 ++, –, 단항 연산자 +과 -인 경우에는 오른쪽부터 계산됩니다. APL은 특이하게도, 연산자 우선순위가 존재하지 않고 무조건 오른쪽부터 왼쪽으로 수행합니다. 예를 들어, A * B + C 라는 연산이 있다면, APC은 B + C를 먼저 수행합니다.&lt;/p&gt;

&lt;p&gt;만약 컴파일러가 연산자 수행 순서를 변경할 수 있는 경우, 식의 수행을 위한 코드를 더 빨리 생성할 수 있습니다. 무슨 말이냐 하면, 예를 들어 A + B + C + D라는 식이 있다고 가정해봅시다. 기본적으로 정수의 덧셈은 우선순위가 동일하기 때문에 왼쪽부터 수행하게 됩니다. 만약 A와 B가 매우 큰 양수이고, C와 D가 절대값이 매우 큰 음수라면, 순서대로 덧셈을 진행했을 때 A + B는 오버플로를 야기하게 됩니다. 이것은 수학의 문제가 아니라 컴퓨터 산술의 한계로 인해 발생하는 것이기 때문에, 컴퓨터에서는 이것이 동일한 연산이 아닐 수도 있다는 뜻이 됩니다. 따라서 컴파일러가 이러한 덧셈 연산의 순서를 재조정하면 오버플로 문제를 회피할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 프로그래머는 식에 괄호를 포함하여 우선순위 규칙이나 결합 법칙을 변경할 수 있습니다. 예를 들어, (A + B) * C 와 같이 괄호를 포함하여 우선순위가 낮은 덧셈 연산을 곱셈 연산보다 먼저 처리하게 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 연산자의 피연산자가 &lt;span style=&quot;color:red&quot;&gt;부작용(Side Effect)&lt;/span&gt;을 갖고있다면, 피연산자의 수행 순서가 중요합니다. 함수적 부작용이란, 함수가 매개변수나 전역 변수를 변경하는 것을 말합니다. 예를 들어, 위 슬라이드 중간에 있는 코드를 보겠습니다. sub1 프로시저에서 정수형 변수 a가 선언되어 있습니다. 그런데 하위 프로시저 sub2에서 a에 10을 할당하고, b에 a + fun(b)를 할당합니다. 문제는, 함수 fun()에서 a의 값을 변화시키는 명령어가 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;이런 경우 a + fun(b)에서 fun(b)의 실행 순서의 따라 15가 될지, 32가 될지 달라집니다. 이러한 문제를 해결하기 위한 두 가지 해결책이 있습니다. 첫 번째 방법은 처음부터 언어를 설계하는 컴퓨터과학자가 함수적 부작용을 허용하지 않게 만들어서 함수 결과가 식의 값에 영향을 미치는 것을 막는 것입니다. 그러나 명령형 언어에서 이것을 허용하지 않게 되면 프로그램의 유연성이 감소시키는 또 다른 문제가 발생합니다. 예를 들어, 함수적 부작용을 막는다면 함수에서 전역 변수에 접근할 수 없습니다. 두 번째 방법은 식에 포함된 피연산자들이 특정 순서로 수행된다고 정의하는 것입니다. 예를 들어, Java 언어는 피연산자들이 무조건 왼쪽부터 오른쪽으로 수행되는 것으로 정의되었기 때문에 예제 코드와 같은 상황에서 항상 15의 결과가 나옵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 최근 대부분의 고급 언어에서는 if-then-else 문으로 조건 연산을 수행합니다. C 언어 같은 경우에는 더 간단하게 ? 연산자로 표기할 수 있습니다.&lt;/p&gt;

&lt;p&gt;산술 연산자는 여러 가지 목적으로 사용될 수도 있습니다. 예를 들어, + 연산자는 일반적으로 정수나 실수의 덧셈 연산을 수행하는 연산자이지만, Java 언어에서는 문자열을 잇는데 사용할 수도 있습니다. 이것을 &lt;span style=&quot;color:red&quot;&gt;연산자 오버로딩(Operator Overloading)&lt;/span&gt;이라고 부릅니다. 연산자 오버로딩을 남용하면 가독성이나 신뢰성을 낮출 수 있기 때문에 사용에 주의해야 합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 Fortran 언어에서 + 연산은 정수 피연산자에 사용하면 정수 덧셈, 실수 피연산자에 사용하게 되면 실수 덧셈을 수행합니다. 이것은 수학적으로도 일반적인 표현이기 때문에 크게 문제가 되지 않지만, C 언어에서 &amp;amp; 연산자는 이것과 경우가 조금 다릅니다. &amp;amp; 연산자를 이항 연산으로 사용하면 논리 AND 연산을 수행하지만, 단항 연산자라면 변수의 주소를 불러옵니다. 이 경우 만약 C 언어에서 실수로 왼쪽의 피연산자를 누락한다면 컴파일러는 이 오류를 탐지하지 못합니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어는 연산자 오버로딩을 피하기 위해 실수 나눗셈에는 / 연산자를 사용하고, 정수 나눗셈에는 div 연산자를 사용합니다.&lt;/p&gt;

&lt;p&gt;또한 프로그래밍 언어 중에서는 사용자 정의 연산자 오버로딩을 허용하는 경우도 있습니다. 예를 들어 Ada 언어는 오버로딩 된 연산자를 발견하면 피연산자의 타입에 따라 올바른 의미를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 &lt;span style=&quot;color:red&quot;&gt;타입 변환(Type Conversion)&lt;/span&gt;에 대해 알아보겠습니다. 타입 변환에는 두 가지 종류가 있는데, 컴파일러에 의해 수행되는 묵시적 타입 변환(Coercion)과 프로그래머가 명시적으로 수행하는 타입 변환(Casting)이 있습니다.&lt;/p&gt;

&lt;p&gt;타입 변환으로 데이터 타입은 축소될 수도 있고 확장될 수도 있습니다. Java 언어에서 double 데이터 타입을 float로 변환하는 것은 &lt;strong&gt;축소 변환(Narrowing Conversion)&lt;/strong&gt;입니다. 반대로 float 데이터 타입을 double로 변환하는 것은 &lt;strong&gt;확장 변환(Widening Conversion)&lt;/strong&gt;입니다. 확장 변환은 거의 항상 안전하지만, 축소 변환은 상황에 따라 값의 크기가 변경될 수 있으므로 위험합니다.&lt;/p&gt;

&lt;p&gt;확장 변환은 대부분 안전하지만, 정확성을 낮추는 문제가 발생할 수도 있습니다. 예를 들어, int 데이터 타입을 float로 변환한다고 가정해봅시다. int는 일반적으로 32비트에 저장되는데, float도 마찬가지로 32비트에 저장됩니다. 따라서 int에서의 정수는 9자리 십진수까지 정확하게 저장할 수 있지만, float는 단지 7자리 십진수까지의 정확성만 보장됩니다. 따라서 정수 데이터 타입에서 부동 소수점 데이터 타입으로의 확장 변환은 정확성 손실이 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;묵시적 타입 변환의 설계 방법에 대해 자세히 알아보겠습니다. Fortran 77의 경우 모든 숫자형 데이터 타입은 확장 변환으로만 묵시적 타입 변환이 수행됩니다. 고전 C 언어의 경우에는 거의 항상 확장 변환이 수행됩니다. 예를 들어, float나 short int와 같은 데이터 타입으로도 수행 가능한 연산이라고 할지라도, 식이나 매개변수로써 사용될 때 항상 double이나 int로 강제 변환됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 하나의 식 안에 여러 데이터 타입이 혼재할 때도 타입 변환이 일어날 수 있습니다. 이것은 타입 검사와도 연관된 내용입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 Fortran 77에서, A, B, C는 정수형 변수로, D는 실수형 변수로 정의가 되어 있습니다. 그리고 C = FUN(A + D) 식을 수행하는데, FUN() 함수는 매개변수로 정수형 변수가 들어가야 합니다. 이 경우 A + D가 정수 + 실수이기 때문에 엄밀한 타입 검사를 수행할 경우 오류가 발생해야하지만, Fortran 77은 이것을 오류로 탐지하지 않고 A를 실수 타입으로 강제로 변환합니다. 이와 달리 Ada 언어와 Modula-2 언어는 식에서 정수와 부동 소수점 실수의 연산을 허용하지 않습니다.&lt;/p&gt;

&lt;p&gt;명시작 타입 변환은 Ada 언어와 Modula-2 언어에서 함수 호출로 수행합니다. 예를 들어, FLOAT(SUM)과 같이 함수의 매개변수로 변수를 넣어서 그 반환값을 원하는 데이터 타입으로 받은 구조입니다. C 언어에서는 소괄호를 이용하여 (int) SUM과 같이 표기합니다.&lt;/p&gt;

&lt;p&gt;이러한 타입 변환은 식의 오류를 발생시킬 수도 있습니다. 이런 오류는 주로 컴퓨터의 산술 연산의 한계로 인해 발생합니다. 계산 결과가 너무 작으면 &lt;strong&gt;언더플로(Underflow)&lt;/strong&gt;나 너무 크면 &lt;strong&gt;오버플로(Overflow)&lt;/strong&gt; 문제가 발생할 수 있습니다. 또한 강제 변환으로 인해 값이 0으로 변환되어 나눗셈에서 오류가 발생할 수도 있습니다. 이러한 오류를 &lt;span style=&quot;color:red&quot;&gt;예외(Exception)&lt;/span&gt;라고 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 &lt;span style=&quot;color:red&quot;&gt;관계식(Relational Expression)&lt;/span&gt;에 대해 알아보겠습니다. 관계식은 2개의 피연산자와 1개의 관계 연산자(Relational Operator)로 이루어진 식입니다. 관계식의 결과값은 Boolean 타입(True/False)입니다. 관계 연산자는 일반적으로 다양한 데이터 타입에 대해 오버로딩 될 수 있습니다. 관계식의 참이나 거짓을 결정하는 연산은 피연산자의 타입에 따라 달라집니다. 피연산자가 정수인 경우에는 단순하지만, 문자열인 경우에는 다소 복잡할 수도 있습니다. 관계 연산자는 항상 산술 연산자보다 우선순위가 낮다는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;불리안 식(Boolean Expression)&lt;/span&gt;은 불리안 변수, 불리안 변수, 관계식, 불리안 연산자로만 구성된 식을 말합니다. 불리안 연산자는 AND, OR, NOT을 말합니다. 이러한 식에서도 연산자간의 우선순위가 존재합니다. (C99 이전의) C 언어 같은 경우에는 Boolean 타입이 없기 때문에 Boolean 값도 없습니다. 대신 0은 false, 그 외의 값은 모두 true로 취급합니다. 따라서 a &amp;gt; b &amp;gt; c와 같은 연산이 가능하지만, 실제 이 식에서 b &amp;gt; c 연산은 수행되지 않습니다. C 언어는 이러한 특성으로 인해 불리안 식에서 오류를 감지하기 어렵습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;단락 평가(Short-circuit Evaluation)&lt;/span&gt;는 모든 피연산자와 연산자를 수행하지 않고 결과가 결정되는 것을 말합니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(13 * A) * (B / 13 - 1)&lt;/code&gt; 이란 식은 A가 0이라면 나머지 식을 계산할 필요도 없이 0이 나옵니다. 그러나 컴퓨터는 실행 중에 이러한 산술식을 쉽게 발견하기 어렵기 때문에 일반적으로 고려되지 않습니다.&lt;/p&gt;

&lt;p&gt;그러나 불리안 식의 경우는 조금 다릅니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(A &amp;gt;= 0) and (B &amp;lt; 10)&lt;/code&gt;라는 식은 A &amp;lt; 0이면 (B &amp;lt; 10)의 결과는 볼 필요도 없습니다. 산술식과는 달리, 컴퓨터는 이러한 단락을 쉽게 발견할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어에서는 단락 평가를 사용하지 않으므로 때때로 실행 시간 오류를 발생시킵니다. 예제의 코드를 보면, 단락 평가를 사용하지 않을 때는 항상 while 문 내의 두 개의 식을 모두 수행합니다. 이 식에서 마지막 루프에서 index의 값은 11이 되는데, 만약 단락 평가를 사용한다면 (index &amp;lt;= listlen)이 False이기 때문에 바로 while문을 빠져나옵니다. 그러나 단락 평가를 사용하지 않는다면 (list[index] &amp;lt;&amp;gt; key) 식까지 수행해야 하는데, 이 때 list[11]은 배열의 범위 밖이기 때문에 실행 시간 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;Fortran 언어에서는 결과를 결정하는 데 필요한 것보다 더 많은 식을 수행하지 않도록 선택할 수 있습니다. 그런데 이 경우에도 문제가 발생할 수 있습니다. 만약 수행하지 않는 식에 부작용이 있는 경우인데요, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a &amp;gt; b) || (b++ / 3)&lt;/code&gt;에서 (a &amp;gt; b)가 True이면 뒤의 연산은 수행할 필요가 없습니다. 그런데 이 식에는 ++ 라는 증감 연산자가 포함되어 있습니다. 프로그래머는 항상 이 식이 수행될 때마다 b의 값을 증가시키고 싶었겠지만, 그것이 수행되지 않는다면 의도대로 동작하지 않는다는 문제가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어에서는 프로그래머가 and then과 or else의 연산자를 사용하여 불리안 연산자 and와 or가 단락 평가를 할 수 있도록 허용합니다. 슬라이드에 나온 코드는 이전 슬라이드의 Pascal 언어와 동일한 역할을 수행하지만, 범위를 벗어난 실행 시간 오류를 발생시키지 않습니다.&lt;/p&gt;

&lt;p&gt;C 언어와 Modula-2에서는 AND와 OR 연산 모두 기본적으로 단락 평가를 수행합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;단락 평가의 여부는 Ada 언어와 같이 프로그래머에게 선택권을 주는게 가장 좋은 설계입니다. Ada의 and then과 or else는 불리안 식의 일부를 조건부로 평가하는데 사용됩니다. 단락 평가의 올바른 사용은 이전 슬라이드의 코드처럼 예외를 발생시키는 식의 수행을 방지하는 것입니다.&lt;/p&gt;

&lt;p&gt;단락 평가의 여부를 프로그래머에게 맡겼기 때문에 프로그래머는 코드 설계를 정확하게 수행할 필요가 있습니다. 예를 들어, 중간에 있는 코드에서 G(Dog)는 Dog가 null이 아닌 경우에만 수행됩니다. and then이 없으면 항상 G(Dog)가 수행되어 Dog가 null 일 때 예외가 발생합니다.&lt;/p&gt;

&lt;p&gt;Ada에서 and then과 or else는 오버로딩 될 수 없으므로, 엄밀히 말하면 연산자가 아닙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;배정문(Assignment Statement)&lt;/span&gt;은 명령형 언어의 핵심 구성 요소 중 하나로써, 프로그래머가 변수에 대한 값의 바인딩을 동적으로 변경할 수 있는 메커니즘입니다.&lt;/p&gt;

&lt;p&gt;가장 간단한 배정문은 대상 변수, 배정 연산자, 식으로 구성되어 있습니다. 배정 연산자(Assignment Operator)는 최근 대부분의 언어에서 ‘=’를 사용합니다만, 과거에는 동등 연산자과 구분하기 위해 ‘:=’를 사용했습니다. 현재 동등 연산자는 ‘==’를 사용하기 때문에 배정 연산자와 구분이 가능합니다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어에 따라 대상이 여러 변수인 경우에도 배정이 가능한 경우가 있습니다. 예를 들어, PL/I의 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM, TOTAL = 0&lt;/code&gt;을 사용하면 SUM과 TOTAL 변수에 모두 0이 배정됩니다. C 언어의 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM = TOTAL = 0&lt;/code&gt;을 이용하서 같은 배정을 수행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배정문에 조건을 넣어 값을 배정하는 것도 가능합니다. 예를 들어, C++ 언어에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flag ? count1 : count 2 = 0;&lt;/code&gt; 라는 표현은 다음 코드와 동일한 의미를 갖습니다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;count1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;count2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;복합 배정 연산자(Compound Assignment Operator)&lt;/span&gt;는 배정문의 좌변과 우변에서 공통적으로 사용되는 피연산자를 축약하는 방법입니다. 예를 들어, C 언어에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum = sum + value;&lt;/code&gt; 와 같이 좌변과 우변에서 동일한 변수가 사용될 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum += value;&lt;/code&gt;로 표현하는 것을 허용합니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;단항 배정 연산자(Unary Assignment Operator)&lt;/span&gt;는 증가 연산이나 감소 연산을 배정문으로 축약하여 단일 연산자로 사용하는 방법입니다. 예를 들어, C 언어에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count = count + 1;&lt;/code&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count++;&lt;/code&gt;로 축약하여 표현할 수 있습니다. 단항 배정 연산자를 지원하지 않는 언어는 대표적으로 Python 언어가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C를 비롯한 C 기반 언어들에서 배정문은 배정되는 값과 동일한 결과를 생성합니다. 그래서 배정문 자체를 식의 피연산자로 쓸 수 있습니다. 예를 들어, 슬라이드의 반복문에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch = get()&lt;/code&gt; 이라는 배정문이 있습니다. 이때 ch에는 표준 입력으로 받은 문자가 들어가지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch = get()&lt;/code&gt;의 수행 결과도 동일하게 해당 문자가 들어갑니다. 이 때, 반드시 소괄호로 영역을 지정해줘야 합니다. 왜냐하면 배정 연산자는 관계 연산자보다 우선순위가 낮기 때문입니다. (그 경우 ch에는 0이나 1의 값이 들어갑니다)&lt;/p&gt;

&lt;p&gt;이러한 표현을 허용하는 것은 가독성을 매우 낮추는 단점이 있습니다. 대신 이 방법을 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum = count = 0;&lt;/code&gt;처럼 여러 대상에게 동시에 할당하는 것이 가능해집니다. 다만 이로 인해 관련 오류를 찾기 힘들어지는 단점이 있습니다. C 언어를 처음 배울 때  조건문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x == y&lt;/code&gt;가 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x = y&lt;/code&gt;를 입력하는 실수를 하신 분들이 많을겁니다. 만약 이것이 오류라면 컴파일러가 오류를 잡아주지만, C 언어에서는 이게 정상적인 식으로 인식되기 때문에 직접 눈으로 찾지 않는 이상 발견할 수 없다는 문제가 있습니다. 따라서 Java 언어는 이것을 불허하여 이 문제를 예방하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/007/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;혼합형 식과 마찬가지로 &lt;span style=&quot;color:red&quot;&gt;혼합형 배정문(Mixed-mode Assignment)&lt;/span&gt;도 존재할 수 있습니다. 혼합형 배정문을 설계할 때는 다음을 고려해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;식의 타입이 할당되는 변수의 타입과 동일해야 하는가?&lt;/li&gt;
  &lt;li&gt;두 타입이 일치하지 않는 경우에는 타입 강제 변환을 사용해야 하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortran 언어(그리고 C)에서는 혼합형 식에서 사용되는 것처럼 혼합형 배정문에 타입 강제 변환을 사용합니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어에서는 부동 소수점 변수에 할당할 수 있는 일부 강제 변환 정수가 포함되어 있습니다.&lt;/p&gt;

&lt;p&gt;Ada 언어나 Modula-2 언어에서 할당할 때는 정수를 부동 소수점으로 강제 변환하는 것을 허용하지 않습니다.&lt;/p&gt;

&lt;p&gt;7장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Data Types</title><link href="http://localhost:4000/pl/data-types/" rel="alternate" type="text/html" title="Data Types" /><published>2023-09-01T00:00:00+09:00</published><updated>2023-09-01T00:00:00+09:00</updated><id>http://localhost:4000/pl/data-types</id><content type="html" xml:base="http://localhost:4000/pl/data-types/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;6장에서는 데이터 타입의 개념과 각 데이터 타입의 특성을 소개합니다. 이번 장을 한 문장으로 요약하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“컴퓨터 프로그램은 데이터를 조작하여 결과를 생성합니다. 이 작업을 쉽게 수행할 수 있는지 판단하는 중요한 요소는 데이터 타입이 실제 문제와 얼마나 유사한가입니다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;데이터 타입(Data Type)&lt;/span&gt;은 데이터 값들의 모임과 그 값들에 대해 미리 정의된 연산들의 집합으로 정의됩니다. 프로그램은 데이터를 토대로 여러 연산을 통해 결과를 도출하기 때문에, 사용하는 언어에서 제공하는 데이터 타입이 현실의 문제와 얼마나 잘 매칭되는가가 중요합니다.&lt;/p&gt;

&lt;p&gt;몇 가지 사례를 소개하자면, Fortran 90 이전에는 기본적인 데이터 구조만을 지원했기 때문에, 연결 리스트나 트리가 모두 배열로 구현되었습니다. COBOL은 십진수의 데이터 값과 레코드를 위한 데이터 타입을 지원했습니다. PL/I는 다양한 분야에 사용하는 것을 목적으로 만들어졌기 때문에 많은 데이터 타입을 지원하였습니다. ALGOL 68은 기본적인 데이터 타입을 지원하되, 필요한 경우 사용자가 직접 만들 수 있는 데이터 타입을 지원하였습니다. Ada 언어에 이르러서는 추상 데이터 타입을 지원하기 시작했습니다. 추상 데이터 타입은 직접적으로 구현 방법을 명시하지는 않고 데이터와 데이터에 대한 연산을 나타내는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;원시 데이터 타입(Primitive Data Type)&lt;/span&gt;은 다른 타입의 관점에서 정의되지 않은 데이터 타입을 말합니다. 즉, 언어에서 기본적으로 제공하는 데이터 타입이라고 생각하시면 됩니다. 이러한 데이터 타입은 표현과 연산이 하드웨어에서 지원하는데, 구조화된 타입을 제공하기 위해서는 원시 데이터 타입과 함께 한 개 이상의 타입 생성자가 함께 사용됩니다.&lt;/p&gt;

&lt;p&gt;원시 데이터 타입 중 &lt;strong&gt;수치 타입(Numeric Type)&lt;/strong&gt;에 대해 알아보겠습니다. 수치 타입 중 가장 대표적인 타입이 바로 &lt;span style=&quot;color:red&quot;&gt;정수(Integer)&lt;/span&gt;입니다. 정수형 타입은 컴퓨터에 따라 다른 크기가 지원되는데, 예를 들어 byte, word, long word, quadword 등이 있습니다. C, C++, C# 등과 같은 언어에서는 부호가 없는 정수(Unsigned Int) 타입을 지원하는데, 이것은 주로 이진 데이터에 대해 사용합니다.&lt;/p&gt;

&lt;p&gt;Word가 실제로 메모리에 차지하는 비트의 수는 컴퓨터의 CPU에 따라 달라집니다. (16비트 컴퓨터, 32비트 컴퓨터 등)&lt;/p&gt;

&lt;p&gt;정수 자료형을 구현할 때는 비트 문자열로 표기하며, 일반적으로 가장 왼쪽에 있는 비트는 부호를 나타냈습니다. 그러나 최근에는 덧셈과 뺄셈 연산이 편리한 2의 보수(2’s Compliment) 표기법을 많이 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실수를 모델링하기 위해서는 일반적으로 &lt;span style=&quot;color:red&quot;&gt;부동 소수점(Floating Point)&lt;/span&gt;을 사용합니다. 그러나 부동 소수점은 대부분 실수 값을 근사할 뿐입니다. 많이 사용되는 실수인 $\pi$나 $e$ 조차 정확하게 표기가 불가능합니다. 예를 들어 십진수 0.1을 부동 소수점으로 표기한다면, 이진수 0.0001100110011…로 정확하게 표현되지 않습니다.&lt;/p&gt;

&lt;p&gt;부동 소수점 데이터 타입은 대부분의 언어에 포함되어 있지만, 많은 소형 컴퓨터에서는 하드웨어에서 지원하지 않는 경우가 많습니다. 이런 경우 고정 소수점 방식을 사용하거나, 아니면 근사치를 나타낸 표를 저장하여 처리하기도 합니다. 그러나 이런 경우까지 고려하실 필요는 없고, 과학적인 프로그래밍을 지원하는 언어에서는 일반적으로 float와 double이라는 두 가지 타입을 제공합니다.&lt;/p&gt;

&lt;p&gt;부동 소수점은 IEEE 754 규격을 이용하여 구현하는데, 이것은 부호 비트, 지수부, 소수부로 구성되어 있습니다. double 타입은 일반적으로 더 정밀한 소수를 표현하기 위해서 사용하므로, float 타입에 비해 두 배 이상의 소수부를 갖고 있는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비즈니스 업무에 사용하는 것이 상정된 컴퓨터들은 하드웨어에서 &lt;span style=&quot;color:red&quot;&gt;십진수(Decimal)&lt;/span&gt; 데이터 타입을 지원합니다. 십진수 타입은 부동 소수점과 다르게 제한된 범위 내에서 소수 값을 정확하게 저장할 수 있는 장점이 있습니다. 대표적인 십진수 데이터 타입은 &lt;strong&gt;BCD(Binary Coded Decimal)&lt;/strong&gt;로, 이진수 코드를 사용하여 문자열과 비슷하게 저장하는 방식입니다. BCD에는 packed 방식과 unpacked 방식이 있습니다. unpacked 방식은 자리수 하나당 1개의 바이트를 이용해서 표현하는 방식이고 (4개는 의미 없음), packed 방식은 2개의 자리를 1개의 바이트로 압축하여 표현하는 방식입니다. unpacked 방식의 경우 남는 4개의 비트를 1로 채우지만, 마지막 글자의 경우 숫자가 양수인지 음수인지에 따라 다릅니다. 양수의 경우 1100, 음수의 경우에는 1101로 표현합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;불리안 타입(Boolean Type)&lt;/span&gt;은 참과 거짓만 나타낼 수 있는 가장 간단한 데이터 타입입니다. ALGOL 60에서 처음 도입되었으며, 스위치나 플래그를 표현하기 위해서 사용합니다. 불리안 타입은 한 개의 비트로 표현이 가능하지만, 컴퓨터에서 한 개의 비트를 효율적으로 접근할 수 없기 때문에 일반적으로 1개의 바이트로 구현됩니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;문자 타입(Character Type)&lt;/span&gt;은 일반적으로 수치 값으로 컴퓨터에 저장됩니다. 가장 많이 사용하는 기법은 ASCII(American Standard Code for Information Interchange)로써 0부터 127까지의 값을 사용합니다. 그러나 세계화가 이루어짐에 따라 128개의 글자가 부족해졌고, 결국 1991년 Unicode라는 새로운 규격이 만들어졌습니다. C 언어와 C++ 언어는 계속 ASCII 코드를 사용하지만, Java, Python과 같이 그 뒤에 나온 언어들은 Unicode를 사용하여 문자를 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;문자열 타입(Character String Type)&lt;/span&gt;은 문자들로 구성되는 타입입니다. 문자열은 문자 조작을 하는 모든 프로그램에서 필수적인 데이터 타입입니다. 문자열 타입을 설계할 때 중요한 두 가지 고려사항이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스트링이 원시 타입인가, 아니면 단순히 문자 배열의 특수한 종류인가?&lt;/li&gt;
  &lt;li&gt;스트링이 정적의 길이를 갖는가, 아니면 동적인 길이를 갖는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저 첫 번째 고려사항부터 살펴보겠습니다. 문자열을 단순히 문자의 배열로 취급하는 대표적인 언어가 바로 C 언어입니다. 이러한 언어들에서는 표준 라이브러리를 통해 문자열 연산 기능을 제공하며(string.h), 널 문자(\0)를 이용하여 문자의 끝을 나타냅니다.&lt;/p&gt;

&lt;p&gt;반대로 문자열을 원시 타입으로 제공하는 언어들도 있습니다. Java나 Python이 채택한 방법인데, 이러한 방법은 언어의 작성력이 증가하며 그에 따른 비용도 크지 않다는 장점이 있습니다. 원시 타입으로 문자열 타입을 제공할 경우, 할당, 관계 연산자, 연결 및 하위 문자열 참조와 같은 기능을 기본 연산으로 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로는 문자열 길이에 관한 고려사항입니다. 생성될 때 길이가 같이 정해지는 문자열을 &lt;span style=&quot;color:red&quot;&gt;정적 길이 스트링(Static Length String)&lt;/span&gt;이라고 합니다. Fortran 77과 90, COBOL, Ada 언어에서 기본적으로 제공하는 문자열이 바로 이런 방식입니다.&lt;/p&gt;

&lt;p&gt;다른 방법으로는 문자열 변수를 선언할 때 길이가 같이 선언되지만, 고정된 최대 길이까지 가변적인 길이를 갖는 것을 허용하는 &lt;span style=&quot;color:red&quot;&gt;제한된 동적 길이 스트링(Limited Dynamic Length String)&lt;/span&gt;이 있습니다. C 언어에서의 문자열이 바로 이런 구조입니다. 왜냐하면 문자열의 길이를 나타낼 때, 배열의 길이 자체가 변하는 것이 아니라 널 문자가 어디에 있는지에 따라 문자열의 끝이 달라지기 때문입니다.&lt;/p&gt;

&lt;p&gt;마지막 방법은 문자열이 최대 길이의 제한 없이 가변 길이를 갖는 것을 허용하는 &lt;span style=&quot;color:red&quot;&gt;동적 길이 스트링(Dynamic Length String)&lt;/span&gt; 방식입니다. JavaScript나 C++ 언어가 이러한 방식을 채택하고 있는데, 동적 기억공간 할당과 회수에 따른 부담이 늘어나지만 유연성을 갖는다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;특이하게 Ada 95 이후의 Ada 언어는 이 세 가지 방법을 모두 지원합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문자열 타입은 언어의 작성력에 중요한 요소입니다. 문자열을 배열로 다루는 것은 원시 타입으로 다루는 것보다 더 복잡해질 수 있습니다. 예를 들어, C 언어에서 strcpy를 사용하지 않고 구현한다고 하면 반복문이 반드시 필요합니다. 프로그래밍 언어에서 문자열을 원시 타입으로 추가하는 것은 비용도 거의 들지 않는 일이기 때문에 굉장히 비효율적인 일입니다. 따라서 현대 프로그래밍 언어에서는 대부분 문자열을 원시 타입으로써 제공합니다. 패턴 매칭이나 접합과 같은 연산은 대부분의 프로그램에서 필수적이기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문자열 타입은 하드웨어에서 직접 지원될 수도 있지만, 대부분의 경우에는 소프트웨어로써 구현됩니다. 만약 문자열 타입이 문자 배열로 표현되는 경우에는 언어 자체에서 문자열 관련 연산을 거의 제공하지 않습니다.&lt;/p&gt;

&lt;p&gt;정적 길이 스트링에서 변수의 속성 모음(Descriptor)은 컴파일 과정에서만 요구되며, 변수 이름, 길이, 첫 번째 문자가 저장된 주소입니다. 제한된 동적 길이 스트링에서는 변수 이름, 첫 번째 문자가 저장된 주소, 최대 길이, 현재 길이가 저장되며 실행 시간 속성 모음이 필요합니다. 이 두 방법에서는 동적 기억공간 할당이 필요하지 않습니다. 제한된 동적 길이 스트링도 변수가 기억공간에 바인딩될 때 최대 길이까지 저장할 수 있는 크기만큼 할당되기 때문입니다.&lt;/p&gt;

&lt;p&gt;그러나 동적 길이 스트링의 구현은 다소 복잡합니다. 첫 번째 방법은 연결 리스트에 문자열을 저장하는 것입니다. 만약 문자열의 길이가 늘어난다면 새로 필요한 기억공간은 힙의 무작위 위치에서 생성됩니다. 이 방법은 보다 많은 공간이 필요하고 접근도 느리다는 단점이 있습니다. 두 번째 방법은 문자열 전체를 인접한 기억공간에 저장하는 것입니다. 문제는 동적 길이 스트링은 문자열이 얼마나 늘어날지 예측할 수 없다는 것입니다. 따라서 이 방법에서 문자열의 길이가 늘어난다면, 문자열 전체를 저장할 수 있는 새로운 영역으로 이동합니다. 이 방법은 첫 번째 방법에 비해 접근이 빠르고 저장공간을 비교적 적게 차지하지만, 할당 시간이 느리다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;순서 타입(Ordinal Type)&lt;/span&gt;은 가능한 값의 범위가 양의 정수의 집합과 관련이 있는 타입입니다. Pascal이나 Java에서 제공하는 기본 순서 타입은 Integer, char, boolean 등이 있습니다. 일반적으로 프로그래밍 언어에서 지원하는 사용자 정의 순서 타입은 &lt;strong&gt;열거(Enumeration)&lt;/strong&gt; 타입과 &lt;strong&gt;부분범위(Subrange)&lt;/strong&gt; 타입입니다.&lt;/p&gt;

&lt;p&gt;열거 타입은 기호 상수(Symbolic Constant)인 모든 가능한 값들이 열거되는 타입입니다. 대표적으로 슬라이드에 나온 Ada 언어에서 요일을 저장한 타입이 있습니다. 이러한 열거 타입은 전형적으로 0, 1, … 등의 정수가 할당되지만, 정의에 따라 임의의 정수가 할당될 수도 있습니다. 열거 타입을 설계할 때 고려할 것들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;열거 상수가 한 개 이상의 타입 정의에 나타나는 것이 허용되는가?&lt;/li&gt;
  &lt;li&gt;그렇다면, 프로그램에서 이러한 상수 참조시 그 타입이 어떻게 검사되는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 고려 사항들은 타입 검사와 관련이 있습니다. 만약 열거 변수가 수치 타입으로 강제 변환되면, 연산들의 범위나 값들에 대한 제어가 없습니다. 따라서 이제부터 각각 언어에서 열거 타입을 어떻게 구현하였는지 자세히 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal, C, C++ 언어 같은 경우에 열거 상수는 주어진 참조 환경에서 둘 이상의 열거 타입에 사용될 수 없습니다. 또한 열거형 변수는 배열 첨자, 반복문의 변수, Case 문의 선택기로도 사용할 수 있습니다. 또한 관계 연산자와도 비교할 수 있습니다. 이러한 것들이 가능한 이유는, 열거 변수가 정수 문맥에서 사용될 때 정수형 변수로 강제 변환되기 때문입니다. 그러나 반대로 다른 타입의 값이 열거 타입으로 강제 변환되지는 않습니다.&lt;/p&gt;

&lt;p&gt;Ada 언어 같은 경우에는 동일 환경에서 열거 상수가 두 개 이상의 선언에서 정의될 수 있습니다. 이것을 &lt;span style=&quot;color:red&quot;&gt;중복 리터럴(Overloaded Literal)&lt;/span&gt;이라고 부릅니다. Ada에서는 타입 검사를 위해 열거 변수가 정수형 변수로 강제 변환되지 않습니다. 이는 컴파일 시간에서 문맥 오류를 탐지하는 것을 가능하게 합니다.&lt;/p&gt;

&lt;p&gt;열거 타입을 사용하는 이유는 매우 직접적인 방식으로 가독성을 증가시키기 때문입니다. 이름을 통해 정의된 값은 쉽게 인식되지만, 숫자로 코드화할 경우 쉽게 인식하기 어렵기 때문입니다. 숫자형 데이터 타입과 비교했을 때, 산술 연선이 불가능하고 범위 오류를 쉽게 감지할 수 있다는 장점이 있습니다. 열거형 변수에는 정의된 범위 밖의 값을 할당할 수 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부분 범위 타입은 순서 타입의 연속된 부분 순서열입니다. 예를 들면, Pascal 언어에서 index를 1부터 100까지의 범위를 갖는 변수로 설정했습니다. 이것은 정수의 연속된 부분 순서열이라고 볼 수 있습니다. 부분 범위 타입을 사용하는 이유는 가독성과 안정성이 증가하기 때문입니다. 간단한 타입이기 때문에, 설계할 때 고려사항은 딱히 없습니다. 다만 왜인지 Ada 95 이후로는 대부분의 언어에서 부분 범위 타입을 지원하지 않습니다. (왜 그런지 교재 제작자도 이상하게 생각하더라구요)&lt;/p&gt;

&lt;p&gt;앞서 소개한 대로, 이러한 사용자 정의 순서 타입의 구현은 보통 (음이 아닌) 정수로 구현됩니다. 부분 범위 타입은 범위 검사가 포함되어야 한다는 점만 제외하면 상위 유형(정수형 타입)과 동일한 방식으로 구현됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;배열(Array)&lt;/span&gt;은 동질적인 데이터 원소들의 묶음으로, 개개의 원소는 배열의 첫 번째 원소와 상대적인 위치에서 식별됩니다. 배열의 원소들은 모두 동일한 데이터 타입을 갖고, 배열 원소에 대한 참조는 대괄호와 같은 첨자 식을 이용하여 나타냅니다. 이 때, 참조되고 있는 메모리 위치의 주소를 결정하기 위해 실행 시간 계산이 추가로 필요합니다.&lt;/p&gt;

&lt;p&gt;배열 타입을 설계할 때 고려해야할 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아래 첨자에는 어떤 유형이 적합한가? (정수형, 순서형 등)&lt;/li&gt;
  &lt;li&gt;아래 첨자의 범위는 언제 바인딩되는가? (실행 시간 vs 컴파일 시간)&lt;/li&gt;
  &lt;li&gt;배열 할당은 언제 발생하는가? (실행 시간 vs 컴파일 시간)&lt;/li&gt;
  &lt;li&gt;아래 첨자는 몇 개나 허용되는가? (가능한 차원의 수)&lt;/li&gt;
  &lt;li&gt;공간이 할당될 때 배열이 초기화되는가?&lt;/li&gt;
  &lt;li&gt;어떤 종류의 슬라이스가 존재하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 페이지부터 이러한 고려 사항을 하나씩 따져보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열의 원소들은 두 단계의 구문 메커니즘에 의해 참조됩니다. 첫 번째는 배열의 이름이고, 두 번째는 첨자나 색인입니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a[100]&lt;/code&gt;과 같이 참조할 때, a가 배열의 이름이고, 100이 첨자입니다. 선택 연산은 배열 이름과 첨자로부터 하나의 원소로 매핑하는 것으로 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;배열에서 첨자를 표시할 때 소괄호를 이용하는 경우도 있고 대괄호를 이용하는 경우도 있습니다. Fortran과 PL/I이 개발되었을 당시에는 첨자를 나타낼 적절한 문자가 없었기 때문에 소괄호를 선택하였습니다. 그러나 소괄호를 사용하는 경우에는 함수에서 인자를 호출하는 것과 혼동될 여지가 있었기 때문에, 90년대 이후로는 대괄호를 이용하여 첨자를 표시하게 됩니다.&lt;/p&gt;

&lt;p&gt;배열의 첨자 타입은 일반적으로 정적으로 바인딩됩니다. 먼저 첨자 범위의 하한은 C 계열 언어에서 0으로 정의되며, Fortran 1, 2, 4에서는 1로 고정됩니다. Fortran 77과 90에서도 기본적으로 1로 설정되어 있지만, 임의의 정수로 설정할 수 있습니다. 이 범위가 프로그래머로부터 명시적으로 선언되어야 하는 언어도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열 첨자의 범위에 대한 바인딩과 저장공간에 대한 바인딩을 토대로 다음과 같이 네 가지 종류로 나눌 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;정적 배열(Static Array)&lt;/strong&gt; : 첨자의 범위와 기억공간 할당이 모두 정적으로 바인딩되는 배열입니다. 따라서 실행 시간 전에 바인딩이 끝나며, 동적 할당이나 회수가 이루어지지 않기 때문에 매우 효율적이라는 장점이 있습니다. Fortran 77의 배열이 이 방법을 채택하고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고정 스택 동적 배열(Fixed Stack Dynamic Array)&lt;/strong&gt; : 첨자의 범위는 정적으로 바인딩되지만, 기억공간 할당이 실행 시간 중에 발생하는 배열입니다. 두 개의 부프로그램이 있고, 각각 고정 스택 동적 배열을 갖고 있다면 동시에 실행되지 않는 한 그 배열들은 기억공간을 공유하기 때문에 기억공간을 효율적으로 사용할 수 있다는 장점이 있습니다. 대신 할당과 회수 시간이 별도로 소모되는 단점도 있습니다. Pascal의 지역 배열이 이 방법을 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스택 동적 배열(Stack Dynamic Array)&lt;/strong&gt; : 첨자의 범위와 기억공간의 바인딩이 모두 실행 시간 중에 동적으로 바인딩되는 배열입니다. 그러나 일단 첨자 범위가 바인딩되고 기억공간이 할당되면 변수의 수명 동안 고정됩니다. 이 방법은 배열이 사용되기 전까지 미리 선언할 필요가 없기 때문에 유연성이 높다는 장점이 있습니다. C 언어가 대표적으로 이 방법을 사용하고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;힙 동적 배열(Heap Dynamic Array)&lt;/strong&gt; : 첨자의 범위와 기억공간의 바인딩이 모두 동적이며, 배열의 수명 동안 변경이 가능한 배열입니다. 스택 동적 배열보다 더 유연하다는 장점이 있습니다만, 힙으로부터 할당과 해제가 일어나기 때문에 더 느리다는 단점이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여담으로 다양한 데이터 타입을 저장할 수 있는 배열도 있습니다. 이러한 배열을 &lt;span style=&quot;color:red&quot;&gt;이기종 배열(Heterogeneous Array)&lt;/span&gt;이라고 부르는데, 배열의 원소가 동일한 데이터 타입일 필요가 없는 배열입니다. Perl, Python, JavaScript, Ruby 등에서 지원되며, 이 배열은 그 특성상 힙 동적 배열로 정의됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 다룰 내용은 배열의 첨자 수에 관한 설계입니다. 프로그래밍 언어의 역사에서 다루었듯이, Fortran I의 경우에는 첨자를 3개까지만 허용했습니다. 즉, 3차원 배열까지만 생성이 가능했다는 것입니다. 이후 Fortran 77과 90에서는 최대 7개를 지원했고, 그 이후 등장한 언어들에서는 무제한 차원의 배열이 가능했습니다.&lt;/p&gt;

&lt;p&gt;의외로 C 언어는 1개의 첨자만 사용할 수 있습니다. 그러나 배열 자체가 배열의 원소가 될 수 있으므로, 다차원 배열의 생성이 가능한 것입니다. 이와 같은 방식을 &lt;span style=&quot;color:red&quot;&gt;직교 설계(Orthogonal design)&lt;/span&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;몇몇 언어는 배열이 기억공간에 할당되는 시점에 배열을 초기화하는 방법을 제공합니다. 예를 들어, Fortran 77에서는 모든 데이터가 정적으로 할당되므로 DATA 문을 사용한 로드 시간 초기화가 허용됩니다.&lt;/p&gt;

&lt;p&gt;C 언어 또한 정적 배열을 이용한 초기화가 가능합니다. 그러나 동적 배열은 이런식으로 초기화가 불가능합니다.&lt;/p&gt;

&lt;p&gt;Pascal이나 Modular-2와 같은 언어에서는 프로그램 선언에서 배열 초기화를 허용하지 않습니다.&lt;/p&gt;

&lt;p&gt;Ada 언어는 두 가지 방법으로 배열 초기화가 가능합니다. 값을 저장하는 순서대로 나열하는 방법과 =&amp;gt; 연산자를 사용하여 값들을 색인 위치에 직접 할당하는 방법입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;배열 연산(Array Operations)&lt;/span&gt;은 배열 단위로 연산을 수행하는 것을 말합니다. 예를 들어, 배정, 접합, 비교, 슬라이스 등이 있습니다. 이 중 슬라이스는 다음 장에서 따로 논의하도록 하고, 여기에서는 나머지 케이스만을 다루겠습니다.&lt;/p&gt;

&lt;p&gt;Fortran 90에서는 elemental 이라고 부르는 배열 연산을 제공합니다. 제공하는 연산들이 배열 원소들의 쌍(Pair) 연산이기 때문에 그렇게 이름이 붙었다고 합니다. 대표적으로 + 연산은 두 배열의 원소 쌍들의 합을 계산한 배열입니다. 이 외에도 할당, 산술, 관계 및 논리 연산자는 모든 크기의 배열에 대해 오버로딩되어 있습니다.&lt;/p&gt;

&lt;p&gt;APL은 가장 강력한 배열 연산을 지원하는 언어입니다. +, -, *, / 4가지 기본 산술 연산은 물론, 벡터, 행렬, 스칼라 피연산자에 대해서도 정의되어 있습니다. 내적, 외적 연산까지 지원합니다.&lt;/p&gt;

&lt;p&gt;C 언어는 기본적으로 배열 연산을 지원하지 않습니다. Java나 C++ 언어는 메소드를 통해 일부만 지원하며, Python은 배열 접합이나 비교, 원소 추가와 관련된 일부 연산을 지원합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열의 &lt;span style=&quot;color:red&quot;&gt;슬라이스(Slice)&lt;/span&gt;는 배열의 부분 구조입니다. 예를 들어, Fortran 90 언어에서 MAT(1:3, 2)는 1행부터 3행까지 2번째 열을 잘라서 만든 부분 배열이고, MAT(2:3, 1:3)은 2행부터 3행까지에서 1열부터 3열까지 자른 부분 배열입니다.&lt;/p&gt;

&lt;p&gt;Python 언어는 더 복잡한 슬라이스를 지원합니다. 예를 들어, vector[0:7:2]는 배열의 0부터 7까지 슬라이스하는데, 2 단위로 원소들을 슬라이스하는 명령어입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열을 구현하는 것은 원시 타입을 구현하는 것보다 훨씬 더 많은 노력이 필요합니다. 왜냐하면 효율적인 실행 시간 접근을 위해서는 배열에 대한 접근 방법이 컴파일 시간에 만들어져야 하기 때문입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, list[k]의 주소를 계산한다고 가정해봅시다. 1차원 배열은 각각의 원소가 인접한 메모리로 바인딩되기 때문에 (배열 list의 시작 첨자가 1이라면) list[k]의 주소 = list[1]의 주소 + (k - 1) * 원소의 크기 로 계산할 수 있을 것입니다. 원소의 타입이 정적으로 바인딩되고, 배열이 기억공간에 정적으로 바인딩되면 이 식은 실행 시간 전에 계산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 식을 컴파일 시간 내에 계산하기 위해서는 1차원 배열에 대한 속성이 그림과 같은 구조로 설정되어야 합니다. 만약 이러한 항목들이 동적으로 바인딩된다면, 배열의 주소는 실행 시간에 계산할 수밖에 없습니다.&lt;/p&gt;

&lt;p&gt;다차원 배열은 1차원 배열보다 구현하기 복잡합니다. 하드웨어 메모리는 일반적으로 선형으로 구성되어 있기 때문에, 다차원 배열을 1차원 배열로 매핑해야만 합니다. 이 때, 1차원 배열로 매핑하는 방법은 &lt;span style=&quot;color:red&quot;&gt;행 우선 순서(Row Major Order)&lt;/span&gt;와 &lt;span style=&quot;color:red&quot;&gt;열 우선 순서(Column Major Order)&lt;/span&gt;로 나눌 수 있습니다. 행 우선 순서는 1행의 내용을 저장 - 2행의 내용을 저장 - 3행의 내용을 저장 - … 순서대로 저장하는 방식이고, 열 우선 순서는 1열의 내용을 저장 - 2열의 내용을 저장 - 3열의 내용을 저장 - … 순서대로 저장하는 방식입니다. 대부분의 명령형 언어에서는 행 우선 순서대로 저장을 하며, Fortran과 같은 일부 언어에서만 열 우선 저장을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다차원 배열에서 &lt;span style=&quot;color:red&quot;&gt;접근 함수(Access Function)&lt;/span&gt;는 기반 주소와 참조 값들의 집합을 메모리 주소로 매핑하는 함수입니다. 예를 들어, 행 우선 순서로 2차원 배열에 대한 접근 함수를 구해보겠습니다. 시작 주소가 a[1,1]로 주어진 상황에서, 임의의 배열 원소인 a[i,j]의 주소를 계산한다면 a[1,1]의 주소 + ((i-1)*n +(j-1)) * 원소의 크기로 계산할 수 있습니다. 이 식에서 i와 j 부분은 그 값에 따라 달리지기 때문에, 상수와 변수 부분을 구분해서 정리하면 a[1,1]의 주소 - (n+1) * 원소의 크기 + (i * n + j) * 원소의 크기로 바꿔쓸 수 있습니다. 이를 반영하여, 다차원 배열에서 컴파일 시간에 계산할 수 있는 속성은 위 슬라이드의 마지막 그림과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 슬라이드는 3차원 배열에서 특정 배열 원소의 주소를 행 우선 순서/열 우선 순서로 계산하는 것을 나타낸 슬라이드입니다. 계산 방법은 쉽게 설명되어 있으니 한번 읽고 넘어가시면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;연상 배열(Associative Array)&lt;/span&gt;은 &lt;strong&gt;키(Key)&lt;/strong&gt;라고 불리는 원소의 개수와 동일한 개수의 값들로 참조되는 정렬되지 않은 배열을 말합니다. 일반적인 배열에서 색인 값은 전혀 정의할 필요가 없지만, 연상 배열에서는 색인 값도 키와 함께 정의되어야 합니다. 따라서 연상 배열의 실제 원소는 키와 값의 쌍으로 이루어져 있습니다. Perl, Python, Ruby 등의 언어에서는 연상 배열을 기본적으로 지원하며, Java나 C++ 언어에서는 표준 클래스 라이브러리로써 지원합니다. (ex. HashMap)&lt;/p&gt;

&lt;p&gt;Perl 언어에서 연상 배열은 &lt;strong&gt;해쉬(Hash)&lt;/strong&gt;라는 이름으로 지원됩니다. 모든 해쉬 변수는 % 기호로 시작해야 하며, =&amp;gt; 연산자 를 이용해 키와 값을 배정합니다. Python 언어에서는 &lt;strong&gt;사전(Dictionary)&lt;/strong&gt; 자료형을 통해 연상 배열을 지원합니다.&lt;/p&gt;

&lt;p&gt;해쉬의 장점은 원소에 접근할 때 일반적인 배열보다 매우 효율적이라는 것입니다. 왜냐하면 원소에 접근할 때 사용하는 해쉬 연산이 배열보다 효율적이기 때문입니다. 따라서 만약 취급할 데이터가 이름과 급료와 같이 쌍으로 구성되어 있다면 해쉬를 사용하는 것이 좋습니다. 그러나 리스트의 모든 원소를 처리해야하는 경우에는 배열을 사용하는것이 더 낫습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;레코드(Record)&lt;/span&gt;는 각각의 원소들이 이름으로 식별되고 다양한 데이터 타입을 가질 수 있는 자료형입니다. 이러한 자료형은 1960년대 초 COBOL에서 처음 도입된 이후 가장 인기있었던 프로그래밍 언어의 요소였습니다. 배열과 비교해보자면, 배열은 색인을 통해 원소에 접근하고 모든 원소가 동일한 데이터 타입을 갖지만, 레코드는 식별자로 원소에 접근하고 원소가 다양한 데이터 타입을 가질 수 있다는 차이점이 있습니다. 예를 들면, 학생의 정보를 저장할 때 이름은 문자열, 학번은 정수, 학점은 실수로 저장해 만드는 자료형이라고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;레코드의 구조는 언어마다 조금씩 다르게 지원합니다. 최초로 레코드를 지원했던 COBOL을 예로 들면, EMPLOYEE-RECORD 레코드는 EMPLOYEE-NAME과 HOURLY-RATE로 구성되어 있습니다. 앞의 01, 02, 05는 수준 번호로써 레코드의 계층 구조를 나타내며, PICTURE는 기억공간 형식을 나타냅니다. X(20)은 최대 20개의 글자로 이루어진 자료형을 나타내며, 99V99는 중간에 소수점을 갖는 4개의 십진수 숫자라는 의미입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어는 COBOL과는 다르게 계층 번호를 사용하지 않고 레코드 내부에 레코드를 또 선언함으로써 나타냅니다. 그리고 모든 Ada의 레코드 타입은 이름을 갖는 타입이어야만 합니다.&lt;/p&gt;

&lt;p&gt;Fortran과 C 언어에서 중첩 레코드를 사용할 경우, 중첩된 레코드를 먼저 선언하고 상위 레코드에서 하위 레코드를 참조하는 형식으로 정의합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;레코드 필드를 참조하는 방법도 여러 가지가 있습니다. 먼저 COBOL 언어는 OF 라는 명령어를 사용하여 참조합니다. 예를 들어, 이전 슬라이드에 나와있던 COBOL 레코드에서 MIDDLE 이라는 필드를 참조하려면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIDDLE OF EMPLOYEE-NAME OF EMPLOYEE-RECORD&lt;/code&gt; 와 같이 작성하면 됩니다. 이 외의 다른 언어들에서는 대부분 EMPLOYEE_RECORD.EMPLOYEE_NAME.MIDDLE과 같이 .(마침표)를 이용해서 표현합니다. 이렇게 마침표를 이용해 표시하는 방법을 &lt;strong&gt;도트 표기법(Dot Notation)&lt;/strong&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;레코드 필드를 참조할 때 두 가지 형식이 있는데, 레코드 필드까지 모든 중간 레코드의 이름이 포함되어야 하는 &lt;span style=&quot;color:red&quot;&gt;완전 자격 참조(Fully Qualified Reference)&lt;/span&gt;와, 참조 환경이 명확하다면 레코드 이름의 일부나 전체를 생략할 수 있는 &lt;span style=&quot;color:red&quot;&gt;생략 참조(Elliptical Reference)&lt;/span&gt; 형식이 있습니다. COBOL의 레코드는 생략 참조를 허용함으로써 프로그래머의 편리성을 고려하였지만, 생략 참조는 가독성에 문제가 생길 수 있기 때문에 일반적으로 완전 자격 참조 방식을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal이나 Modular-2 언어 같은 경우에는 레코드를 할당하는 것이 가능합니다. Ada 언어 또한 레코드의 할당과 동일성의 비교를 지원합니다. COBOL 언어 같은 경우에는 MOVE CORRESPONDING 명령어를 통해 대상 레코드에 동일한 이름이 필드가 있을 경우 원본 레코드의 필드를 복사하는 기능을 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;레코드 필드도 배열과 마찬가지로 인접한 메모리에 저장됩니다. 그러나 배열과는 다르게 필드의 크기가 반드시 같지는 않기 때문에 배열과는 다른 접근 방식을 사용합니다. 이러한 문제는 레코드의 시작 주소에 상대적인 오프셋 주소를 필드에 포함시킴으로써 해결합니다. 아래 그림은 컴파일 시간 속성의 형식을 나타내고 있습니다.&lt;/p&gt;

&lt;p&gt;또한 레코드의 경우 필드별 크기가 상이하기 때문에 컴퓨터 메모리의 효율적인 접근을 위한 &lt;strong&gt;워드 정렬(Word Alignment)&lt;/strong&gt;이라는 기법을 사용합니다. 예를 들어 오른쪽과 같은 구조체 코드가 있습니다. 이 경우 문자형 변수 c는 1바이트, 정수형 변수 i는 4바이트를 차지합니다. 원래라면 구조체 aa는 이 둘을 합친 5바이트를 차지해야하지만, 32비트 컴퓨터의 경우 4바이트(=32비트) 단위로 명령어를 처리하기 때문에 5바이트씩 처리하게 되면 비효율적인 접근이 발생합니다. 따라서 이 경우에는 컴퓨터가 한번에 가져올 수 있는 데이터의 크기에 맞추기 위해, 일부러 쓰지않는 3바이트를 더 배정해서 8바이트로 만드는 것이 접근에 유리합니다. 이런 용도로 추가하는 비트를 &lt;strong&gt;패딩(Padding)&lt;/strong&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;공용체(Union)&lt;/span&gt;는 변수가 프로그램 실행 중에 다른 시간이라면 다른 타입의 값을 저장할 수 있는 타입을 말합니다. 예를 들면, 컴파일러를 위한 상수들의 테이블이 있습니다. 이 테이블은 컴파일 중인 프로그램에서 발견된 상수들을 저장하는데 사용되는데, 프로그램에 사용되는 상수들은 데이터 타입이 다양합니다. 그런데 이 테이블에 저장된 값은 동일한 테이블 필드에 저장되므로, 발견되는 데이터 타입 중 가장 큰 타입을 기준으로 기억공간이 할당됩니다. 즉, 데이터 타입의 합집합(Union)이라고 볼 수 있으므로 이러한 이름이 붙었습니다.&lt;/p&gt;

&lt;p&gt;공용체의 주요한 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타입 검사가 요구되어야 하는가? (만약 타입 검사가 요구된다면 반드시 동적으로 구현되어야 한다)&lt;/li&gt;
  &lt;li&gt;공용체가 레코드에 포함되어야 하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 설계 고려 사항을 참고하여 공용체가 구현된 언어를 간략하게 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 Fortran 언어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EQUIVALENCE&lt;/code&gt;라는 구문으로 공용체를 선언합니다. Fortran에서는 공용체의 타입 검사를 실시하지 않습니다. ALGOL 68 언어는 Fortran과 다르게 타입 검사를 요구합니다. 이 때, 공용체가 현재 갖고 있는 타입을 나타내기 위해 &lt;strong&gt;태그(Tag)&lt;/strong&gt; 나 &lt;strong&gt;판별자(Discriminant)&lt;/strong&gt;를 표기하는데, 이러한 것을 포함하는 공용체를 &lt;span style=&quot;color:red&quot;&gt;판별 공용체(Discriminated Union)&lt;/span&gt;라고 부릅니다. 판별 공용체는 실행 시간에서 타입을 검사합니다.&lt;/p&gt;

&lt;p&gt;ALGOL 68은 판별 공용체를 &lt;span style=&quot;color:red&quot;&gt;적합성 문장(Conformity Clause)&lt;/span&gt;으로 구현하였습니다. 이것은 실행 시간에 변수가 어떤 타입을 갖고 있는지 테스트하여 각 경우의 수 별로 다르게 처리하는 방법입니다. 오른쪽의 코드를 보시면 ir1은 정수형, 실수형 변수가 저장될 수 있는 공용체로 정의되어 있습니다. 아래의 case 문에서는 ir1이 정수일 때와 실수일 때로 나누어서 문구를 처리합니다. 이러한 방식으로 공용체의 타입을 관리하는 것이 적합성 문장입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/32.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal 언어는 판별 공용체와 레코드 구조를 결합하여 &lt;span style=&quot;color:red&quot;&gt;변종 레코드(Variant Record)&lt;/span&gt;로 구현하였습니다. 이것은 판별 공용체를 갖고 있는 레코드 구조 타입입니다. Pascal 언어의 판별자는 현재 타입의 값이 저장된 레코드에서 사용자가 접근할 수 있는 변수입니다. 코드 예시를 보면 case 문에 form이라는 이름이 있는데, 이것이 바로 판별자입니다. 레코드에 circle, triangle, rectangle 이 저장될 수 있는데, 이 중 하나를 선택하는 의미입니다.&lt;/p&gt;

&lt;p&gt;공용체는 결국 프로그램의 신뢰성을 떨어트리기 때문에 최근에는 지향하지 않는 타입입니다. 기본적으로 메모리를 공유하기 때문에, 공용체 내의 변수의 값을 변경하면 다른 변수의 값도 변형됩니다. 또한 C, C++ 언어와 같이 타입 검사를 하지 않는 자유 공용체를 사용하는 경우 강 타입 언어로부터 멀어지게 됩니다. 타입 검사를 하더라도 그것이 매우 어렵기 때문에 Java나 C#과 같은 최근 언어에서는 공용체를 지원하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/33.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;공용체는 포함된 모든 가능한 변수를 같은 주소에 배정하는 것으로 간단하게 구현할 수 있습니다. 당연히 공용체에서 가장 큰 크기를 차지하는 변수만큼 기억공간이 할당됩니다. 예제로 나온 Ada 코드와 같이 공용체가 주어진 경우, 컴파일 시간 내에 이것을 저장하기 위한 배치는 다음과 같을 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공용체의 시작 주소&lt;/li&gt;
  &lt;li&gt;판별체(=TAG)&lt;/li&gt;
  &lt;li&gt;필드 접근을 위한 오프셋(=상대 주소)&lt;/li&gt;
  &lt;li&gt;TRUE - COUNT (INTEGER), FALSE - SUM (CHARACTER)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/34.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;집합(Set)&lt;/span&gt; 타입은 기본 타입의 고유한 값을 정렬되지 않은 모음으로 저장할 수 있는 타입입니다. 집합 타입의 설계 고려 사항은 최대 원소의 개수를 몇 개로 정할 것이냐입니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어를 예로 들면, 집합의 최대 원소 수는 구현에 따라 다르지만, 일반적으로 100개 이하입니다. 집합과 그 원소에 대한 연산은 단일 Word 크기에 맞는 비트 문자열로 표현함으로써 가장 효율적으로 구현할 수 있습니다. 예를 들어, {red, blue, green} 집합의 부분 집합인 {red, green}을 2진수 101로 표현하는 것입니다.&lt;/p&gt;

&lt;p&gt;Pascal 언어에서 집합 연산은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;’:=’&lt;/strong&gt; : 집합 타입의 적절한 배정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’+’&lt;/strong&gt; : 합집합&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;‘*‘&lt;/strong&gt; : 교집합&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’-‘&lt;/strong&gt; : 차집합&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’=’&lt;/strong&gt; : 동일한 집합인가 판단&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;집합을 배열과 비교해보면, 집합의 연산은 배열의 연산보다 효율적이라는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/35.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전 슬라이드에서 말씀드렸듯이 집합은 일반적으로 비트 스트링 형태로 메모리에 저장합니다. 따라서 집합의 연산의 대부분은 간단한 논리 연산으로 해결이 가능하므로 효율적입니다. 예를 들어, 합집합 연산은 논리 OR, 원소의 포함 여부는 논리 AND 연산으로 간단하게 계산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/36.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;포인터(Pointer)&lt;/span&gt; 타입은 변수가 메모리 주소와 특수 값 nil로 구성되는 값들의 범위를 갖습니다. nil은 유효한 주소가 아니며, 포인터가 메모리 셀을 현재 참조할 수 없음을 나타냅니다. 포인터는 간접 주소 지정과 동적 할당 관리 용도로 주로 사용됩니다. 포인터는 일반적으로 타입 연산자(C언어에서의 *)를 사용하여 정의됩니다. 그러나 배열이나 레코드와는 다르게 실제 데이터를 저장하기 위해서 사용하기보다는, 다른 변수를 참조하기 위해서 사용합니다. 이렇게 다른 변수를 참조하기 위해서 사용하는 변수를 &lt;strong&gt;참조 타입(Reference Type)&lt;/strong&gt;이라고도 부릅니다. 반대로 실제 데이터를 저장하는 변수는 &lt;strong&gt;값 타입(Value Type)&lt;/strong&gt;이라고도 부릅니다.&lt;/p&gt;

&lt;p&gt;포인터의 설계 고려 사항은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포인터 변수의 영역(Scope)과 수명(Lifetime)은 어떻게 되는가?&lt;/li&gt;
  &lt;li&gt;포인터가 참조하는 동적 변수의 수명은 어떻게 되는가?&lt;/li&gt;
  &lt;li&gt;포인터가 가리킬 수 있는 값의 타입이 제한되는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포인터는 기본적으로 &lt;strong&gt;배정&lt;/strong&gt;과 &lt;strong&gt;역참조&lt;/strong&gt; 두 가지 연산을 제공합니다. 배정은 포인터 변수의 값을 다른 주소로 설정하는 것이고, 역참조는 포인터 변수에 바인딩된 메모리 셀이 가리키는 값에 대한 참조를 말합니다. 예를 들어, 예제 코드에서 aa는 포인터 타입으로 정의되어 있습니다. 다음 줄에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aa = &amp;amp;bb&lt;/code&gt;는 aa에 bb의 주소를 배정함으로써 포인터 변수 aa가 bb의 메모리 셀을 가리키게 만드는 연산입니다. 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cc = *aa&lt;/code&gt;를 통해 변수 cc에 aa가 가리키는 메모리 셀의 값, 즉 55를 저장하게 만드는 역참조 연산입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/37.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;포인터라는 개념을 처음 도입한 언어는 PL/I이었습니다. 포인터의 개념이 도입되고 나서 프로그램의 유연성이 매우 높아졌지만, 덩달아 여러 가지 유형의 프로그래밍 오류가 초래되었습니다. 따라서 Java와 같은 최근의 언어에서는 포인터를 사용하지 않고 참조 타입으로 대체하였습니다. 여기서는 포인터로 발생할 수 있는 여러 가지 문제를 짚고 넘어가보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 포인터 변수에 대한 &lt;strong&gt;타입 검사(Type Checking)&lt;/strong&gt; 문제입니다. 포인터가 가리킬 수 있는 개체 유형을 도메인 타입이라고 합니다. PL/I의 포인터는 단일 도메인 타입으로 제한되지 않았기 때문에 포인터에 대한 타입 검사가 어려웠습니다. C/C++ 언어에서는 정수 변수를 가리키는 포인터 변수는 정수 포인터, 실수 변수를 가리키는 포인터 변수는 실수 포인터와 같이 가리키는 데이터 타입에 따라 포인터 변수의 타입이 고정되어 있기 때문에 이 문제를 약간이나마 해결했습니다.&lt;/p&gt;

&lt;p&gt;다음으로는 &lt;strong&gt;허상 포인터(Dangling Pointer)&lt;/strong&gt; 문제입니다. 이 문제는 C 언어를 배울 때도 다루는 문제입니다. 허상 포인터는 이미 회수된 변수의 주소를 가리키는 포인터를 말합니다. 허상 포인터의 문제는 가리키고 있는 기억장소의 위치에 다른 변수가 할당될 수도 있기 때문에 위험합니다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;strong&gt;분실된 객체(Lost Object)&lt;/strong&gt; 문제입니다. 이것은 허상 포인터와 반대로, 기억공간에는 여전히 데이터가 저장되어 있지만, 사용자 프로그램에서 더이상 접근할 수 없게된 객체입니다. 이러한 변수를 흔히 쓰레기(Garbage)라고도 부릅니다. 왜냐면 더 이상 원래의 목적대로 사용할 수도 없고, 그렇다고 다른 용도로 재사용할 수도 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;위 슬라이드의 마지막 부분에서는 허상 포인터와 분실된 객체가 발생할 수 있는 코드 예시를 나타내고 있습니다. 왼쪽의 예제에서는 포인터 전역 변수인 i가 정의되어 있습니다. 그런데 부프로그램 sub1()에서 지역변수인 j가 새로 선언되어있습니다. sub1()에서 포인터 변수 i가 j를 가리키게 배정되었습니다. 그런데 변수 j는 부프로그램 sub1()의 지역변수이기 때문에, sub1()이 종료되면 수명이 끝납니다. 따라서 sub1()이 호출된 이후 *i는 이미 회수된 변수의 주소를 가리키게 됩니다.&lt;/p&gt;

&lt;p&gt;오른쪽 코드에서는 포인터 문자 변수 c가 정의되어 있습니다. 두 번째 줄에서 동적 할당을 통해 c에 새로운 기억공간이 할당됩니다. 그런데 이를 해제하지 않고, 나중에 또 c에 새로운 기억공간을 할당합니다. 이렇게 되면 첫 번째 할당한 기억공간은 프로그램 내에서 더이상 접근할 수 없습니다. 따라서 이 때 분실된 객체 문제가 발생하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/38.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pascal 언어에서 포인터는 동적으로 할당된 변수에 접근하는데만 사용됩니다. 동적 할당에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; 명령어를 사용하고, 해제할때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispoose&lt;/code&gt; 명령어를 사용합니다. dispose 명령어는 허상 포인터 문제가 거의 항상 발생했기 때문에, dispose 명령어가 나오면 이걸 무시하는 경우도 많았습니다. 이것은 허상 포인터 문제를 발생하지 않게 하지만, 프로그램이 더 이상 필요로 하지 않는 힙의 재사용을 불가능하게 만드는 단점이 있습니다. 이것은 초기 Pascal 언어가 산업용 보다는 교육용 언어로 설계되었기 때문에 발생하는 문제입니다.&lt;/p&gt;

&lt;p&gt;포인터는 어쩌면 goto문과 비슷한데, goto문이 문장의 제어 범위를 확대시키는 것처럼 포인터는 변수가 참조할 수 있는 메모리 셀의 범위를 확대시킵니다. goto문이 프로그래밍 언어 설계자들에게 비난을 받는 것처럼 포인터도 이와 같은 비난을 받는데요, 오른쪽에 포인터에 대한 악담이 실려있는데, 이 내용이 재미있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“고급 언어에서 포인터의 도입은 우리가 결코 회복할 수 없는 후퇴였습니다”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마치 우한 폐렴 때 질병관리청에서 그 전으로는 절 때 돌아갈 수 없다고 말한 것과 비슷한 느낌이네요.&lt;/p&gt;

&lt;p&gt;C 언어에서 포인터는 어셈블리 언어에서 주소를 사용하는 것처럼 사용할 수 있는데요, 이러한 설계는 허상 포인터나 분실된 객체 문제에 대해 어떤 해결책도 없다는 단점이 있습니다. 그러나 그 대신 C 언어에서는 포인터의 산술 연산이 가능하다는 특징이 있습니다. 기본적으로 ‘*’ 연산은 포인터의 역참조 연산, ‘&amp;amp;’ 연산은 변수의 주소를 생성합니다. 이 외에도 포인터 변수와 일반 변수의 산술 연산이 가능한데, 예를 들어 ptr + index 라는 연산이 있습니다. 이 것은 ptr에 index 값을 단순히 더하는 것이 아니라, 먼저 ptr이 가리키고 있는 메모리 셀의 크기 단위로 index의 값이 조절됩니다. 만약 ptr의 크기가 4인 메모리 셀을 가리키면, index에 먼저 4를 곱한 다음 ptr에 더하는 방식입니다. 이렇게 설정된 목적은 포인터 연산으로 배열을 표현하기 위해서입니다. 예를 들어, 포인터 변수 ptr에 1차원 배열이 할당되었다고 하면, *(ptr + 1)은 ptr[1]과 동일한 의미입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/39.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;참조 타입(Reference Type)&lt;/span&gt;은 포인터와 유사하지만, 포인터가 메모리의 주소를 참조하는 것과 달리 참조 타입은 메모리의 객체나 값을 참조합니다. 따라서 포인터는 주소값을 다루기 때문에 산술 연산이 가능하지만, 참조 타입은 그렇지 않다는 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;대표적인 참조 타입은 C++ 언어에서 구현되어 있습니다. C++ 언어의 참조 타입은 항상 암시적으로 역참조되는 상수 포인터로 구현되어 있는데, 상수이기 때문에 정의할 때 어떤 변수에 주소값으로 초기화되어야 합니다. 물론 초기화된 후에는 다른 변수를 참조하도록 설정할 수 없습니다. 일반적으로 C++ 언어에서 참조 타입은 함수에서 호출 함수와 피호출 함수간의 양방향 통신에 사용됩니다. 이러한 예제는 다음을 참고해주시기 바랍니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void sub1(int&amp;amp; num){
  num = 10;
}
int n = 0;
sub1(n);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같이 함수 매개변수를 참조 타입으로 설정하면, n을 포인터로 넘기지 않아도 n의 값을 0에서 10으로 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/40.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;대부분의 대형 컴퓨터에서 포인터는 2바이트 또는 4바이트 메모리 셀(워드 크기)에 저장된 단일 값으로 저장됩니다. 그런데 포인터를 구현할 때는 포인터를 저장하는 것 자체보다는 포인터로 인해 발생하는 허상 포인터 문제를 고려하는 것이 더 중요합니다.&lt;/p&gt;

&lt;p&gt;첫 번째 방법은 &lt;span style=&quot;color:red&quot;&gt;비석 접근 방법(Tombstone Approach)&lt;/span&gt;입니다. 이것은 모든 동적 변수에 비석이라는 특수한 셀을 포함시키는 것입니다. 실제 사용하는 포인터 변수는 이 비석을 가리키게 하고, 비석이 동적 변수를 가리키게 만드는 구조입니다. 만약 동적 변수가 기억장소에서 해제된다면, 비석은 그대로 남지만 nil을 가리키도록 설정됩니다. 즉, 비석을 통해 포인터가 회수된 기억공간을 계속 가리키는 것을 방지하는 방법입니다.&lt;/p&gt;

&lt;p&gt;아이디어만 들어도 이 방법의 문제점이 자연스럽게 떠오릅니다. 먼저, 동적 변수가 해제될 때도 비석은 해제되지 않기 때문에 그 만큼의 기억공간이 낭비됩니다. 게다가, 포인터 변수가 기억공간을 직접 가리키지 않고 비석을 통해 간접적으로 가리키기 때문에 그만큼의 접근 시간이 추가로 소모됩니다. 일반적으로는 이 정도의 시간적/공간적 비용을 감당하면서까지 신뢰성을 확보할 필요가 없기 때문에, 이 방법을 사용하는 언어는 거의 없습니다. 버전 9 이하의 매킨토시나 C++ 언어의 일부 라이브러리(std::weak_ptr)만 이 방법을 사용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/41.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;허상 포인터를 해결하는 두 번째 아이디어는 &lt;span style=&quot;color:red&quot;&gt;잠금과 키 접근 방법(Locks-and-key Approach)&lt;/span&gt;입니다. 이 방법은 동적 변수를 (변수, 잠금값)의 순서쌍으로 나타내고, 동적 변수를 가리키는 포인터는 (키, 주소)의 순서쌍으로 나타냅니다. 동적 변수가 할당되면 잠금값이 생성되어 포인터 변수의 키 값과 동적 변수의 잠금값에 이 값이 저장됩니다. 포인터가 역참조될 때는 포인터의 키 값과 동적 변수의 잠금값과 비교함으로써 그 접금이 일치하는지, 아닌지 확인합니다. 만약 포인터가 복사된다면 잠금값도 같이 복사되어야 하고, 해제될 때는 잠금값도 해제되어야 합니다.&lt;/p&gt;

&lt;p&gt;사실 이러한 방법들 보다는 그냥 프로그래머 직접 매번 동적 변수를 해제해주는 것이 좋습니다. 프로그램 내에서 모든 동적 변수가 명시적으로 해제된다면 허상 포인터 문제는 발생하지 않기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/42.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 힙 메모리 관리에 대해 알아보도록 하겠습니다. 힙 메모리 관리는 매우 복잡한 실행 시간 프로세스로, 여기서는 모든 힙이 동일한 크기로 할당/회수되는 시나리오와 가변 크기로 할당/회수되는 시나리오, 두 가지 상황으로 나누어 고려해보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 동일한 크기에 대해 회수에 대해 먼저 논의하자면, 기억공간 회수를 통해 사용가능한 셀을 묶어 가용 공간 리스트를 만들 수 있습니다. 할당은 필요할 때 이 리스트로부터 요구된 셀의 개수를 가져오는 것입니다. 할당보다 회수가 더 어려운 문제인데, 동적 변수는 2개 이상의 포인터로 가리켜질 수 있으므로 그 변수가 언제 프로그램에서 더 이상 사용되지 않는지 판단하는 것이 어렵기 때문입니다. 예를 들어, 동적 변수를 가리키던 포인터가 없어진다고 해서 그 동적 변수가 쓰이지 않는다고 보장할 수 없습니다. 다른 포인터가 그 동적 변수를 가리키고 있을 수도 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;LISP 언어에서는 회수하는 방법에 따라 두 가지 방법으로 나눌 수 있는데, 순차적으로 회수하는 &lt;strong&gt;참조 계수기 접근 방법(Reference Counter)&lt;/strong&gt;과 &lt;strong&gt;쓰레기 수집 접근 방법(Grabage Collection Approach)&lt;/strong&gt;이 있습니다.&lt;/p&gt;

&lt;p&gt;먼저 참조 계수기 접근 방법부터 알아보겠습니다. 참조 계수기 방법은 접근할 수 없는 메모리 셀이 생성될 때마다 회수를 수거하는 방법입니다. 이것을 구현하기 위해, 항상 모든 메모리 셀에 대해 현재 자신을 가리키고 있는 포인터의 갯수를 저장하는 계수기를 사용합니다. 만약 어떤 셀의 계수기 값이 0이 된다면 이 메모리 셀을 가리키는 포인터가 없다는 뜻이므로 더 이상 쓰지 않는 메모리 셀로 판단하여 회수합니다.&lt;/p&gt;

&lt;p&gt;참조 계수기 방법에는 세 가지 문제점이 존재합니다. 첫째는 기억공간의 셀 크기가 작다면, 그만큼 계수기가 차지는 공간이 부담이 될 수 있습니다. 둘째로 계수기의 값을 조절하기 위한 시간적 부담도 존재합니다. 특히나 LISP은 거의 모든 명령문마다 포인터의 값이 변경되므로, 프로그램 실행 시간에서 계수기가 차지하는 실행 시간이 매우 부담스럽습니다. 마지막으로 셀이 순환적으로 참조되어 있는 경우입니다. 이러한 순환 리스트에 속하는 셀은 적어도 1의 계수기 값을 갖게 되므로 영원히 회수되지 않는다는 문제점이 있습니다.&lt;/p&gt;

&lt;p&gt;다만 참조 계수기 방법에 단점만 있는 것은 아닙니다. 참조 계수기 방법은 순차적으로 동작하는 방식이기 때문에 프로그램의 수행과 번갈아가며 발생합니다. 따라서 전체적으로 프로그램 실행에 지연을 초래하지 않는다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/43.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 쓰레기 수집 접근 방법에 대해 알아보겠습니다. 실행 시간에서 저장공간이 요구될 때 기억공간의 메모리 셀을 할당하고, 필요할 때 포인터와 셀의 연결을 끊습니다. 이 때는 일단 기억공간 회수에 신경쓰지 않고, 사용가능한 모든 셀이 할당될 때까지 이루어집니다. 이 과정에서 발생하는 쓰레기를 수집하기 위해, 쓰레기 수집 프로세스가 시작됩니다. 쓰레기 수집을 위해, 모든 셀은 수집 과정에서 사용되는 여분의 비트나 필드를 갖습니다. 쓰레기 수집을 위한 간단한 알고리즘은 다음과 같이 나타낼 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;힙의 모든 셀은 쓰레기인지 나타내는 표시가 설정됩니다.&lt;/li&gt;
  &lt;li&gt;프로그램의 모든 포인터는 힙으로 추적되고, 도달 가능한 셀은 쓰레기가 아닌 것으로 표시합니다.&lt;/li&gt;
  &lt;li&gt;쓰레기가 아닌 것으로 표시되지 않은 힙의 모든 셀을 회수합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 쓰레기 수집 접근 방법의 가장 큰 단점은 가장 필요할 때 가장 최악으로 동작한다는 것입니다. 이게 무슨 말이냐 하면, 쓰레기 수집은 힙의 기억공간을 대부분 사용되었을 때만 사용됩니다. 그런데 이 방법은 대부분의 셀을 추적해서 현재 사용중인지 확인해야하기 때문에, 상당한 많은 시간이 소요됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/006/44.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 메모리 셀이 가변 크기인 경우에는 문제가 더 복잡해집니다. 우선 가변 크기 셀에서는 동일한 크기의 셀에서 발생하는 모든 어려움을 기본적으로 갖고 있고, 다음과 같은 추가적인 문제가 더 발생합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;힙에 있는 모든 셀이 쓰레기라는 것을 나타내기 위한 표시의 초기 설정이 어렵습니다. 왜냐하면 각각의 셀이 다른 크기이기 때문에, 셀의 영역이 어디서부터 어디까지인지 스캔하는 것이 어렵기 때문입니다. 이에 대한 대책으로는 셀의 첫 번째 필드로 그 셀의 크기를 표시하는 것입니다.&lt;/li&gt;
  &lt;li&gt;만약 포인터를 전혀 포함하지 않는 셀이라면 어떻게 표시를 할 것인지도 문제가 됩니다. 물론 이것은 내부 포인터를 추가하면 해결되는 문제이지만, 이것으로 인해 추가적인 공간적 부담과 시간적 부담이 발생합니다.&lt;/li&gt;
  &lt;li&gt;사용가능한 기억공간의 리스트를 관리하는 것도 문제입니다. 회수된 기억공간의 크기는 클 수도 있지만 작을 수도 있습니다. 만약 회수된 기억공간 중 하나가 필요한 기억공간의 크기에 맞지 않다면 충분한 크기를 가진 다른 기억공간을 찾아야합니다. 이에 대한 해결책으로는 기억공간의 크기가 작은 경우 인접한 블록을 합병하는 것이지만, 이 과정에서도 추가적인 시간적 부담이 발생합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 문제점 중, 1번과 2번의 문제는 참조 계수기 방법을 사용하면 어느 정도 해결이 가능합니다. 그러나 3번 문제는 참조 계수기로도 해결할 수 없습니다. 나쁜 소식은 대부분의 프로그래밍 언어에서는 이러한 가변 크기 셀의 관리가 반드시 필요하다는 것입니다.&lt;/p&gt;

&lt;p&gt;6장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Names, Bindings, Type Checking, and Scopes</title><link href="http://localhost:4000/pl/names-bindings-type-checking-and-scope/" rel="alternate" type="text/html" title="Names, Bindings, Type Checking, and Scopes" /><published>2023-08-28T00:00:00+09:00</published><updated>2023-08-28T00:00:00+09:00</updated><id>http://localhost:4000/pl/names-bindings-type-checking-and-scope</id><content type="html" xml:base="http://localhost:4000/pl/names-bindings-type-checking-and-scope/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;처음 소개드린대로 3장과 4장은 컴파일러 과목과 중복된 내용이기 때문에 생략하고, 바로 5장으로 넘어갑니다. 5장은 변수와 관련된 개념들을 하나씩 소개합니다. 특히 제목대로 변수의 이름, 바인딩, 타입 검사, 유효 영역 등을 중점으로 짚도록 하겠습니다. 이번 장을 한 문장으로 요약하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“변수는 속성이나 속성의 모음으로 특징지어질 수 있으며, 그 중 가장 중요한 것은 타입입니다. 프로그래밍 언어의 데이터 타입을 설계하려면 범위, 수명, 타입 검사 및 초기화 등 다양한 문제를 고려해야 합니다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령형 언어는 폰 노이만 구조를 기반으로 한 추상화입니다. 이 컴퓨터 구조의 가장 큰 특징은 명령어와 데이터를 저장하는 메모리와, 그 메모리의 내용을 수정하기 위한 연산을 제공하는 CPU로 구성되어 있다는 것입니다. 명령형 언어의 변수라는 것은 결국 메모리 셀에 대한 추상화입니다. 변수는 데이터 타입, 유효 영역, 수명, 타입 검사 등과 같은 속성(Attribute)들의 모음으로 특징지어질 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 &lt;span style=&quot;color:red&quot;&gt;이름(Name)&lt;/span&gt;은 프로그램에서 변수, 레이블, 부프로그램 및 매개변수와 같은 요소들을 식별하는데 사용되는 문자열입니다. 이름을 설계할 때는 다음과 같은 것들을 고려해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이름의 최대 길이는 무엇인가?&lt;/li&gt;
  &lt;li&gt;이름에 밑줄과 같은 연결 문자를 사용할 수 있는가?&lt;/li&gt;
  &lt;li&gt;이름이 대소문자를 구분하는가?&lt;/li&gt;
  &lt;li&gt;이름이 특수어, 예약어, 키워드인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이것들에 대해 하나씩 고려해보도록 하겠습니다. 먼저 이름의 길이는 언어가 발전되면서 점점 늘어났습니다. 초기 프로그래밍 언어에서는 오로지 단 한 문자만 허용되었으나, FORTRAN I은 6글자, COBOL은 30문자, C와 C++, Java와 같은 경우는 제한 없는 길이가 가능해졌습니다.&lt;/p&gt;

&lt;p&gt;또한 대부분 프로그래밍 언어에서 밑줄 문자를 띄어쓰기와 비슷한 용도로 사용합니다. 이러한 문화는 1970년 ~ 1980년대에 널리 사용되었지만, 최근에는 점점 배제하는 경향을 보입니다. C 언어 이후 등장한 언어들에서는 Camel Notation이라는 표기법이 정립되어, 대소문자를 통해 단어를 구분했습니다. 예를 들어서 myStack과 같이 말입니다. 그러나 이러한 밑줄 문자나 대소문자 혼용 사용은 언어 설계의 고려 사항이 아니라 프로그래밍에서의 고려 사항입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 언어에서 대소문자를 구별하는 것이 옳은 선택일까요? 예를 들어 C++에서는 대소문자가 완벽하게 다른 글자로 구분됩니다. ROSE, rose, Rose 이 3개의 이름은 모두 다른 이름으로 취급됩니다. 이것은 가독성 측면에서 굉장히 좋지 않다고 볼 수 있습니다. 왜냐하면 이 3개의 이름은 서로 유사하게 보이지만, 실제로는 아무런 관련이 없기 때문입니다. 물론 이것은 프로그래밍에서의 문제이기 때문에 대부분의 사람들은 대소문자가 구별되는 것을 싫어하지 않지만, 사전 정의된 이름들에서 대소문자가 구별되는 경우 문제가 생길 수 있습니다. 예를 들어, Java에서 문자열을 정수 값으로 변환하는 메소드는 parseInt인데, ParseInt나 parseint로 입력하면 인식하지 못합니다. 이것은 작성력 측면에서 좋지 않은 경우라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;특수어(Special Words)&lt;/span&gt;는 수행될 행동들을 명칭화하여 프로그램의 가독성을 높이는데 사용됩니다. 대부분의 프로그래밍 언어에서 특수어는 &lt;span style=&quot;color:red&quot;&gt;키워드(Keyword)&lt;/span&gt;, 또는 &lt;span style=&quot;color:red&quot;&gt;예약어(Reserved word)&lt;/span&gt;로 분류되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;키워드&lt;/strong&gt; : 프로그래밍 언어 내의 특수어를 재정의할 수 있는 경우 키워드라고 부릅니다. 현재 사용되고 있는 언어 중에서 특수어가 키워드인 언어는 Fortran 뿐입니다. Fortran의 특수어 중 하나인 REAL은 REAL APPLE로 선언하는 경우에는 APPLE이 실수형 변수로 정의가 되지만, REAL = 3.4로 선언할 경우 REAL 이란 변수에 3.4를 대입하는 식이 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;예약어&lt;/strong&gt; : 프로그래밍 언어 내의 특수어를 재정의할 수 없는 경우 예약어라고 부릅니다. 프로그래밍 언어 설계 관점에서 보면, 예약어가 키워드보다 낫다는 것이 일반적인 의견입니다. 그러나 예약어에서도 문제가 하나 있는데, 언어가 갖고있는 예약어가 너무 많을 경우 프로그래머가 불편함을 느낄 수 있다는 것입니다. 특히 COBOL 언어는 300여개의 예약어를 가지고 있는데, 그 중에는 일반적으로 많이 사용하는 이름인 COUNT, LENGTH와 같은 것들도 포함하고 있습니다. 이 경우 프로그래머가 변수 이름을 짓는데 상당한 애로사항이 생길 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;변수(Variable)&lt;/span&gt;는 1페이지에서도 설명드렸듯이 메모리 셀에 대한 추상화입니다. 변수는 이름(Name), 주소(Address), 타입(Type), 값(Value), 수명(Lifetime), 유효 범위(Scope) 6개의 튜플로 구성되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이름&lt;/strong&gt; : 변수의 이름은 프로그램에서 가장 일반적으로 볼 수 있는 이름입니다. 변수의 이름은 &lt;strong&gt;식별자(Identifiers)&lt;/strong&gt;라고도 불립니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소&lt;/strong&gt; : 변수의 주소는 그 변수와 연관된 실제 메모리의 주소입니다. 많은 언어들에서는 동일한 변수가 프로그램의 위치에 따라 다른 주소와 연관되는 것이 가능합니다. C 언어와 비슷한 언어에서는 지역 변수(Local Variable)라는 개념을 생각하시면 됩니다. 또한 같은 주소를 가리키는 여러 개의 변수를 가질 수도 있습니다. 이것을 &lt;span style=&quot;color:red&quot;&gt;별칭(Alias)&lt;/span&gt;이라고 하는데, 이것은 가독성을 떨어트리므로 권장되지 않습니다. 예를 들어, total이 sum의 별칭이라면, total 값을 변경시켰을 때 sum 값도 변경되고, 그 반대도 가능해집니다. 따라서 프로그램을 읽는 프로그래머는 total과 sum이 같은 공간을 가리키는 것을 반드시 기억해둬야 하는 불편함이 있습니다. 결국 프로그램 내의 별칭이 많을 수록 검증이 더욱 어려워집니다. C 언어의 포인터가 대표적인 별칭의 예시입니다. 또한 부프로그램의 매개변수를 통해서 생성될 수도 있는데, 이것은 9장에서 부프로그램에 대해서 다룰 때 더 자세하게 논의하겠습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;타입&lt;/strong&gt; : 변수의 타입은 그 변수가 저장할 수 있는 값들의 범위와 정의될 수 있는 연산들의 집합을 결정합니다. 예를 들어, Fortran에서의 Integer 타입은 -32,768 ~ 32,767 사이의 값을 가질 수 있으며, 사칙연산이 가능합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;값&lt;/strong&gt; : 변수의 값은 그 변수에 저장된 메모리 셀의 내용입니다. 변수는 등호(=)를 기준으로 왼쪽에 있을 때는 &lt;span style=&quot;color:red&quot;&gt;l-value&lt;/span&gt;, 오른쪽에 있을 때는 &lt;span style=&quot;color:red&quot;&gt;r-value&lt;/span&gt;로 부릅니다. l-value는 변수의 주소, r-value는 변수의 값을 나타냅니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;바인딩(Binding)&lt;/span&gt;은 연산과 기호 같은 하나의 속성과 하나의 개체 간의 연관성입니다. 바인딩이 일어나는 시기를 &lt;span style=&quot;color:red&quot;&gt;바인딩 시간(Binding Time)&lt;/span&gt;이라고 부릅니다. 바인딩 시간은 다음과 같이 다양한 경우로 분류할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;언어 설계 시간 : ‘*’ 기호는 일반적으로 언어 설계 시 곱셈 연산으로 바인딩됩니다.&lt;/li&gt;
  &lt;li&gt;언어 구현 시간 : Integer와 같은 데이터 타입이 어떤 범위의 값을 가질지는 언어 구현 시간에 바인딩됩니다.&lt;/li&gt;
  &lt;li&gt;컴파일 시간 : Pascal로 구현된 프로그램에서 변수가 어떤 데이터 타입을 가질지는 컴파일 시간에 바인딩됩니다.&lt;/li&gt;
  &lt;li&gt;링크 시간 : 라이브러리 부프로그램에 대한 호출은 링크 시간에 부프로그램 코드에 바인딩됩니다.&lt;/li&gt;
  &lt;li&gt;로드 시간 : 프로그램이 메모리에 로드될 때 변수가 메모리 셀에 바인딩됩니다.&lt;/li&gt;
  &lt;li&gt;실행 시간 : 프로시저의 변수는 프로시저가 실제로 호출될 때 메모리 셀에 바인딩됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 오른쪽 구석에 있는 간단한 프로그램을 확인해봅시다. 가장 첫 줄에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int count;&lt;/code&gt;를 통해 count 변수를 int형 변수로 선언하였습니다. 이것은 컴파일 시간에 바인딩됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count = count * 5;&lt;/code&gt;에서 count가 가질 수 있는 값은 언어 구현 시간에 바인딩됩니다. 또한 ‘*’ 연산이 어떤 의미를 가질지는 피연산자의 타입이 결정되었을 때 바인딩되므로 컴파일 시간에 바인딩됩니다. 5라는 숫자 표현은 컴파일 설계 시간에 바인딩되며, count의 최종 값은 이 배정문의 실행 시간에 바인딩됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sub1(count);&lt;/code&gt;에서 count 변수는 이 부프로그램의 매개변수로 들어있습니다. 그러나 count의 값은 이전 구문에서 실행 시간에 바인딩되었으므로 이 때는 실행 시간에 바인딩됩니다. 그러다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sub1(int aa)&lt;/code&gt;에서 변수 aa는 매개변수로 처음 선언되는 변수입니다. 따라서 변수 aa는 count와는 다르게 로드 시간에 바인딩됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 바인딩이 실행 시간 이전에 일어나고 프로그램 실행 전체에 걸쳐서 변하지 않는다면 &lt;span style=&quot;color:red&quot;&gt;정적 바인딩(Static Binding)&lt;/span&gt;이라고 부릅니다. 반대로 프로그램 실행 과정에서 변경될 수 있다면 &lt;span style=&quot;color:red&quot;&gt;동적 바인딩(Dynamic Binding)&lt;/span&gt;이라고 부릅니다. 하드웨어에서 발생하는 동적 바인딩의 대표적인 예시는 가상 메모리입니다. 가상 메모리는 상황에 따라 실제 물리적 메모리에 다르게 바인딩될 수 있지만, 여기서 이러한 종류의 동적 바인딩까지는 고려하지 않도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 타입 바인딩의 경우를 살펴보겠습니다. 변수는 프로그램 내에서 참조되기 전까지 어떤 데이터 타입인지 바인딩되어야만 합니다. 변수에서 타입은 두 가지 선언 방법이 있습니다. 변수 이름과 특정 타입을 직접 명세함으로써 타입을 바인딩하는 &lt;span style=&quot;color:red&quot;&gt;명시적 선언(Explicit Declaration)&lt;/span&gt;이 있습니다. 1960년 이후 설계된 대부분의 프로그래밍 언어들은 명시적 선언 방법을 채택하고 있습니다. 반대로 직접 선언하지 않고 규칙에 의해 변수에 타입을 바인딩하는 것을 &lt;span style=&quot;color:red&quot;&gt;묵시적 선언(Implicit Declaration)&lt;/span&gt;이라고 합니다. 대표적으로 Fortran, Basic, PL/I가 이 방법을 사용합니다. 공통점은 이 두 방법 모두 정적 바인딩으로 분류된다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동적 타입 바인딩에서는 변수의 타입이 선언문이나 이름 그 자체로 정해지지 않습니다. 대신 변수에 어떤 값이 할당되는 순간 그 변수에 타입이 바인딩됩니다. 오른쪽 그림과 같이 변수 count는 1을 넣었을 때는 정수형, 3.0을 넣었을 때는 실수형, [1, 2, 3]을 넣었을 때는 배열로 바인딩됩니다. 대표적으로 Python이 이러한 동적 타입 바인딩 방식을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;동적 타입 바인딩의 장점은 프로그래밍 시의 유연성을 제공한다는 것입니다. 특히 Generic Program을 작성할 때 빛을 발휘할 수 있습니다. 그러나 프로그램의 신뢰성을 낮추는 단점이 있습니다. 동적 타입 바인딩을 가진 언어는 컴파일 시간에 오류를 탐지하기 더 어렵기 때문입니다. 따라서 타입 검사를 실행 시간에 수행해야만 하는데, 그로 인해 추가적인 비용이 드는 것이 문제입니다. 그렇기 때문에 동적 타입 바인딩을 갖는 언어는 컴파일러보다는 인터프리터를 사용해서 구현하는 경우가 많습니다. 왜냐면 어차피 인터프리터는 컴파일러에 비해 10배 이상 느리기 때문에 동적 타입 바인딩에서 발생하는 검사 시간이 인터프리터의 번역 시간에 묻히기 때문입니다.&lt;/p&gt;

&lt;p&gt;묵시적 선언에서 타입 선언을 하는 것을 &lt;span style=&quot;color:red&quot;&gt;타입 추론(Type Inference)&lt;/span&gt;라고 부르기도 합니다. ML이라는 언어에서 부프로그램은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fun circum(r) = 3.14 * r * r;&lt;/code&gt;과 같이 선언할 수 있습니다. ML 언어는 함수의 내부 구조를 통해 함수의 결과값이 어떤 타입인지 확인하는데, 이 경우 3.14라는 실수 값이 함수의 결과값에 영향을 주기 때문에 결과 값은 실수 타입으로 자동으로 추론됩니다.&lt;/p&gt;

&lt;p&gt;Generic Programming은 데이터 타입에 의존하지 않고, 하나의 변수가 여러 다른 데이터 타입을 가질 수 있게 만드는 프로그래밍 스타일입니다. 이것은 코드의 재사용성을 크게 높일 수 있으며, 이러한 접근 방식은 1973년 ML이라는 언어에서 처음 제안되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;변수의 &lt;span style=&quot;color:red&quot;&gt;수명(Lifetime)&lt;/span&gt;은 변수가 특정 메모리에 바인딩되어 있는 기간으로 정의됩니다. 즉, 변수가 특정 메모리 공간에 바인딩 될 때 시작되며 그 공간에서 해제될 때 종료됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;정적 변수(Static Variable)&lt;/strong&gt;는 프로그램이 실행되기 전에 메모리 공간에 바인딩되고, 프로그램 실행이 종료되면 해제됩니다. 대표적인 정적 변수는 전역 변수(Global Variable)가 있고, 부프로그램에서 기록에 민감한 변수의 경우에도 정적 변수로 선언됩니다. 정적 변수는 할당이나 해제를 위한 시간이 필요하지 않기 때문에 효율성을 높일 수 있다는 장점이 있지만, 유연성을 감소시킨다는 문제점이 있습니다. 특히 정적 변수만을 갖는 언어로는 재귀적 부프로그램을 만들 수 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스택 동적 변수(Stack Dynamic Variable)&lt;/strong&gt;는 선언문에 의해 지시될 때 기억공간 바인딩이 생성되지만, 타입은 정적으로 바인딩되는 변수를 말합니다. 따라서 바인딩 자체는 실행 시간에 일어나게 됩니다. 대표적인 스택 동적 변수의 예시는 프로시저에서의 지역 변수가 있습니다. 예를 들어, C나 Java와 같은 언어에서 함수에 선언된 변수는 그 함수가 호출될 때 기억공간에 바인딩됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스택 동적 변수의 장점은 재귀적 부프로그램을 가능하게 만들고, 서로 다른 프로시저에서 동일한 메모리 공간을 차지하게 만들 수 있습니다. 단점으로는 실행 시간에서 지역 변수의 메모리 할당 및 할당 해제를 위한 추가적인 비용이 필요하다는 것입니다. 또한 스택 동적 변수는 간접적인 주소지정을 필요로 하기 때문에 접근 속도가 더 느리다는 단점도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택 동적 변수의 예로 위와 같은 하나의 프로그램을 보겠습니다. 먼저 변수 a2와 변수 p는 sub()라는 부프로그램 안에서 선언되었기 때문에 스택 동적 변수입니다. 따라서 이 변수들은 sub() 종료시 메모리에서 자동으로 회수됩니다. 변수 a3은 부프로그램 안에서 선언되었지만, static으로 선언되었기 때문에 정적 변수이므로 sub()가 종료되더라도 자동으로 회수되지 않습니다. 변수 a3은 프로그램이 종료될 때 회수됩니다. 또한 변수 p는 a2와 다르게 포인터로 선언되어 있습니다. 그렇기 때문에 이것도 일단 실행 시간에서 기억공간에 할당되고 회수되지만, a2와는 다르게 힙(Heap)에 저장된다는 차이점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;묵시적 힙 동적 변수(Implicit Heap Dynamic Variable)&lt;/strong&gt;은 값이 배정될 때 힙 기억장소에 바인딩 되는 변수입니다. 다음과 같은 APL 언어의 LIST 변수는 이전에 어떤 용도로 사용되었는지에 상관 없이 list 형으로 값이 배정된다면 list 형으로 기억장소에 바인딩되고, 마찬가지로 정수형으로 배정된다면 기억장소에 정수형으로 바인딩됩니다. 장점으로는 높은 유연성을 갖는다는 것이지만, 타입 바인딩 때와 마찬가지로 실행 시간에서의 부담이 늘어나고 컴파일 시간에 오류를 탐지하는 것이 어려워진다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;명시적 힙 동적 변수(Explicit Heap Dynamic Variable)&lt;/strong&gt;은 프로그래머가 명시적으로 공간을 할당하고 회수되는 변수입니다. 명시적 힙 동적 변수는 포인터나 참조 변수에 의해서만 참조될 수 있으며 실행 시간에서 메모리 공간 바인딩과 해제가 모두 일어납니다. 명시적 힙 동적 변수의 타입은 컴파일 시간에 바운딩되지만, 기억장소에 바인딩 되는 것은 실행 시간입니다.&lt;/p&gt;

&lt;p&gt;명시적 힙 동적 변수를 이해하기 위해, 가운데에 있는 C++ 코드 예제를 보겠습니다. 이 예제에서 명시적 힙 동적 변수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new int&lt;/code&gt;를 통해서 생성됩니다. 그리고 이 변수는 포인터인 intnode를 통해 참조될 수 있습니다. 그리고 delete 명령어를 통해 기억공간에서 해제됩니다. C++는 쓰레기 수집(Garbage collection)과 같은 묵시적 기억공간 회수 방법을 사용하지 않기 때문에 명시적 연산자인 delete가 반드시 필요합니다. 반대로 Java는 명시적 힙-동적 변수를 사용하지만 쓰레기 수집을 지원하기 때문에 명시적으로 회수할 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;명시적 힙 동적 변수의 장점은 실행 시간 도중 크기가 커지거나 줄어들 수 있는 연결 리스트나 트리와 같은 동적인 구조체를 구현하는데 유용합니다. 그러나 참조 변수를 올바르게 사용하기가 어렵고, 참조 비용, 기억공간 관리를 구현하는게 어렵다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 확인해볼 사항은 &lt;span style=&quot;color:red&quot;&gt;타입 검사(Type Checking)&lt;/span&gt;입니다. 사실 10판 이후로 이 부분은 6장으로 넘어갔지만, 강의자료에서는 그것이 반영되지 않아 여전히 5장의 내용으로 나와있네요. 어쨌든 강의자료를 기반으로 설명드리는 것이기 때문에 타입 검사는 여기에서 짚고 넘어가겠습니다.&lt;/p&gt;

&lt;p&gt;타입 검사는 연산자와 피연산자가 &lt;span style=&quot;color:red&quot;&gt;호환 가능한 타입(Compatible Type)&lt;/span&gt;인지 확인하는 검사입니다. 호환 가능한 타입이란 연산자에 대해 적합하거나, 컴파일러에 의해 적합한 타입으로 변환되는 것이 허용되는 타입입니다. 이렇게 컴파일러에 의해 자동으로 변환되는 것을 &lt;span style=&quot;color:red&quot;&gt;타입 강제 변환(Coercion)&lt;/span&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;타입 검사에는 &lt;strong&gt;정적 타입 검사(Static Type Checking)&lt;/strong&gt;와 &lt;strong&gt;동적 타입 검사(Dynamic Type Checking)&lt;/strong&gt; 2가지 종류가 있습니다. 정적 타입 검사는 모든 변수의 타입 바인딩이 정적인 경우 수행되는 타입 검사이며, 동적 타입 검사는 실행 시간에 검사하는 타입 검사입니다. 예를 들어, JavaScript나 PHP 같은 언어는 동적 타입 바인딩으로 인해 동적 타입 검사만을 지원합니다.&lt;/p&gt;

&lt;p&gt;타입 검사도 컴파일 시간에 수행하는 것이 실행 시간에 수행하는 것보다 효율적입니다. 정적 검사는 컴파일 시간에 타입 검사를 실행함으로써 효율적인 검사가 가능하지만, 프로그래밍의 유연성이 낮다는 단점이 있습니다. 그러나 최근에는 이러한 유연성이 오히려 가독성에 악영향을 끼친다고 인식되고 있기 때문에 큰 문제는 아닙니다. 동적 타입 검사는 반대로 프로그래밍의 유연성이 증가하지만, 그만큼 타입 검사가 어려워진다는 문제가 있습니다. 특히, 실행 중에 서로 다른 유형의 값을 서로 다른 시점에 저장할 수 있도록 허용되는 경우 타입 검사가 매우 복잡해집니다. 오른쪽의 Pascal 언어의 예시와 마찬가지로, C언어의 공용체(Union)가 바로 이러한 경우입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1970년대 중요하게 여겨졌던 언어 설계의 아이디어 중 하나는 강 타입(Strong Typing)입니다. 프로그램 내에 모든 타입이 정적으로 바인딩되어 타입 오류가 항상 탐지되는 언어를 &lt;span style=&quot;color:red&quot;&gt;강 타입 언어(Strongly Typed Language)&lt;/span&gt;라고 부릅니다. 이것은 꼭 하나의 변수가 하나의 타입만 가져야할 것처럼 보이지만, 실제로 그렇지는 않습니다. 두 개 이상의 타입이 저장되는 변수의 경우에는 실행 시간에 탐지하는 것도 허용됩니다.&lt;/p&gt;

&lt;p&gt;대표적으로 Ada 언어가 강 타입 언어에 가장 가까운 언어이고, C 언어와 C++ 언어는 강 타입 언어가 아닌 대표적인 언어입니다. Java는 C++의 파생 언어이지만 강 타입 언어에 매우 가깝습니다. Fortran 77 언어는 실제 매개변수와 형식 매개변수 간의 관계가 타입 검사되지 않기 때문에 강 타입 언어가 아니며, Pascal 언어는 강 타입 언어에 가깝지만 레코드 설계 측면에서는 강 타입 언어가 아닙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로는 타입 동등(Type Equivalence)에 대해 살펴보겠습니다. 먼저 서로 다른 두 변수가 서로 가지고 있는 값을 다른 변수에게 할당할 수 있는 경우에는 &lt;span style=&quot;color:red&quot;&gt;타입 호환(Type Compatible)&lt;/span&gt;이 가능하다고 정의됩니다. 스칼라 타입 변수의 경우에는 대부분 단순하고 엄격한 조건을 가지고 있지만, 배열이나 레코드와 같은 구조화된 타입에서는 규칙이 더 복잡해집니다.&lt;/p&gt;

&lt;p&gt;이러한 강제 변환(Coercion) 없이, 어떤 타입의 피연산자가 다른 타입의 피연산자로 대체될 수 있을 때 타입 동등이라고 부릅니다. 타입 동등은 타입 호환성보다 엄격한 조건임을 알 수 있습니다. 타입 동등은 다음과 같은 2개의 종류로 구분됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이름 타입 동등(Name Type Equivalence)&lt;/strong&gt; : 두 변수가 동일한 선언, 또는 동일한 타입 이름을 사용하는 선언으로 정의된 경우 타입 동등으로 정의됩니다. 구현하기는 쉽지만, 매우 제한적이라는 특징이 있습니다. 예를 들어, 정수의 부분 범위를 갖는 변수는 정수 타입 변수와 동등하지 않게 정의됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구조 타입 동등(Structure Type Equivalence)&lt;/strong&gt; : 두 변수의 타입이 동일한 구조를 갖는 경우 타입 동등으로 정의됩니다. 구조 타입 동등은 이름 타입 동등보다 유연하지만 구현하기가 더 어렵습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;변수의 &lt;span style=&quot;color:red&quot;&gt;영역(Scope)&lt;/span&gt;은 변수를 볼 수 있는 범위를 일컫습니다. 만약 변수를 해당 문장에서 참조할 수 있는 경우, &lt;strong&gt;볼 수 있다(Visible)&lt;/strong&gt;고 표현합니다. 변수가 프로그램이나 블록 내에 정의되면 &lt;span style=&quot;color:red&quot;&gt;지역 변수(Local Variable)&lt;/span&gt;이라고 합니다. 반대로 &lt;span style=&quot;color:red&quot;&gt;비지역 변수(Nonlocal Variable)&lt;/span&gt;은 해당 프로그램이나 블록 내에서 볼 수 있지만, 그곳에서 선언되지 않은 경우를 말합니다. &lt;strong&gt;전역 변수(Global Variable)&lt;/strong&gt;은 비지역 변수 중 하나라고 볼 수 있습니다. 비지역 변수는 그 규칙에 따라 정적 영역과 동적 영역으로 구분할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정적 영역(Static Scoping)&lt;/strong&gt;은 ALGOL 60에서 처음 도입되었으며, 실행 전에 변수의 영역이 정적으로 정해지는 것을 말합니다. 정적 영역은 주로 중첩된 부프로그램에서 생성됩니다. 예를 들어 아래와 같은 경우, 변수 x는 big이라는 프로시저에서 선언되었습니다. 그런데 sub1이라는 프로시저에서 변수 x에 대한 참조가 발생합니다. sub1 내에서 변수 x를 선언하지 않았다고 하면, sub1의 상위 프로시저를 탐색하여 변수 x에 대한 선언을 찾습니다. 프로시저의 호출 순서가 big -&amp;gt; sub2 -&amp;gt; sub1이라서 sub1의 상위 프로시저가 sub2라고 착각할 수도 있지만, sub1의 프로시저는 big 프로시저 안에서 정의되어있기 때문에 (정적 영역 하에서는) 무조건 big의 변수 x를 참조함에 유의하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;몇몇 언어는 &lt;span style=&quot;color:red&quot;&gt;블록(Block)&lt;/span&gt;이라는 개념을 도입하여 새로운 정적 영역이 코드 중간에 정의되는 것을 허용하고 있습니다. 블록이라는 코드의 일부분에서만 사용할 수 있는 지역 변수를 선언할 수 있으며, 스택 동적으로 선언되기 때문에 블록 내에 진입할 때 기억공간에 할당되고 블록을 빠져나올 때 기억공간에서 해제됩니다. 이것은 C 언어에서 다음과 같이 temp라는 변수처럼 사용됩니다.&lt;/p&gt;

&lt;p&gt;정적 영역은 많은 상황에서 잘 작동하지만, 여러가지 문제점을 내포하고 있습니다. 첫째로, 호출할 수 없어야 하는 프로시저에 대한 오류는 컴파일러에서 오류로 감지되지 않는다는 문제가 있습니다. (영역 구멍) 둘째로, 변수와 부프로그램에 대한 접근을 너무 많이 허용한다는 것입니다. 또한 프로그램을 업데이트할 때 문제가 발생할 소지가 많은데, 이러한 접근 방식을 제대로 이해하지 못하고 코드를 추가할 경우 필요 이상으로 전역 변수를 사용하거나 접근 방식이 꼬일 가능성이 높습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;동적 영역(Dynamic Scope)&lt;/strong&gt;은 부프로그램들의 상호간의 공간 배치가 아닌, 부 프로그램의 호출 시퀀스에 기반한 영역 방식입니다. 따라서 동적 영역은 실행 시간에 결정됩니다. APL, SNOBOL4, LISP의 몇몇 분파 언어들에서 사용되는 방식이며, 프로그램 단위 간 편리하게 매개변수를 전달할 수 있다는 장점이 있습니다. 정적 영역에서 보았던 big, sub1, sub2 프로시저를 다시 보시면 호출 순서가 big -&amp;gt; sub2 -&amp;gt; sub1 이었습니다. 따라서 동적 영역이라고 가정하면 sub1에서 참조하는 x는 sub2에서 선언한 x가 됩니다.&lt;/p&gt;

&lt;p&gt;동적 영역 또한 문제가 발생할 수 있습니다. 첫째로, 부프로그램의 지역 변수는 실행 중인 다른 부프로그램에서 모두 볼 수 있습니다. 그들간의 코드상 거리와는 상관이 없기 때문에, 지역 변수를 보호할 수 있는 방법이 없고 결과적으로 정적 영역보다 덜 신뢰적인 프로그램이 만들어지게 됩니다. 둘째로, 비지역 변수를 참조할 때 정적으로 타입 검사할 수 없습니다. 마지막으로, 변수에 대한 참조가 항상 동일한 변수에 대해 일어나는 것이 아니기 때문에 가독성이 떨어지는 문제도 있습니다.&lt;/p&gt;

&lt;p&gt;따라서 동적 영역은 정적 영역에 비해 널리 사용되지 않고 있습니다. 일반적으로 정적 영역 언어가 가독성이 좋고, 더 신뢰적이고, 더 빠르게 실행되는 것이 정설입니다.&lt;/p&gt;

&lt;p&gt;다음으로는 변수의 영역과 수명에 대해 알아보겠습니다. 변수의 영역과 수명은 얼핏 보면 동일하거나, 거의 관련이 있는 것처럼 보입니다. 그러나 상황에 따라 완전히 달라질 수 있습니다. 먼저 변수의 영역과 수명에 대한 정의부터 다시 해보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;영역(Scope)&lt;/strong&gt; : 변수의 선언부터 프로시저의 마지막 예약어까지의 범위&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수명(Lifetime)&lt;/strong&gt; : 프로시저에 진입한 시점부터 프로시저의 실행이 종료된 시점까지의 기간&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 오른쪽 코드에서 변수 sum의 영역과 수명을 각각 계산해보겠습니다. 먼저 변수 sum의 영역은 compute 프로시저에 완전히 포함됩니다. printheader 프로시저가 compute 프로시저 안에서 실행되지만, sum의 영역은 printheader 함수의 내부까지 포함하지는 않습니다. 그러나 sum의 수명은 printheader가 실행되는 시간도 포함되며, printheader 호출 전에 기억공간에 바인딩 된 sum은 printheader의 실행 동안과 그 이후에도 지속됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코드에 있는 어떤 문장의 &lt;span style=&quot;color:red&quot;&gt;참조 환경(Referencing Environment)&lt;/span&gt;은 그 문장에서 볼 수 있는 모든 이름의 모음입니다. 정적 영역 언어라면 어떤 문장의 참조 환경은 그 지역에서 선언된 변수와 그 조상 영역에서 선언된 변수의 모음이 됩니다. 동적 영역 언어라면 지역 변수와 함께 현재 활성화 되어있는 다른 모든 부프로그램(Active Procedure)에서 선언된 변수로 구성됩니다.&lt;/p&gt;

&lt;p&gt;참조 환경을 더 쉽게 이해하기 위해서 오른쪽의 코드를 보겠습니다. 1번 위치에서 참조 환경은 sub1 프로시저에서 선언된 x, y와 그 상위 프로시저인 example에서 선언된 a, b입니다. 2번 위치에서 참조 환경은 sub3에서 선언된 x와 example에서 선언된 a, b가 됩니다. sub2에서 선언된 x는 당연히 무시되는데, 이것을  숨겨진 변수(Hidden Variable)라고 합니다. 3번 위치에서 참조 환경은 sub2에서 선언된 x와 example에서 선언된 a, b입니다. 4번 위치에서 참조 환경은 example에서 선언된 a, b가 되는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/005/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;이름 상수(Name Constant)&lt;/span&gt;는 단지 한 번만 값에 바인딩되는 변수입니다. 예를 들어 원주율 3.14159265… 의 값을 PI로 할당해놓으면 가독성이 상승하는 효과가 있습니다. Java의 final 키워드가 대표적인 예시입니다.&lt;/p&gt;

&lt;p&gt;마지막으로 변수가 기억 공간에 바인딩되는 시점에 값을 바인딩 하는 것을 &lt;span style=&quot;color:red&quot;&gt;초기화(Initialization)&lt;/span&gt;라고 부릅니다. 만약 변수가 기억공간에 정적으로 바인딩되면 바인딩과 초기화는 실행 시간 이전에 일어납니다. 만약 기억공간 바인딩이 동적이라면 초기화도 동적입니다. 대표적으로 C 언어에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int sum = 0;&lt;/code&gt; 과 같은 문장이 초기화입니다.&lt;/p&gt;

&lt;p&gt;5장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry><entry><title type="html">Evolution of the Major Programming Languages</title><link href="http://localhost:4000/pl/evolution-of-the-major-programming-languages/" rel="alternate" type="text/html" title="Evolution of the Major Programming Languages" /><published>2023-08-23T00:00:00+09:00</published><updated>2023-08-23T00:00:00+09:00</updated><id>http://localhost:4000/pl/evolution-of-the-major-programming-languages</id><content type="html" xml:base="http://localhost:4000/pl/evolution-of-the-major-programming-languages/">&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/01.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로그래밍 언어론의 2장은 지금까지 개발되었던 프로그래밍 언어에 대한 간단한 정리입니다. 과거부터 지금까지 개발된 프로그래밍 언어의 종류는 매우 많지만, 이러한 프로그래밍 언어의 특징에 대해 하나하나 전부 외울 필요는 없습니다. 그 대신, 주요한 몇몇 언어에서 도입된 새로운 개념에 대해서만 간단하게 요약하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/02.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림은 이번 장에서 다룰 프로그래밍 언어의 계보입니다. 다루는 순서는 연도별로 정리되어 있지만, 같은 계보에 있는 언어들 (ex. FORTRAN과 그 후속 버전)은 한번에 같이 다루도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/03.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran은 Formula Translator의 약자로써, IBM이 개발한 IBM 704 하드웨어에서 동작하는 것을 목표로 개발된 프로그래밍 언어입니다. IBM 704는 부동 소수점 연산이 가능했던 최초의 하드웨어였기 때문에, 이를 구동하기 위해 1954년 IBM에서는 The IBM Mathematical Formular Translating System이라는 보고서를 작성하였고, 이것이 Fortran 언어의 원형인 Fortran 0입니다. Fortran 0가 실제로 구현되지는 않았지만, 구현 도중 언어 시스템이 계속 수정되면서, 1957년 드디어 Fortran 1이 개발됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/04.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran I의 특징은 동적 공간이 없었으며, 반복문을 동작하기 위하여 좋은 배열이 필요했습니다. 또한 변수 중 I, J, K, L, M, N은 정수형 타입이었으며, 다른 모든 변수는 부동 소수점 타입이라는 규약이 있었습니다. 하지만 문자열 처리가 불가능했고, 강력한 입출력 시스템을 갖지 못했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/05.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/06.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran I이 가지는 의의는 컴파일러를 사용하는 최초의 고급 언어라는 것입니다. Fortran I의 특징을 정리하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수의 이름은 최대 여섯 글자로 제한됨&lt;/li&gt;
  &lt;li&gt;반복문은 Do 반복문만 존재&lt;/li&gt;
  &lt;li&gt;입출력 형식이 정해져 있음&lt;/li&gt;
  &lt;li&gt;사용자 정의 부프로그램 생성 가능&lt;/li&gt;
  &lt;li&gt;3가지 분기를 가지는 선택문이 존재 (IF)&lt;/li&gt;
  &lt;li&gt;데이터 타입을 표기하는 문법이 없음&lt;/li&gt;
  &lt;li&gt;부분 컴파일이 불가능&lt;/li&gt;
  &lt;li&gt;컴파일러는 18명의 기술자에 의해 1957년 4월에 개발됨&lt;/li&gt;
  &lt;li&gt;IBM 704의 낮은 신뢰도로 인해, 400줄이 넘는 프로그램은 컴파일이 정상적으로 수행되지 않음&lt;/li&gt;
  &lt;li&gt;코드는 매우 빠르게 수행됨 (최적화가 잘됨)&lt;/li&gt;
  &lt;li&gt;불과 1년이 지나 IBM 704를 위한 코드 중 절반 이상이 Fortran I으로 작성될 정도로 널리 보급됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/07.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran II는 Fortran I이 나온지 약 1년 후에 배포되었습니다. Fortran I이 가지고 있던 단점을 보완하여 부분 컴파일을 가능하게 했고, 이로 인해 Fortran I보다 긴 프로그램 제작이 가능해졌습니다. 그 외에 Fortran I의 버그를 수정하여 안정성을 향상시켰습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/08.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran II 다음에 Fortran III이 개발되긴 하였으나, 널리 쓰여지지 않았기 때문에 금세 잊혀졌습니다. 대신 1960년대 초에 개발된 Fortran IV는 엄청난 성공을 거두었습니다. Fortran IV는 명시적 타입 선언, 논리 IF문, 그리고 부프로그램을 매개변수로 취급하여 다른 부프로그램에 전달할 수 있는 기능이 추가되었습니다. Fortran IV는 ANSI에 의해 1966년에 표준화가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/09.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran IV 다음으로는 Fortran 77이 발표되었습니다. Fortran 77은 문자 스트링 처리, 논리 반복 제어문, IF-THEN-ELSE 문이 추가되었습니다. Fortran 77은 1978년에 표준화가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/10.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 90은 Fortran 77에서 상당한 발전을 이루어서 모듈, 동적 배열, 포인터, 재귀문, Case문, 매개변수 타입 체크 기능이 추가되었습니다. Fortran 90은 1992년에 표준화가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/11.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran 90 이후, Fortran은 5년 주기의 마이너 업데이트, 10년 주기의 메이저 업데이트를 개발하기로 결정됩니다. 그로 인해 Fortran 95는 Fortran 90의 마이너 업데이트 버전입니다. 기존 문법 중 쓰이지 않는 문법도 제거되었습니다.&lt;/p&gt;

&lt;p&gt;계획대로라면 Fortran 95 이후, 2000년에 메이저 업데이트를 포함한 Fortran 2000이 개발되었어야 했지만, 기술자들의 합의가 이루어지지 않아 2003년에야 Fortran 2003으로 발표됩니다. 사실 메이저 업데이트라고 해도 크게 변한 것은 없었습니다. (그래서 위와 동일하다고 ditto로 표시되어 있습니다)&lt;/p&gt;

&lt;p&gt;이 글을 쓰는 시점에서 최신 버전은 Fortran 2018입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/12.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortran은 초창기에 개발된 고급 언어이지만, 현재까지도 적지 않은 사용자를 보유하고 있습니다. 가장 큰 이유로는 Fortran 90 이전의 모든 Fortran 언어는 최적화가 매우 훌륭하기 때문에, 모든 변수의 타입과 저장 공간이 런타임 이전에 고정되었다는 것입니다. 즉, 런타임에서 새로 할당되는 변수가 한 개도 없었다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;Fortran의 성공은 컴퓨터가 사용되는 방식을 크게 변화시켰고, 많은 프로그래밍 언어가 Fortran의 문법으로부터 영향을 받았기 때문에, 컴퓨팅 세계에서 &lt;em&gt;공통어(Lingua Franca)&lt;/em&gt;라고 불리기도 합니다. (Alan Perlis, 1978)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/13.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;처음으로 개발된 함수형 프로그래밍 언어는 LISP입니다. LISP는 1958년 MIT에 근무하던 John McCarthy에 의해 개발되었습니다. 이 당시에도 연구자들은 AI에 대한 관심이 있었기 때문에, AI 연산에 어울리는 프로그래밍 언어를 목표로 설계되었습니다. LISP의 문법은 Lambda Calculus를 기반으로 만들어졌다는 특징이 있습니다. 예를 들어, 1부터 10까지 출력하는 프로그램을 Python으로 구현하면 반복문을 사용한 방법이 먼저 떠오르지만, 람다식을 기반으로 만든다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[print(x) for x in range(10)]&lt;/code&gt;와 같이 나타낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/14.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LISP은 당시 유행하던 Fortran과는 다르게, Atom과 List라는 데이터 타입을 가지고 있습니다. Atom은 상수나 심볼을 의미하며, List는 Atom으로 이루어진 자료구조입니다. List는 저희가 자료구조 시간에 배운 연결 리스트와 동일한 구조이며, 위의 그림처럼 리스트 내부에는 부분 리스트가 존재할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/15.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LISP는 처음 개발된 이후부터 현재까지 AI 응용 분야에서 절대적인 위치에 존재하고 있습니다. LISP가 발전하면서 기존에 가지고 있던 느린 실행 시간이란 문제도 인터프리터도 컴파일러로 변경되면서 보다 빠른 실행 시간을 갖도록 개선되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/16.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LISP의 문법은 위와 같이 연산 기호가 앞에 오는 전위 표기(Prefix) 구조를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/17.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LISP에서 함수는 위와 같이 정의할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/18.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LISP에서 반복문은 위와 같이 나타낼 수 있습니다. 위 슬라이드의 함수는 구구단을 출력하는 함수로, (printDan 2)로 호출하여 구구단 2단을 출력하게 만드는 코드입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/19.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 LISP 계열 언어는 초창기에 개발된 LISP보다 그 개선형들이 더 많이 사용되고 있습니다. 1970년대 중반에 MIT에서 LISP의 파생 언어인 Scheme이 개발되었는데, LISP보다 작은 규모, 정적 영역의 활용, 함수를 일등급 객체로 취급하여 매개변수나 리스트의 원소 등으로 취급할 수 있는 기능이 추가되었습니다. Scheme은 그 간단한 문법으로 인해 교육용으로 많이 사용되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/20.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또 다른 LISP 계열 언어로써 Common LISP이 있는데, Scheme과는 다르게 오히려 초창기 LISP보다 복잡한 구조를 가지고 있습니다. 그 이유는 LISP 계열 파생 언어를 한 개로 결합했기 때문인데, 구조가 복잡한 대신 LISP 파생 언어들로 작성된 프로그램들을 모두 이식할 수 있다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/21.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 이전에 존재하던 프로그래밍 언어들은 모두 특정한 하드웨어에 종속된 언어였습니다. 따라서 범용성을 늘리고자 하는 연구 끝에 보편적으로 사용할 수 있는 최초의 프로그래밍 언어인 ALGOL 60 언어가 등장하게 됩니다. ALGOL은 Algorithmic Language의 약자입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/22.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL의 설계는 1958년부터 시작되었습니다. 이 때 설계의 목표는 수학적 표기에 가까운 문법, 알고리즘의 설명을 위해 이 언어를 사용하는 것이 가능해야할 것, 그리고 반드시 자동적으로 기계어로 번역되어야 한다는 것이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/23.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL에서 정립한 특징은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터 타입의 형식화&lt;/li&gt;
  &lt;li&gt;변수명 길이 제한이 없음&lt;/li&gt;
  &lt;li&gt;배열의 차원 제한이 없음&lt;/li&gt;
  &lt;li&gt;매개변수가 입출력에 따라 구분됨&lt;/li&gt;
  &lt;li&gt;색인 첨자를 괄호로 표시함&lt;/li&gt;
  &lt;li&gt;복합문을 가능하게 만듬 (begen - end로 표기)&lt;/li&gt;
  &lt;li&gt;각 문구는 세미콜론으로 구분함&lt;/li&gt;
  &lt;li&gt;배정문은 :=로 정의함&lt;/li&gt;
  &lt;li&gt;조건문 if에서 else-if 문을 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;프로그램에서 필요로하는 입출력이 없음 (이로 인해 기계에 종속적일 수 있기 때문에)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/24.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL은 1958년에 ALGOL 58이란 보고서로 처음 탄생하였습니다. 이것이 실제 구현되지는 않았지만, 이 보고서를 기반으로 MAD나 JOVIAL 등의 언어가 영향을 받아 구현되었습니다. ALGOL 58이 처음 발표되었을 때, IBM은 초기에 관심을 보였으나 이미 IBM 700번대 컴퓨터에 도입된 Fortran을 유지하기로 결정하여 포기하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/25.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 58을 실제로 구현하기 위해 연구자들은 파리에서 6일간 회의를 진행했습니다. 회의 기간이 길지는 않았지만, 이 때 추가된 기능들이 상당히 많은데요. 정리하자면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;블록 구조 (지역화의 도입)&lt;/li&gt;
  &lt;li&gt;부프로그램에 매개변수를 전달하는 두 가지 다른 방법이 도입됨 (Call by Value, Call by Name)&lt;/li&gt;
  &lt;li&gt;부프로그램을 재귀적으로 호출하는 것이 가능&lt;/li&gt;
  &lt;li&gt;스택 동적 배열이 허용됨 (6장에서 다룸)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만 입출력 형식은 기계에 종속적일 수 있기 때문에 여전히 다루지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/26.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/27.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 ALGOL 60이 성공한 것과 실패한 것을 나누어 생각해보겠습니다. 먼저 ALGOL 60이 성공한 것부터 말하자면, 컴퓨터 알고리즘을 표기하는 방식이 ALGOL 60을 기준으로 기술되었다는 것입니다. 그렇기 때문에 1960년 이후 설계된 모든 명령형 프로그래밍 언어는 ALGOL 60을 기반으로 설계되었습니다. (C, Java, Pascal 등) 그리고 처음에도 소개했듯이, ALGOL 60은 최초의 기계에 독립적인 프로그래밍 언어이고, 프로그래밍 언어의 문법을 BNF(Backus-Naur Form)으로 규정화하였습니다.&lt;/p&gt;

&lt;p&gt;ALGOL 60이 실패한 점은 결국 대중화되지 못했다는 것입니다. 특히 미국에서 굉장히 부진했는데, 그렇다고 유럽에서 널리 쓰인 것도 아니었습니다. 그 이유는 여러 가지가 있었지만, 몇 개만 소개하자면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입출력의 부재로 인해 다른 컴퓨터에 이식하는 것을 어렵게 만듬&lt;/li&gt;
  &lt;li&gt;언어가 너무 유연했기 때문에 구현하기 어려웠음&lt;/li&gt;
  &lt;li&gt;기존에 사용하던 Fortran의 견고한 대중성&lt;/li&gt;
  &lt;li&gt;처음 도입된 BNF 문법을 이해하기 어려웠음&lt;/li&gt;
  &lt;li&gt;IBM으로부터의 지원 결여&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/28.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음으로 설명할 언어는 비즈니스 용도로 개발된 COBOL입니다. COBOL이 개발되기 전, 1957년에 FLOW_MATIC이라는 언어가 비즈니스 용도로 개발되었으나, 이 언어는 UNIVAC 회사의 소유로써 UNIVAC의 컴퓨터를 위해 설계되었었기 때문에 범용적이지 못했습니다. 또 다른 언어는 미국 공군(USAF)에 의해 개발된 AIMACO가 있었으나, FLOW-MATIC과 큰 차이가 없었고, IBM이 COMTRAN이라는 비즈니스용 언어를 설계하였으나, 결국 구현되지는 못했습니다. 이 외에도 여러 언어들이 비즈니스 용도로 계획되었으나, 각자 가지고 있는 단점으로 인해 주력화되지는 못했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/29.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;COBOL 언어는 기존 비즈니스용 언어였던 FLOW-MATIC을 기반으로 만들어졌습니다. 이 당시 FLOW-MATIC은 하이픈을 포함해 12개의 문자로 이름을 짓는 것이 가능했고, 영어로 연산을 표기했습니다. 이 말인 즉슨, 1 + 2와 같이 연산 기호를 사용하지 않고 ADD 1, 2 와 같이 표현했다는 뜻입니다. 또한 데이터와 코드는 완전히 구분되었고, 모든 구문의 첫 단어는 동사로 지정되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/30.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;COBOL을 위한 회의는 1959년 펜타곤에서 처음 열렸습니다. 비즈니스 용도가 목적인 만큼, 전문가가 아닌 일반인도 사용할 수 있도록 간단한 영어처럼 보이게 만들고, 보다 덜 효율적이더라도 사용하기 쉬워야만 했습니다. 또한 컴퓨터를 사용할 수 있는 사람들을 늘리고 현재 발생하고 있는 컴파일(구현) 문제들에 의해 지나치게 제약되어서는 안되었습니다.&lt;/p&gt;

&lt;p&gt;COBOL 설계를 위한 구성원들은 전부 컴퓨터 제조업자들과 국방 관계자였습니다. (Department of Defence; DoD)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/31.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;COBOL 언어는 Define으로 명명된 최초의 매크로가 포함된 첫 고급 언어입니다. 또한 Record라고 불리는 계층적 데이터 구조와 중첩된 선택문이 가능했습니다. 이름을 지을 때 FLOW-MATIC에서는 12개의 문자로 한정되었지만, COBOL은 30글자까지 가능하게 개선되었습니다. 또한 데이터 영역이 코드 영역과 완전히 구분되었다는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/32.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;COBOL에 가장 큰 영향을 미친 것은 바로 미 국방성이었습니다. 미 국방성의 설계 개입과 지원은 COBOL이 다른 언어들에 비해 성공할 수 있었던 주요한 이유로 평가됩니다. 미국에서는 여전히 국가 시스템의 일부분이 COBOL로 설계되었기 때문에 가끔 뜬금없이 COBOL 프로그래머를 구인하는 공고가 올라오곤 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/33.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이것은 COBOL로 작성된 프로그램의 예시입니다. 간단한 영어로 대부분 표현되어 있기 때문에 COBOL 언어를 모르더라도 대략적인 해석이 가능합니다. TIJA는 뭔가 싶었는데, 아무리봐도 그냥 임의로 지어진 이름인 것 같습니다. 혹시 다른 뜻으로 알고 계신 분이 있다면 댓글 부탁드립니다…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/34.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 소개할 언어는 BASIC 입니다. 두 수학자 John Kemeny와 Thomas Kurtz는 다트머스 대학교에서 근무하고 있었는데, 다트머스 대학교는 학부중심대학(Liberal Arts College)으로써 약 75%의 학생이 인문계열을 전공하였습니다. 두 수학자는 이러한 학생들을 위한 새로운 언어가 필요하다고 판단하여 이공계열 학생이 아닌 학생들이 이해하기 쉽도록 설계한 Beginner’s All-purpose Symbolic Instruction Code (BASIC)을 개발하였습니다.&lt;/p&gt;

&lt;p&gt;현재 BASIC 언어 중 가장 유명한 파생 언어는 마이크로소프트에서 개발한 Visual BASIC입니다. 아마 90년대에 태어나신 분이라면 한번쯤은 들어보신 언어일 것이라고 생각합니다.&lt;/p&gt;

&lt;p&gt;BASIC 언어는 시분할 개념을 도입한 최초의 언어입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/35.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PL/I는 모든 사람을 위해 개발된 첫 번째 대규모 언어입니다. IBM에 의하면, 이전까지 프로그래밍 언어를 사용하던 사용자들은 과학 용도로 사용하던 SHARE 그룹과 비즈니스적 용도로 사용하던 GUIDE 그룹이 있었습니다. SHARE 그룹은 Fortran을, GUIDE 그룹은 COBOL을 주로 사용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/36.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 1963년부터 두 사용자 그룹이 충돌하려는 조짐이 보이기 시작했습니다. 당시 과학 용도로 사용하던 사용자들은 대규모 데이터를 처리하기 위해 효율적인 입출력 기능을 가진 COBOL에 관심을 보였고, 비즈니스 용도로 사용하던 사람은 회귀 분석을 수행하기 위해 부동 소수점 데이터 처리와 배열 기능에 관심을 보이기 시작했습니다. 이것은 각각 분리되었던 두 사용자 그룹이 서로의 언어와 컴퓨터가 필요로 한다는 것을 의미했고, 이것으로 인해 두 종류의 컴퓨터 뿐만 아니라 각각의 프로그래밍 언어를 사용할 수 있는 프로그래머의 추가 고용이 필요했습니다.&lt;/p&gt;

&lt;p&gt;따라서 IBM은 두 용도로 모두 사용할 수 있는 범용적인 컴퓨터와 그 언어를 개발하는 작업에 착수합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/37.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 언어를 설계하기 위한 위원회가 만들어졌는데, 구성원은 IBM 직원 3명, SHARE 직원 3명으로 이루어졌습니다. 초창기 컨셉은 Fortran IV의 확장으로 기획되었으며, 코드명 NPL (New Programming Language)로 불렸습니다. 1965년에 비로소 현재의 이름인 PL/I (Programming Language One)로 변경됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/38.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PL/I가 프로그래밍 언어에 기여한 부분은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동시에 실행할 수 있는 부프로그램을 생성할 수 있음&lt;/li&gt;
  &lt;li&gt;발생할 수 있는 예외를 처리할 수 있음&lt;/li&gt;
  &lt;li&gt;부프로그램을 재귀적으로 사용하는 것을 허용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 타입에 포인터가 추가됨&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;배열의 일부분이 참조될 수 있음 (ex. 2차원 행렬의 특정 행이 1차원 배열인 것처럼 참조될 수 있음)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 PL/I에서 추가된 새로운 구조는 너무 많았고, 설계에 결함도 상당히 많았습니다. 게다가 프로그래밍 언어가 너무 방대하고 복잡하다는 단점이 있었습니다. 하지만 적어도 1970년대까지는 이 언어가 상당히 많이 사용되었기 때문에 어느 정도 성공은 거뒀다고 평가받고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/39.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 소개할 언어는 APL과 SNOBOL입니다. 이 두 언어는 앞서 소개했던 다른 언어들에 비해 중요도가 높지 않기 때문에 간단하게만 설명하고 넘어가도록 하겠습니다. APL과 SNOBOL은 최초의 동적 언어로서의 의미가 있지만, 이후에 나타나는 다른 언어들에 그다지 큰 영향을 남기지는 못했습니다.&lt;/p&gt;

&lt;p&gt;동적 언어로 불리는 이유는 기본적으로 동적 타입과 동적 공간 할당을 지원하기 때문입니다. 예를 들어, 이 언어들에서는 변수가 선언될 때 타입이 선언되지 않고 값이 배정될 때 타입이 결정됩니다. 또한 값이 할당되기 전에는 필요한 기억 공간을 알 수 없기 때문에, 변수는 값이 배정되어야만 기억 공간에 할당됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/40.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;APL(A Programming Language)은 1960년 쯤에 IBM의 Kenneth Iverson에 의해 설계되었습니다. 사실 초창기에는 하드웨어의 구조를 설명하는 의도로 제작되었지만, 나중에 프로그래밍 언어로써 목적이 바뀌게 됩니다. 그래서 그런지 몰라도, 이 언어는 굉장히 많은 연산자를 가지고 있으며, 대부분의 코드가 간단하게 표기되지만 읽기가 매우 힘들다는 단점이 있습니다. 예를 들어 Daniel McCracken이라는 프로그래머는 4줄로 작성된 APL 프로그램을 이해하는데 4시간이나 걸렸다고 합니다.&lt;/p&gt;

&lt;p&gt;그래서인지 APL은 널리 사용되지는 못했지만, 사용하고 있는 사람은 여전히 있습니다. 그리고 그 구조 또한 초창기에서 거의 변하지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/41.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SNOBOL은 1964년에 벨 연구소에 근무하던 Farber, Griswold, Polensky에 의해 설계되었습니다. SNOBOL은 텍스트 처리, 그 중에서도 문자열 패턴 매칭에 강한 성능을 가졌습니다. 그러나 특수 목적에 사용되는 것과 더불어 동적인 특징으로 인해 일반적인 다른 언어들보다 느리기 때문에, 그다지 많이 사용되지는 못했습니다. 그러나 여전히 몇몇 소수의 사용자들은 이 언어를 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/42.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 프로그램은 SNOBOL을 사용해서 더 이상 요청이 없을 때까지 문자열 입력을 계속 요청하는 프로그램입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/43.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SIMULA 67은 최초로 데이터 추상화에 대한 개념이 도입된 프로그래밍 언어입니다. 노르웨이 컴퓨팅 센터에서 일하던 Nygaard와 Dahl은 시스템 모의실험을 위해 SIMULA I 언어를 설계하였고, ALGOL 60 언어와 SIMULA I을 기반으로 SIMULA 67 언어를 구현하였습니다. 이 언어는 부프로그램의 실행이 끝나면 이전에 실행이 중단된 지점에서 다시 실행을 이어가는 Coroutine이라는 새로운 부프로그램을 설계하였으며, 그것을 위한 클래스, 객체, 그리고 상속이 도입되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/44.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 68은 ALGOL 60의 개정판이지만 ALGOL 60과 상당히 다른 구조를 가지고 있습니다. 안타깝게 ALGOL 60과 마찬가지로 그다지 널리 쓰이지는 못했지만, ALGOL 68은 프로그래밍 언어의 평가 기준 중 하나인 직교성을 처음으로 중요하게 논의하였다는 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/45.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL 68은 사용자 정의 데이터 구조와 동적 배열이라는 개념을 새로 도입하였습니다. 그러나 ALGOL 60에서 안좋은 점을 답습하여 언어 기술 문서를 너무 복잡하게 작성하였기 때문에 사람들로부터 외면받았습니다. 하지만 이 언어는 Pascal, C 언어를 포함한 후속 언어에 매우 강한 영향을 끼쳤기 때문에 역사적으로는 중요한 언어입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/46.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALGOL의 후속 언어라고 볼 수 있는 언어 중 하나는 Pascal 언어입니다. 이 언어는 ALGOL 68을 설계했던 위원 중 하나인 Niklaus Wirth에 의해 설계되었습니다. Pascal은 작고 간단하다는 특징으로 인해 프로그래밍 교육에 지대한 영향을 끼쳤으며, 1970년대 중반부터 1990년대 후반까지 대학교에서 프로그래밍 교육 용도로 사용되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/47.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C언어는 벨 연구소에 근무하던 Dennis Richie에 의해 시스템 프로그래밍 용도로 설계된 언어입니다. C 언어는 BCLP, B, ALGOL 68로 부터 영향을 받았는데, 강력한 연산자를 가지고 있지만 타입 검사를 거의 하지 않는다는 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;기존의 운영체제는 대부분 어셈블리어와 같은 저급 언어로 개발되었으나, C 언어는 처음부터 시스템 프로그래밍 용도로 설계된 언어이기 때문에 실제로 C 언어로 운영체제가 만들어졌습니다. 그 이름도 유명한 UNIX로써, UNIX의 성공과 더불어 C 언어는 현재까지도 널리 쓰이는 주요한 언어로 자리잡게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/48.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Prolog는 마르세유 대학교의 Comerauer, Roussel과 애든버러 대학교의 Kowalski에 의해 1970년대에 개발된 언어입니다. Prolog는 논리 프로그래밍을 위해 개발되었는데, 논리 프로그래밍은 술어 해석학 명제들을 명세화하는 것이라고 합니다. 즉, 관련된 정보와 요구한 결과를 계산하기 위한 추론 과정을 컴퓨터에게 제공함으로써 원하는 결과를 얻어내는 방식입니다. 그러나 Prolog는 매우 비효율적이라는 것이 증명되었고, 논리 프로그래밍을 필요로 하는 분야도 적었기 때문에 널리 사용되지 못했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/49.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어는 지금까지 나타난 언어 중에 가장 오랜 자원을 투자해 설계한 언어입니다. 이것은 COBOL과 마찬가지로 미 국방성(DoD) 주도로 개발이 시작되었으며, 무려 8년간의 기간동안 여러 제안서를 토대로 요구사항을 정립하였습니다. 이 언어의 이름은 최초의 프로그래머인 에이다 러브레이스로부터 딴 Ada로 붙여졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/50.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 언어는 패키지, 예외 처리, 포괄적 프로그래밍, 동시 실행에 대해 많은 기여를 남겼습니다. 그러나 설계 당시 경쟁적으로 요구사항이 추가되었고, 당시에 존재하던 소프트웨어 공학과 언어 설계에 대한 지식이 총동원되었기 때문에 Ada 언어의 컴파일러는 상당히 어려운 문제였습니다. Ada 언어 자체는 1980년 쯤에 등장했지만, Ada 언어를 컴파일할 수 있는 컴파일러는 1985년에서야 나타나기 시작했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/51.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ada 95는 Ada 언어의 개정판으로써 1988년부터 설계가 시작되었습니다. 이때부터 객체 지향 프로그래밍의 개념이 도입되었으며, 상속 시 파생 클래스에 새로운 요소를 추가하는 것이 가능해졌습니다. 또한 공유된 데이터에 대한 제어 메커니즘의 향상 (ex. private), 새로운 동시 프로세스, 더 유연한 라이브러리가 추가되었습니다. 그러나 C++ 언어의 등장으로 인해 Ada 언어는 빠르게 인기를 잃었기 때문에 현재는 그렇게 많이 사용하지는 않습니다. 가장 최근에 발표된 개정판은 Ada 2012입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/52.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Smalltalk는 1960년대 후반 유타 대학교에서 박사과정을 하던 Alan Kay로 부터 처음 제안되었습니다. 그러나 당시에는 그가 고안했던 기능을 구현하기 위한 하드웨어가 없었기 때문에, 1970년대에 되서야 구현되었습니다.&lt;/p&gt;

&lt;p&gt;지금까지 소개된 프로그래밍 언어에서 객체 지향 프로그래밍의 일부 기능을 지원하는 언어는 있었지만, 완전한 객체 지향 프로그래밍을 지원하는 언어는 소개되지 않았습니다. Smalltalk는 완전한 객체 지향 프로그래밍 언어를 지원하는 첫 언어라는데 그 의의가 있습니다. 또한 그래픽 유저 인터페이스를 지원했다는 특징도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/53.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C++ 언어는 벨 연구소에서 근무하던 Bjarne Stroustrup에 의해 1980년에 개발된 언어입니다. 당시 존재하던 C 언어와 SIMULA 67 언어를 기반으로 만들어졌으며, Smalltalk와 같이 객체 지향 프로그래밍을 지원하기 위해 설계되었습니다. C 언어와 다르게 예외 처리를 지원한다는 특징이 있습니다. C++ 언어는 절차적 프로그래밍과 객체 지향 프로그래밍을 모두 지원하도록 설계되었기 때문에 굉장히 방대하고 복잡하게 설계되었습니다. 객체 지향 프로그래밍의 발전으로 인해 C++는 급격하게 인기를 얻게 되었고, 이것은 현재도 마찬가지입니다. 표준화는 ANSI에 의해 1997년에 제정되었고, 대표적인 분파로 마이크로소프트의 Managed C++가 있습니다. 참고로 현재 윈도우 운영체제는 C 언어와 C++ 언어를 기반으로 만들어지고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/54.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 외에 객체 지향 프로그래밍과 관련된 언어는 1992년에 개발된 Eiffel, 2000년에 개발된 Delphi가 있습니다. 그러나 이 언어들은 다음 페이지에 나오는 언어로 인해 묻혀버리고 맙니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/55.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Java 언어는 썬 마이크로시스템즈에 의해 1990년대 초반에 개발되었습니다. 썬 마이크로시스템즈는 컴퓨터 뿐만이 아니라 냉장고나 TV, 오븐 같은 가전 기기들에서 사용할 수 있는 범용적인 언어가 필요했는데, 당시 널리 쓰이던 C와 C++ 언어는 이것이 불가능했기 때문입니다. Java 언어는 C++ 언어에서 신뢰성에 영향을 미치는 포인터나 구조체, 공용체와 같은 개념을 모두 빼버리고 오로지 객체 지향 프로그래밍만을 위해 설계되었습니다. 이것은 가전 기기에 신뢰성이 매우 중요한 요소였기 때문입니다. 또한 동시성을 위해 애플릿이라는 개념도 새로 도입하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/56.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Java는 그 외에도 GUI나 데이터베이스를 위한 라이브러리 추가, 자바 가상 머신으로 인해 이식성이 높은 특징이 있습니다. Java 언어는 웹 프로그래밍 분야에서 널리 쓰이게 되며 빠르게 사용자를 늘려왔습니다. Java 언어의 최신 버전은 2023년에 발표된 Java 20입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/57.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스크립트 언어는 스크립트(Script) 라는 명령어 리스트를 해석하기 위해 하나의 파일로 저장했던 것에서 유래했습니다. 초기 스크립트 언어는 프로그래밍 언어와 차이가 있었으나, 그 발전 과정에서 프로그래밍 언어와 같은 부프로그램, 변수, 제어문 등이 추가됨으로써 프로그래밍 언어와 점점 가까워졌습니다. 여기서는 대표적으로 몇 개의 스크립트 언어를 간단하게 소개하고 넘어가겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Perl&lt;/strong&gt; : Perl은 1987년 Larry Wall에 의해 개발되었습니다. Perl의 특징은 변수들이 정적 타입을 갖지만 묵시적으로 선언된다는 것입니다. Perl의 변수 타입은 변수명의 첫 글자로부터 정해지는데, 스칼라 변수는 $로 시작하고, 배열은 @, 해시는 %로 선언됩니다. Perl의 성능은 강력하지만, 안정성이 낮다는 단점이 있습니다. 주로 웹 프로그래밍 분야에서 많이 사용하며, 유닉스 시스템에서도 종종 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; : JavaScript는 1995년 넷스케이프에 근무하던 Brendan Eich에 의해 개발되었습니다. 원래 이름은 LiveScript였으나, 당시 유행하던 Java 언어의 인기에 편승하기 위해 JavaScript로 변경하였습니다. JavaScript는 주로 동적인 HTML 문서를 만들기 위해 웹 프로그래밍 분야에 사용되며, 클라이언트에서 인터프리팅 된다는 특징이 있습니다. Java와는 사실 그다지 큰 관련이 없습니다. 프로그래머 사이의 농담 중에, Java와 JavaScript의 관계는 인도와 인도네시아의 관계와 동일하다라는 말이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PHP&lt;/strong&gt; : PHP는 1994년 아파치 그룹의 회원인 Rasmus Lerdorf에 의해 개발되었습니다. JavaScript와는 다르게 PHP는 서버에서 인터프리팅하는 특징이 있습니다. 주로 웹에서 데이터베이스 관리 시스템을 운영할 때 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/58.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt; : Python은 1991년 네덜란드의 프로그래머 귀도 반 로썸에 의해 개발되었습니다. 1989년 크리스마스 주에 할게 없어서 연구실에 나와서 만든 에피소드로 유명합니다. Python은 객체 지향 스크립트 언어로써 타입 검사는 하지만 동적인 타입을 갖고 있다는 특징을 가지고 있습니다. Python은 CGI 프로그래밍과 폼 처리에 사용되며 리스트, 튜플, 해쉬 등의 자료구조를 지원합니다. 사실 요즘은 거의 만능으로 사용되는 언어입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Lua&lt;/strong&gt; : Lua는 1993년 리우 데 자네이루 교황청대학교의 Roberto Ierusalimschy, Waldemar Celes, Luis Herique de Figueiredo에 의해 개발되었습니다. Lua는 확장성을 갖는 절차적 함수형 언어를 지원하는 스크립트 언어를 목적으로 하였으며, 객체 지향 프로그래밍도 가능하도록 확장이 가능하다는 특징을 가지고 있습니다. Lua는 주로 게임 프로그래밍에서 많이 쓰이는 언어입니다. Lua의 테이블이라는 1개의 자료구조만 존재합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/59.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ruby는 1996년 Yukihiro Matsumoto에 의해 개발되었습니다. Ruby는 Perl과 Python과는 달리 순수 객체 지향 언어로써, 클래스와 객체들도 모두 동적이라는 특성을 가지고 있습니다. 또한 Python과 마찬가지로 Ruby도 사용자가 목적에 맞게 언어를 확장할 수 있다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/60.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C#은 마이크로소프트가 .NET 프로젝트와 함께 개발된 언어입니다. 기본적으로 C++, Java 등의 언어에서 강하게 영향을 받았으며, 컴포넌트 기반(특히 .NET Framework) 소프트웨어 개발을 위한 목적으로 설계되었습니다. 그리고 C#은 개발사인 마이크로소프트에서 사용하던 C#, Visual Basic, .NET, Managed C++ 등의 언어와 결합하기 위한 Common Type System을 사용합니다. 따라서 이들은 공통 라이브러리를 사용하고 동일한 중간 언어로 번역됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/61.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 마크업/프로그래밍 하이브리드 언어에 대해 두 개만 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;XSLT(eXtensible Stylesheet Language Transformation)&lt;/strong&gt; : XSLT가 나타난 배경은 기존에 사용하던 XML(eXtensible Markup Language)라는 마크업 언어로 생성된 XML 문서를 HTML 문서로 변환하기 위해서입니다. XML과 HTML 둘 다 마크업 언어이지만, XSLT는 마크업 언어를 기반으로 하면서도 반복문과 같은 프로그래밍 언어의 특징을 조금 갖고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JSP(Java Server Pages)&lt;/strong&gt; : JavaScript와는 다르게 JSP는 진짜 자바와 관련이 있는 언어입니다. 서블릿(Servlet)은 웹 서버 시스템에서 실행되는 Java 클래스이고, 웹 브라우저에 있는 HTML 문서에 의해 실행이 요청됩니다. JSP는 Java와 마찬가지로 자바 가상 머신 위에서 실행되므로, JSP 소스를 수정 없이 다른 Java 프로그램에 넣어도 실행이 가능합니다. JSP 문서의 처리를 제어하기 위해서는 JSTL(Java Server Pages Standard Tag Library)을 이용합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/PL/002/62.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지금까지 많은 프로그래밍 언어를 살펴보았습니다. 특히 소개했던 주요 언어의 특징을 단순히 외우기보다는 해당 언어가 프로그래밍 언어의 역사에 어떤 영향을 끼쳤는지를 중심으로 생각해보시는 것을 권장드립니다. 최상단에 나와있는 프로그래밍 언어의 계보를 보면서 공부하시면 더 좋습니다.&lt;/p&gt;

&lt;p&gt;2장의 내용은 여기까지입니다. 읽어주셔서 감사합니다!&lt;/p&gt;</content><author><name>Joonsu Ryu</name></author><category term="studies" /><category term="programming languages" /><summary type="html"></summary></entry></feed>